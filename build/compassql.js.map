{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "build/src/config.js",
    "build/src/constraint/base.js",
    "build/src/constraint/encoding.js",
    "build/src/constraint/field.js",
    "build/src/constraint/index.js",
    "build/src/constraint/spec.js",
    "build/src/constraint/value.js",
    "build/src/cql.js",
    "build/src/enumerator.js",
    "build/src/generate.js",
    "build/src/model.js",
    "build/src/nest.js",
    "build/src/property.js",
    "build/src/propindex.js",
    "build/src/query/encoding.js",
    "build/src/query/expandedtype.js",
    "build/src/query/groupby.js",
    "build/src/query/index.js",
    "build/src/query/normalize.js",
    "build/src/query/shorthand.js",
    "build/src/query/spec.js",
    "build/src/query/transform.js",
    "build/src/ranking/aggregation.js",
    "build/src/ranking/effectiveness/axis.js",
    "build/src/ranking/effectiveness/base.js",
    "build/src/ranking/effectiveness/dimension.js",
    "build/src/ranking/effectiveness/facet.js",
    "build/src/ranking/effectiveness/index.js",
    "build/src/ranking/effectiveness/mark.js",
    "build/src/ranking/effectiveness/sizechannel.js",
    "build/src/ranking/effectiveness/type.js",
    "build/src/ranking/effectiveness/typechannel.js",
    "build/src/ranking/fieldorder.js",
    "build/src/ranking/ranking.js",
    "build/src/recommend.js",
    "build/src/schema.js",
    "build/src/stylize.js",
    "build/src/util.js",
    "build/src/wildcard.js",
    "build/src/wildcardindex.js",
    "node_modules/browser-resolve/empty.js",
    "node_modules/datalib/node_modules/d3-time/build/d3-time.js",
    "node_modules/datalib/src/bins/bins.js",
    "node_modules/datalib/src/generate.js",
    "node_modules/datalib/src/import/type.js",
    "node_modules/datalib/src/stats.js",
    "node_modules/datalib/src/time.js",
    "node_modules/datalib/src/util.js",
    "node_modules/json-stable-stringify/index.js",
    "node_modules/jsonify/index.js",
    "node_modules/jsonify/lib/parse.js",
    "node_modules/jsonify/lib/stringify.js",
    "node_modules/tslib/tslib.js",
    "node_modules/vega-lite/build/src/aggregate.js",
    "node_modules/vega-lite/build/src/axis.js",
    "node_modules/vega-lite/build/src/bin.js",
    "node_modules/vega-lite/build/src/channel.js",
    "node_modules/vega-lite/build/src/compile/scale/type.js",
    "node_modules/vega-lite/build/src/datetime.js",
    "node_modules/vega-lite/build/src/fielddef.js",
    "node_modules/vega-lite/build/src/legend.js",
    "node_modules/vega-lite/build/src/log.js",
    "node_modules/vega-lite/build/src/logical.js",
    "node_modules/vega-lite/build/src/mark.js",
    "node_modules/vega-lite/build/src/scale.js",
    "node_modules/vega-lite/build/src/timeunit.js",
    "node_modules/vega-lite/build/src/type.js",
    "node_modules/vega-lite/build/src/util.js",
    "node_modules/vega-util/build/vega-util.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnWA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACndA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpIA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar property_1 = require(\"./property\");\nvar wildcard_1 = require(\"./wildcard\");\nexports.DEFAULT_QUERY_CONFIG = {\n    verbose: false,\n    defaultSpecConfig: {\n        overlay: { line: true },\n        scale: { useUnaggregatedDomain: true }\n    },\n    propertyPrecedence: property_1.DEFAULT_PROP_PRECEDENCE.map(property_1.toKey),\n    enum: wildcard_1.DEFAULT_ENUM_INDEX,\n    numberNominalProportion: 0.05,\n    numberNominalLimit: 40,\n    // CONSTRAINTS\n    constraintManuallySpecifiedValue: false,\n    // Spec Constraints -- See description inside src/constraints/spec.ts\n    autoAddCount: false,\n    hasAppropriateGraphicTypeForMark: true,\n    omitAggregate: false,\n    omitAggregatePlotWithDimensionOnlyOnFacet: true,\n    omitAggregatePlotWithoutDimension: false,\n    omitBarLineAreaWithOcclusion: true,\n    omitBarTickWithSize: true,\n    omitMultipleNonPositionalChannels: true,\n    omitNonSumStack: true,\n    omitRaw: false,\n    omitRawContinuousFieldForAggregatePlot: true,\n    omitRepeatedField: true,\n    omitNonPositionalOrFacetOverPositionalChannels: true,\n    omitTableWithOcclusionIfAutoAddCount: true,\n    omitVerticalDotPlot: false,\n    preferredBinAxis: channel_1.Channel.X,\n    preferredTemporalAxis: channel_1.Channel.X,\n    preferredOrdinalAxis: channel_1.Channel.Y,\n    preferredNominalAxis: channel_1.Channel.Y,\n    preferredFacet: channel_1.Channel.ROW,\n    // Field Encoding Constraints -- See description inside src/constraint/field.ts\n    minCardinalityForBin: 15,\n    maxCardinalityForCategoricalColor: 20,\n    maxCardinalityForFacet: 20,\n    maxCardinalityForShape: 6,\n    timeUnitShouldHaveVariation: true,\n    typeMatchesSchemaType: true,\n    // STYLIZE\n    stylize: true,\n    smallRangeStepForHighCardinalityOrFacet: { maxCardinality: 10, rangeStep: 12 },\n    nominalColorScaleForHighCardinality: { maxCardinality: 10, palette: 'category20' },\n    xAxisOnTopForHighYCardinalityWithoutColumn: { maxCardinality: 30 },\n    // RANKING PREFERENCE\n    maxGoodCardinalityForFacet: 5,\n    maxGoodCardinalityForColor: 7,\n    // HIGH CARDINALITY STRINGS\n    minPercentUniqueForKey: .8,\n    minCardinalityForKey: 50,\n};\nfunction extendConfig(opt) {\n    return __assign({}, exports.DEFAULT_QUERY_CONFIG, opt, { enum: extendEnumIndex(opt.enum) });\n}\nexports.extendConfig = extendConfig;\nfunction extendEnumIndex(enumIndex) {\n    var enumOpt = __assign({}, wildcard_1.DEFAULT_ENUM_INDEX, enumIndex, { binProps: extendNestedEnumIndex(enumIndex, 'bin'), scaleProps: extendNestedEnumIndex(enumIndex, 'scale'), axisProps: extendNestedEnumIndex(enumIndex, 'axis'), legendProps: extendNestedEnumIndex(enumIndex, 'legend') });\n    return enumOpt;\n}\nfunction extendNestedEnumIndex(enumIndex, prop) {\n    return __assign({}, wildcard_1.DEFAULT_ENUM_INDEX[prop + 'Props'], enumIndex[prop + 'Props']);\n}\n//# sourceMappingURL=config.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar property_1 = require(\"../property\");\nvar wildcard_1 = require(\"../wildcard\");\nvar util_1 = require(\"../util\");\n/**\n * Abstract model for a constraint.\n */\nvar AbstractConstraintModel = /** @class */ (function () {\n    function AbstractConstraintModel(constraint) {\n        this.constraint = constraint;\n    }\n    AbstractConstraintModel.prototype.name = function () {\n        return this.constraint.name;\n    };\n    AbstractConstraintModel.prototype.description = function () {\n        return this.constraint.description;\n    };\n    AbstractConstraintModel.prototype.properties = function () {\n        return this.constraint.properties;\n    };\n    AbstractConstraintModel.prototype.strict = function () {\n        return this.constraint.strict;\n    };\n    return AbstractConstraintModel;\n}());\nexports.AbstractConstraintModel = AbstractConstraintModel;\nvar EncodingConstraintModel = /** @class */ (function (_super) {\n    __extends(EncodingConstraintModel, _super);\n    function EncodingConstraintModel(constraint) {\n        return _super.call(this, constraint) || this;\n    }\n    EncodingConstraintModel.prototype.hasAllRequiredPropertiesSpecific = function (encQ) {\n        return util_1.every(this.constraint.properties, function (prop) {\n            if (property_1.isEncodingNestedProp(prop)) {\n                var parent_1 = prop.parent;\n                var child = prop.child;\n                if (!encQ[parent_1]) {\n                    return true;\n                }\n                return !wildcard_1.isWildcard(encQ[parent_1][child]);\n            }\n            if (!encQ[prop]) {\n                return true;\n            }\n            return !wildcard_1.isWildcard(encQ[prop]);\n        });\n    };\n    EncodingConstraintModel.prototype.satisfy = function (encQ, schema, encWildcardIndex, opt) {\n        // TODO: Re-order logic to optimize the \"allowWildcardForProperties\" check\n        if (!this.constraint.allowWildcardForProperties) {\n            // TODO: extract as a method and do unit test\n            if (!this.hasAllRequiredPropertiesSpecific(encQ)) {\n                return true;\n            }\n        }\n        return this.constraint.satisfy(encQ, schema, encWildcardIndex, opt);\n    };\n    return EncodingConstraintModel;\n}(AbstractConstraintModel));\nexports.EncodingConstraintModel = EncodingConstraintModel;\n//# sourceMappingURL=base.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar encoding_1 = require(\"../query/encoding\");\nvar field_1 = require(\"./field\");\nvar value_1 = require(\"./value\");\n/**\n * Check all encoding constraints for a particular property and index tuple\n */\nfunction checkEncoding(prop, wildcard, index, specM, schema, opt) {\n    // Check encoding constraint\n    var encodingConstraints = field_1.FIELD_CONSTRAINTS_BY_PROPERTY.get(prop) || [];\n    var encQ = specM.getEncodingQueryByIndex(index);\n    for (var _i = 0, encodingConstraints_1 = encodingConstraints; _i < encodingConstraints_1.length; _i++) {\n        var c = encodingConstraints_1[_i];\n        // Check if the constraint is enabled\n        if (c.strict() || !!opt[c.name()]) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(encQ, schema, specM.wildcardIndex.encodings[index], opt);\n            if (!satisfy) {\n                var violatedConstraint = '(enc) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + wildcard.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    var valueContraints = value_1.VALUE_CONSTRAINTS_BY_PROPERTY.get(prop) || [];\n    for (var _a = 0, valueContraints_1 = valueContraints; _a < valueContraints_1.length; _a++) {\n        var c = valueContraints_1[_a];\n        // Check if the constraint is enabled\n        if ((c.strict() || !!opt[c.name()]) && encoding_1.isValueQuery(encQ)) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(encQ, schema, specM.wildcardIndex.encodings[index], opt);\n            if (!satisfy) {\n                var violatedConstraint = '(enc) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + wildcard.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    return null;\n}\nexports.checkEncoding = checkEncoding;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar fielddef_1 = require(\"vega-lite/build/src/fielddef\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar expandedtype_1 = require(\"../query/expandedtype\");\nvar property_1 = require(\"../property\");\nvar propindex_1 = require(\"../propindex\");\nvar wildcard_1 = require(\"../wildcard\");\nvar schema_1 = require(\"../schema\");\nvar util_1 = require(\"../util\");\nvar encoding_1 = require(\"../query/encoding\");\nvar base_1 = require(\"./base\");\nexports.FIELD_CONSTRAINTS = [\n    {\n        name: 'aggregateOpSupportedByType',\n        description: 'Aggregate function should be supported by data type.',\n        properties: [property_1.Property.TYPE, property_1.Property.AGGREGATE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.aggregate) {\n                return !expandedtype_1.isDiscrete(fieldQ.type);\n            }\n            // TODO: some aggregate function are actually supported by ordinal\n            return true; // no aggregate is okay with any type.\n        }\n    }, {\n        name: 'asteriskFieldWithCountOnly',\n        description: 'Field=\"*\" should be disallowed except aggregate=\"count\"',\n        properties: [property_1.Property.FIELD, property_1.Property.AGGREGATE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            return (fieldQ.field === '*') === (fieldQ.aggregate === 'count');\n        }\n    }, {\n        name: 'minCardinalityForBin',\n        description: 'binned quantitative field should not have too low cardinality',\n        properties: [property_1.Property.BIN, property_1.Property.FIELD, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, schema, _, opt) {\n            if (fieldQ.bin && fieldQ.type === type_1.Type.QUANTITATIVE) {\n                // We remove bin so schema can infer the raw unbinned cardinality.\n                var fieldQwithoutBin = { channel: fieldQ.channel, field: fieldQ.field, type: fieldQ.type };\n                return schema.cardinality(fieldQwithoutBin) >= opt.minCardinalityForBin;\n            }\n            return true;\n        }\n    }, {\n        name: 'binAppliedForQuantitative',\n        description: 'bin should be applied to quantitative field only.',\n        properties: [property_1.Property.TYPE, property_1.Property.BIN],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.bin) {\n                // If binned, the type must be quantitative\n                return fieldQ.type === type_1.Type.QUANTITATIVE;\n            }\n            return true;\n        }\n    }, {\n        name: 'channelFieldCompatible',\n        description: \"encoding channel's range type be compatible with channel type.\",\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, encWildcardIndex, opt) {\n            var fieldDef = __assign({ field: 'f' }, encoding_1.toFieldDef(fieldQ, ['bin', 'timeUnit', 'type']));\n            return fielddef_1.channelCompatibility(fieldDef, fieldQ.channel).compatible;\n        }\n    }, {\n        name: 'hasFn',\n        description: 'A field with as hasFn flag should have one of aggregate, timeUnit, or bin.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.hasFn) {\n                return !!fieldQ.aggregate || !!fieldQ.bin || !!fieldQ.timeUnit;\n            }\n            return true;\n        }\n    }, {\n        name: 'omitScaleZeroWithBinnedField',\n        description: 'Do not use scale zero with binned field',\n        properties: [property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'zero'), property_1.Property.BIN],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.bin && fieldQ.scale) {\n                if (fieldQ.scale.zero === true) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }, {\n        name: 'onlyOneTypeOfFunction',\n        description: 'Only of of aggregate, autoCount, timeUnit, or bin should be applied at the same time.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN],\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (encoding_1.isFieldQuery(fieldQ)) {\n                var numFn = (!wildcard_1.isWildcard(fieldQ.aggregate) && !!fieldQ.aggregate ? 1 : 0) +\n                    (!wildcard_1.isWildcard(fieldQ.bin) && !!fieldQ.bin ? 1 : 0) +\n                    (!wildcard_1.isWildcard(fieldQ.timeUnit) && !!fieldQ.timeUnit ? 1 : 0);\n                return numFn <= 1;\n            }\n            // For autoCount there is always only one type of function\n            return true;\n        }\n    }, {\n        name: 'timeUnitAppliedForTemporal',\n        description: 'Time unit should be applied to temporal field only.',\n        properties: [property_1.Property.TYPE, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.timeUnit && fieldQ.type !== type_1.Type.TEMPORAL) {\n                return false;\n            }\n            return true;\n        }\n    }, {\n        name: 'timeUnitShouldHaveVariation',\n        description: 'A particular time unit should be applied only if they produce unique values.',\n        properties: [property_1.Property.TIMEUNIT, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, encWildcardIndex, opt) {\n            if (fieldQ.timeUnit && fieldQ.type === type_1.Type.TEMPORAL) {\n                if (!encWildcardIndex.has('timeUnit') && !opt.constraintManuallySpecifiedValue) {\n                    // Do not have to check this as this is manually specified by users.\n                    return true;\n                }\n                return schema.timeUnitHasVariation(fieldQ);\n            }\n            return true;\n        }\n    }, {\n        name: 'scalePropertiesSupportedByScaleType',\n        description: 'Scale properties must be supported by correct scale type',\n        properties: [].concat(property_1.SCALE_PROPS, [property_1.Property.SCALE, property_1.Property.TYPE]),\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.scale) {\n                var scale = fieldQ.scale;\n                //  If fieldQ.type is an Wildcard and scale.type is undefined, it is equivalent\n                //  to scale type is Wildcard. If scale type is an Wildcard, we do not yet know\n                //  what the scale type is, and thus can ignore the constraint.\n                var sType = encoding_1.scaleType(fieldQ);\n                if (sType === undefined || sType === null) {\n                    // If still ambiguous, doesn't check the constraint\n                    return true;\n                }\n                for (var scaleProp in scale) {\n                    if (scaleProp === 'type' || scaleProp === 'name' || scaleProp === 'enum') {\n                        // ignore type and properties of wildcards\n                        continue;\n                    }\n                    var sProp = scaleProp;\n                    if (sType === 'point') {\n                        // HACK: our current implementation of scaleType() can return point\n                        // when the scaleType is a band since we didn't pass all parameter to Vega-Lite's scale type method.\n                        if (!scale_1.scaleTypeSupportProperty('point', sProp) && !scale_1.scaleTypeSupportProperty('band', sProp)) {\n                            return false;\n                        }\n                    }\n                    else if (!scale_1.scaleTypeSupportProperty(sType, sProp)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    }, {\n        name: 'scalePropertiesSupportedByChannel',\n        description: 'Not all scale properties are supported by all encoding channels',\n        properties: [].concat(property_1.SCALE_PROPS, [property_1.Property.SCALE, property_1.Property.CHANNEL]),\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ) {\n                var channel = fieldQ.channel;\n                var scale = fieldQ.scale;\n                if (channel && !wildcard_1.isWildcard(channel) && scale) {\n                    if (channel === 'row' || channel === 'column') {\n                        // row / column do not have scale\n                        return false;\n                    }\n                    for (var scaleProp in scale) {\n                        if (!scale.hasOwnProperty(scaleProp))\n                            continue;\n                        if (scaleProp === 'type' || scaleProp === 'name' || scaleProp === 'enum') {\n                            // ignore type and properties of wildcards\n                            continue;\n                        }\n                        var isSupported = scale_1.channelScalePropertyIncompatability(channel, scaleProp) === undefined;\n                        if (!isSupported) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    }, {\n        name: 'typeMatchesPrimitiveType',\n        description: 'Data type should be supported by field\\'s primitive type.',\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, schema, encWildcardIndex, opt) {\n            if (fieldQ.field === '*') {\n                return true;\n            }\n            var primitiveType = schema.primitiveType(fieldQ.field);\n            var type = fieldQ.type;\n            if (!encWildcardIndex.has('field') && !encWildcardIndex.has('type') && !opt.constraintManuallySpecifiedValue) {\n                // Do not have to check this as this is manually specified by users.\n                return true;\n            }\n            switch (primitiveType) {\n                case schema_1.PrimitiveType.BOOLEAN:\n                case schema_1.PrimitiveType.STRING:\n                    return type !== type_1.Type.QUANTITATIVE && type !== type_1.Type.TEMPORAL;\n                case schema_1.PrimitiveType.NUMBER:\n                case schema_1.PrimitiveType.INTEGER:\n                    return type !== type_1.Type.TEMPORAL;\n                case schema_1.PrimitiveType.DATETIME:\n                    // TODO: add NOMINAL, ORDINAL support after we support this in Vega-Lite\n                    return type === type_1.Type.TEMPORAL;\n                case null:\n                    // field does not exist in the schema\n                    return false;\n            }\n            throw new Error('Not implemented');\n        }\n    },\n    {\n        name: 'typeMatchesSchemaType',\n        description: 'Enumerated data type of a field should match the field\\'s type in the schema.',\n        properties: [property_1.Property.FIELD, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, encWildcardIndex, opt) {\n            if (!encWildcardIndex.has('field') && !encWildcardIndex.has('type') && !opt.constraintManuallySpecifiedValue) {\n                // Do not have to check this as this is manually specified by users.\n                return true;\n            }\n            if (fieldQ.field === '*') {\n                return fieldQ.type === type_1.Type.QUANTITATIVE;\n            }\n            return schema.vlType(fieldQ.field) === fieldQ.type;\n        }\n    }, {\n        name: 'maxCardinalityForCategoricalColor',\n        description: 'Categorical channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, _, opt) {\n            // TODO: missing case where ordinal / temporal use categorical color\n            // (once we do so, need to add Property.BIN, Property.TIMEUNIT)\n            if (fieldQ.channel === channel_1.Channel.COLOR && (fieldQ.type === type_1.Type.NOMINAL || fieldQ.type === expandedtype_1.ExpandedType.KEY)) {\n                return schema.cardinality(fieldQ) <= opt.maxCardinalityForCategoricalColor;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'maxCardinalityForFacet',\n        description: 'Row/column channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, _, opt) {\n            if (fieldQ.channel === channel_1.Channel.ROW || fieldQ.channel === channel_1.Channel.COLUMN) {\n                return schema.cardinality(fieldQ) <= opt.maxCardinalityForFacet;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    }, {\n        name: 'maxCardinalityForShape',\n        description: 'Shape channel should not have too high cardinality',\n        properties: [property_1.Property.CHANNEL, property_1.Property.FIELD, property_1.Property.BIN, property_1.Property.TIMEUNIT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (fieldQ, schema, _, opt) {\n            if (fieldQ.channel === channel_1.Channel.SHAPE) {\n                return schema.cardinality(fieldQ) <= opt.maxCardinalityForShape;\n            }\n            return true; // other channel is irrelevant to this constraint\n        }\n    },\n    {\n        name: 'dataTypeAndFunctionMatchScaleType',\n        description: 'Scale type must match data type',\n        properties: [property_1.Property.TYPE, property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'type'), property_1.Property.TIMEUNIT, property_1.Property.BIN],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (fieldQ, _, __, ___) {\n            if (fieldQ.scale) {\n                var type = fieldQ.type;\n                var sType = encoding_1.scaleType(fieldQ);\n                if (expandedtype_1.isDiscrete(type)) {\n                    return sType === undefined || scale_1.hasDiscreteDomain(sType);\n                }\n                else if (type === type_1.Type.TEMPORAL) {\n                    if (!fieldQ.timeUnit) {\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], sType);\n                    }\n                    else {\n                        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, undefined], sType) || scale_1.hasDiscreteDomain(sType);\n                    }\n                }\n                else if (type === type_1.Type.QUANTITATIVE) {\n                    if (fieldQ.bin) {\n                        return util_1.contains([scale_1.ScaleType.LINEAR, undefined], sType);\n                    }\n                    else {\n                        return util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.QUANTILE, scale_1.ScaleType.QUANTIZE, scale_1.ScaleType.LINEAR, undefined], sType);\n                    }\n                }\n            }\n            return true;\n        }\n    }\n].map(function (ec) { return new base_1.EncodingConstraintModel(ec); });\nexports.FIELD_CONSTRAINT_INDEX = exports.FIELD_CONSTRAINTS.reduce(function (m, ec) {\n    m[ec.name()] = ec;\n    return m;\n}, {});\nexports.FIELD_CONSTRAINTS_BY_PROPERTY = exports.FIELD_CONSTRAINTS.reduce(function (index, c) {\n    for (var _i = 0, _a = c.properties(); _i < _a.length; _i++) {\n        var prop = _a[_i];\n        // Initialize array and use it\n        index.set(prop, index.get(prop) || []);\n        index.get(prop).push(c);\n    }\n    return index;\n}, new propindex_1.PropIndex());\n//# sourceMappingURL=field.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar encoding = require(\"./encoding\");\nexports.encoding = encoding;\nvar spec = require(\"./spec\");\nexports.spec = spec;\n//# sourceMappingURL=index.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar aggregate_1 = require(\"vega-lite/build/src/aggregate\");\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar mark_1 = require(\"vega-lite/build/src/mark\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar expandedtype_1 = require(\"../query/expandedtype\");\nvar base_1 = require(\"./base\");\nvar wildcard_1 = require(\"../wildcard\");\nvar property_1 = require(\"../property\");\nvar propindex_1 = require(\"../propindex\");\nvar util_1 = require(\"../util\");\nvar encoding_1 = require(\"../query/encoding\");\nvar NONSPATIAL_CHANNELS_INDEX = channel_1.NONSPATIAL_CHANNELS.reduce(function (m, channel) {\n    m[channel] = true;\n    return m;\n}, {});\nvar SpecConstraintModel = /** @class */ (function (_super) {\n    __extends(SpecConstraintModel, _super);\n    function SpecConstraintModel(specConstraint) {\n        return _super.call(this, specConstraint) || this;\n    }\n    SpecConstraintModel.prototype.hasAllRequiredPropertiesSpecific = function (specM) {\n        return util_1.every(this.constraint.properties, function (prop) {\n            if (prop === property_1.Property.MARK) {\n                return !wildcard_1.isWildcard(specM.getMark());\n            }\n            // TODO: transform\n            if (property_1.isEncodingNestedProp(prop)) {\n                var parent_1 = prop.parent;\n                var child_1 = prop.child;\n                return util_1.every(specM.getEncodings(), function (encQ) {\n                    if (!encQ[parent_1]) {\n                        return true;\n                    }\n                    return !wildcard_1.isWildcard(encQ[parent_1][child_1]);\n                });\n            }\n            if (!property_1.isEncodingProperty(prop)) {\n                throw new Error('UNIMPLEMENTED');\n            }\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                if (!encQ[prop]) {\n                    return true;\n                }\n                return !wildcard_1.isWildcard(encQ[prop]);\n            });\n        });\n    };\n    SpecConstraintModel.prototype.satisfy = function (specM, schema, opt) {\n        // TODO: Re-order logic to optimize the \"allowWildcardForProperties\" check\n        if (!this.constraint.allowWildcardForProperties) {\n            if (!this.hasAllRequiredPropertiesSpecific(specM)) {\n                return true;\n            }\n        }\n        return this.constraint.satisfy(specM, schema, opt);\n    };\n    return SpecConstraintModel;\n}(base_1.AbstractConstraintModel));\nexports.SpecConstraintModel = SpecConstraintModel;\nexports.SPEC_CONSTRAINTS = [\n    {\n        name: 'noRepeatedChannel',\n        description: 'Each encoding channel should only be used once.',\n        properties: [property_1.Property.CHANNEL],\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var usedChannel = {};\n            // channel for all encodings should be valid\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                if (!wildcard_1.isWildcard(encQ.channel)) {\n                    // If channel is specified, it should no be used already\n                    if (usedChannel[encQ.channel]) {\n                        return false;\n                    }\n                    usedChannel[encQ.channel] = true;\n                    return true;\n                }\n                return true; // unspecified channel is valid\n            });\n        }\n    },\n    {\n        name: 'alwaysIncludeZeroInScaleWithBarMark',\n        description: 'Do not recommend bar mark if scale does not start at zero',\n        properties: [property_1.Property.MARK, property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'zero'), property_1.Property.CHANNEL, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            var encodings = specM.getEncodings();\n            if (mark === mark_1.Mark.BAR) {\n                for (var _i = 0, encodings_1 = encodings; _i < encodings_1.length; _i++) {\n                    var encQ = encodings_1[_i];\n                    if (encoding_1.isFieldQuery(encQ) &&\n                        (encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) &&\n                        (encQ.type === type_1.Type.QUANTITATIVE) &&\n                        (encQ.scale && encQ.scale.zero === false)) {\n                        // TODO: zero shouldn't be manually specified\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'autoAddCount',\n        description: 'Automatically adding count only for plots with only ordinal, binned quantitative, or temporal with timeunit fields.',\n        properties: [property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.TYPE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            var hasAutoCount = util_1.some(specM.getEncodings(), function (encQ) { return encoding_1.isEnabledAutoCountQuery(encQ); });\n            if (hasAutoCount) {\n                // Auto count should only be applied if all fields are nominal, ordinal, temporal with timeUnit, binned quantitative, or autoCount\n                return util_1.every(specM.getEncodings(), function (encQ) {\n                    if (encoding_1.isValueQuery(encQ)) {\n                        return false;\n                    }\n                    if (encoding_1.isAutoCountQuery(encQ)) {\n                        return true;\n                    }\n                    switch (encQ.type) {\n                        case type_1.Type.QUANTITATIVE:\n                            return !!encQ.bin;\n                        case type_1.Type.TEMPORAL:\n                            return !!encQ.timeUnit;\n                        case type_1.Type.ORDINAL:\n                        case expandedtype_1.ExpandedType.KEY:\n                        case type_1.Type.NOMINAL:\n                            return true;\n                    }\n                    /* istanbul ignore next */\n                    throw new Error('Unsupported Type');\n                });\n            }\n            else {\n                var autoCountEncIndex = specM.wildcardIndex.encodingIndicesByProperty.get('autoCount') || [];\n                var neverHaveAutoCount = util_1.every(autoCountEncIndex, function (index) {\n                    var encQ = specM.getEncodingQueryByIndex(index);\n                    return encoding_1.isAutoCountQuery(encQ) && !wildcard_1.isWildcard(encQ.autoCount);\n                });\n                if (neverHaveAutoCount) {\n                    // If the query surely does not have autoCount\n                    // then one of the field should be\n                    // (1) unbinned quantitative\n                    // (2) temporal without time unit\n                    // (3) nominal or ordinal field\n                    // or at least have potential to be (still ambiguous).\n                    return util_1.some(specM.getEncodings(), function (encQ) {\n                        if ((encoding_1.isFieldQuery(encQ) || encoding_1.isAutoCountQuery(encQ)) && encQ.type === type_1.Type.QUANTITATIVE) {\n                            if (encoding_1.isDisabledAutoCountQuery(encQ)) {\n                                return false;\n                            }\n                            else {\n                                return encoding_1.isFieldQuery(encQ) && (!encQ.bin || wildcard_1.isWildcard(encQ.bin));\n                            }\n                        }\n                        else if (encoding_1.isFieldQuery(encQ) && encQ.type === type_1.Type.TEMPORAL) {\n                            return !encQ.timeUnit || wildcard_1.isWildcard(encQ.timeUnit);\n                        }\n                        return false; // nominal or ordinal\n                    });\n                }\n            }\n            return true; // no auto count, no constraint\n        }\n    },\n    {\n        name: 'channelPermittedByMarkType',\n        description: 'Each encoding channel should be supported by the mark type',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        allowWildcardForProperties: true,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            // if mark is unspecified, no need to check\n            if (wildcard_1.isWildcard(mark))\n                return true;\n            // TODO: can optimize this to detect only what's the changed property if needed.\n            return util_1.every(specM.getEncodings(), function (encQ) {\n                // channel unspecified, no need to check\n                if (wildcard_1.isWildcard(encQ.channel))\n                    return true;\n                return channel_1.supportMark(encQ.channel, mark);\n            });\n        }\n    },\n    {\n        name: 'hasAllRequiredChannelsForMark',\n        description: 'All required channels for the specified mark should be specified',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            switch (mark) {\n                case mark_1.Mark.AREA:\n                case mark_1.Mark.LINE:\n                    return specM.channelUsed(channel_1.Channel.X) && specM.channelUsed(channel_1.Channel.Y);\n                case mark_1.Mark.TEXT:\n                    return specM.channelUsed(channel_1.Channel.TEXT);\n                case mark_1.Mark.BAR:\n                case mark_1.Mark.CIRCLE:\n                case mark_1.Mark.SQUARE:\n                case mark_1.Mark.TICK:\n                case mark_1.Mark.RULE:\n                    return specM.channelUsed(channel_1.Channel.X) || specM.channelUsed(channel_1.Channel.Y);\n                case mark_1.Mark.POINT:\n                    // This allows generating a point plot if channel was not a wildcard.\n                    return !specM.wildcardIndex.hasProperty(property_1.Property.CHANNEL) ||\n                        specM.channelUsed(channel_1.Channel.X) || specM.channelUsed(channel_1.Channel.Y);\n            }\n            /* istanbul ignore next */\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + JSON.stringify(mark));\n        }\n    },\n    {\n        name: 'omitAggregate',\n        description: 'Omit aggregate plots.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            if (specM.isAggregate()) {\n                return false;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitAggregatePlotWithDimensionOnlyOnFacet',\n        description: 'Omit aggregate plots with dimensions only on facets as that leads to inefficient use of space.',\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            if (specM.isAggregate()) {\n                var hasNonFacetDim_1 = false, hasDim_1 = false, hasEnumeratedFacetDim_1 = false;\n                specM.specQuery.encodings.forEach(function (encQ, index) {\n                    if (encoding_1.isValueQuery(encQ) || (encoding_1.isDisabledAutoCountQuery(encQ)))\n                        return; // skip unused field\n                    // FieldQuery & !encQ.aggregate\n                    if (encoding_1.isFieldQuery(encQ) && !encQ.aggregate) {\n                        hasDim_1 = true;\n                        if (util_1.contains([channel_1.Channel.ROW, channel_1.Channel.COLUMN], encQ.channel)) {\n                            if (specM.wildcardIndex.hasEncodingProperty(index, property_1.Property.CHANNEL)) {\n                                hasEnumeratedFacetDim_1 = true;\n                            }\n                        }\n                        else {\n                            hasNonFacetDim_1 = true;\n                        }\n                    }\n                });\n                if (hasDim_1 && !hasNonFacetDim_1) {\n                    if (hasEnumeratedFacetDim_1 || opt.constraintManuallySpecifiedValue) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitAggregatePlotWithoutDimension',\n        description: 'Aggregate plots without dimension should be omitted',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            if (specM.isAggregate()) {\n                // TODO relax\n                return util_1.some(specM.getEncodings(), function (encQ) {\n                    if (encoding_1.isDimension(encQ) || (encoding_1.isFieldQuery(encQ) && (encQ.type === 'temporal'))) {\n                        return true;\n                    }\n                    return false;\n                });\n            }\n            return true;\n        }\n    },\n    {\n        // TODO: we can be smarter and check if bar has occlusion based on profiling statistics\n        name: 'omitBarLineAreaWithOcclusion',\n        description: 'Don\\'t use bar, line or area to visualize raw plot as they often lead to occlusion.',\n        properties: [property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            if (util_1.contains([mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA], specM.getMark())) {\n                return specM.isAggregate();\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitBarTickWithSize',\n        description: 'Do not map field to size channel with bar and tick mark',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            var mark = specM.getMark();\n            if (util_1.contains([mark_1.Mark.TICK, mark_1.Mark.BAR], mark)) {\n                if (specM.channelUsed(channel_1.Channel.SIZE)) {\n                    if (opt.constraintManuallySpecifiedValue) {\n                        // If size is used and we constraintManuallySpecifiedValue,\n                        // then the spec violates this constraint.\n                        return false;\n                    }\n                    else {\n                        // Otherwise have to search for the size channel and check if it is enumerated\n                        var encodings = specM.specQuery.encodings;\n                        for (var i = 0; i < encodings.length; i++) {\n                            var encQ = encodings[i];\n                            if (encQ.channel === channel_1.Channel.SIZE) {\n                                if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\n                                    // If enumerated, then this is bad\n                                    return false;\n                                }\n                                else {\n                                    // If it's manually specified, no need to continue searching, just return.\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return true; // skip\n        }\n    },\n    {\n        name: 'omitBarAreaForLogScale',\n        description: 'Do not use bar and area mark for x and y\\'s log scale',\n        properties: [property_1.Property.MARK, property_1.Property.CHANNEL, property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'type'), property_1.Property.TYPE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            var encodings = specM.getEncodings();\n            // TODO: mark or scale type should be enumerated\n            if (mark === mark_1.Mark.AREA || mark === mark_1.Mark.BAR) {\n                for (var _i = 0, encodings_2 = encodings; _i < encodings_2.length; _i++) {\n                    var encQ = encodings_2[_i];\n                    if (encoding_1.isFieldQuery(encQ) && ((encQ.channel === channel_1.Channel.X || encQ.channel === channel_1.Channel.Y) && encQ.scale)) {\n                        var sType = encoding_1.scaleType(encQ);\n                        if (sType === scale_1.ScaleType.LOG) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitMultipleNonPositionalChannels',\n        description: 'Unless manually specified, do not use multiple non-positional encoding channel to avoid over-encoding.',\n        properties: [property_1.Property.CHANNEL],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            // have to use specM.specQuery.encodings insetad of specM.getEncodings()\n            // since specM.getEncodings() remove encQ with autoCount===false from the array\n            // and thus might shift the index\n            var encodings = specM.specQuery.encodings;\n            var nonPositionChannelCount = 0;\n            var hasEnumeratedNonPositionChannel = false;\n            for (var i = 0; i < encodings.length; i++) {\n                var encQ = encodings[i];\n                if (encoding_1.isValueQuery(encQ) || (encoding_1.isDisabledAutoCountQuery(encQ))) {\n                    continue; // ignore skipped encoding\n                }\n                var channel = encQ.channel;\n                if (!wildcard_1.isWildcard(channel)) {\n                    if (NONSPATIAL_CHANNELS_INDEX[channel + '']) {\n                        nonPositionChannelCount += 1;\n                        if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\n                            hasEnumeratedNonPositionChannel = true;\n                        }\n                        if (nonPositionChannelCount > 1 &&\n                            (hasEnumeratedNonPositionChannel || opt.constraintManuallySpecifiedValue)) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitNonPositionalOrFacetOverPositionalChannels',\n        description: 'Do not use non-positional channels unless all positional channels are used',\n        properties: [property_1.Property.CHANNEL],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            var encodings = specM.specQuery.encodings;\n            var hasNonPositionalChannelOrFacet = false;\n            var hasEnumeratedNonPositionOrFacetChannel = false;\n            var hasX = false, hasY = false;\n            for (var i = 0; i < encodings.length; i++) {\n                var encQ = encodings[i];\n                if (encoding_1.isValueQuery(encQ) || (encoding_1.isDisabledAutoCountQuery(encQ))) {\n                    continue; // ignore skipped encoding\n                }\n                var channel = encQ.channel;\n                if (channel === channel_1.Channel.X) {\n                    hasX = true;\n                }\n                else if (channel === channel_1.Channel.Y) {\n                    hasY = true;\n                }\n                else if (!wildcard_1.isWildcard(channel)) {\n                    // All non positional channel / Facet\n                    hasNonPositionalChannelOrFacet = true;\n                    if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.CHANNEL)) {\n                        hasEnumeratedNonPositionOrFacetChannel = true;\n                    }\n                }\n            }\n            if (hasEnumeratedNonPositionOrFacetChannel ||\n                (opt.constraintManuallySpecifiedValue && hasNonPositionalChannelOrFacet)) {\n                return hasX && hasY;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRaw',\n        description: 'Omit raw plots.',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            if (!specM.isAggregate()) {\n                return false;\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRawContinuousFieldForAggregatePlot',\n        description: 'Aggregate plot should not use raw continuous field as group by values. ' +\n            '(Quantitative should be binned. Temporal should have time unit.)',\n        properties: [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.TYPE],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            if (specM.isAggregate()) {\n                var encodings = specM.specQuery.encodings;\n                for (var i = 0; i < encodings.length; i++) {\n                    var encQ = encodings[i];\n                    if (encoding_1.isValueQuery(encQ) || (encoding_1.isDisabledAutoCountQuery(encQ)))\n                        continue; // skip unused encoding\n                    // TODO: aggregate for ordinal and temporal\n                    if (encoding_1.isFieldQuery(encQ) && encQ.type === type_1.Type.TEMPORAL) {\n                        // Temporal fields should have timeUnit or is still a wildcard\n                        if (!encQ.timeUnit && (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.TIMEUNIT) ||\n                            opt.constraintManuallySpecifiedValue)) {\n                            return false;\n                        }\n                    }\n                    if (encQ.type === type_1.Type.QUANTITATIVE) {\n                        if (encoding_1.isFieldQuery(encQ) && !encQ.bin && !encQ.aggregate) {\n                            // If Raw Q\n                            if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.BIN) ||\n                                specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.AGGREGATE) ||\n                                specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.AUTOCOUNT)) {\n                                // and it's raw from enumeration\n                                return false;\n                            }\n                            if (opt.constraintManuallySpecifiedValue) {\n                                // or if we constraintManuallySpecifiedValue\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitRawDetail',\n        description: 'Do not use detail channel with raw plot.',\n        properties: [property_1.Property.CHANNEL, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, opt) {\n            if (specM.isAggregate()) {\n                return true;\n            }\n            return util_1.every(specM.specQuery.encodings, function (encQ, index) {\n                if (encoding_1.isValueQuery(encQ) || (encoding_1.isDisabledAutoCountQuery(encQ)))\n                    return true; // ignore autoCount field\n                if (encQ.channel === channel_1.Channel.DETAIL) {\n                    // Detail channel for raw plot is not good, except when its enumerated\n                    // or when it's manually specified but we constraintManuallySpecifiedValue.\n                    if (specM.wildcardIndex.hasEncodingProperty(index, property_1.Property.CHANNEL) ||\n                        opt.constraintManuallySpecifiedValue) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    },\n    {\n        name: 'omitRepeatedField',\n        description: 'Each field should be mapped to only one channel',\n        properties: [property_1.Property.FIELD],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            var fieldUsed = {};\n            var fieldEnumerated = {};\n            var encodings = specM.specQuery.encodings;\n            for (var i = 0; i < encodings.length; i++) {\n                var encQ = encodings[i];\n                if (encoding_1.isValueQuery(encQ) || encoding_1.isAutoCountQuery(encQ))\n                    continue;\n                var field = void 0;\n                if (encQ.field && !wildcard_1.isWildcard(encQ.field)) {\n                    field = encQ.field;\n                }\n                if (encoding_1.isAutoCountQuery(encQ) && !wildcard_1.isWildcard(encQ.autoCount)) {\n                    field = 'count_*';\n                }\n                if (field) {\n                    if (specM.wildcardIndex.hasEncodingProperty(i, property_1.Property.FIELD)) {\n                        fieldEnumerated[field] = true;\n                    }\n                    // When the field is specified previously,\n                    // if it is enumerated (either previously or in this encQ)\n                    // or if the opt.constraintManuallySpecifiedValue is true,\n                    // then it violates the constraint.\n                    if (fieldUsed[field]) {\n                        if (fieldEnumerated[field] || opt.constraintManuallySpecifiedValue) {\n                            return false;\n                        }\n                    }\n                    fieldUsed[field] = true;\n                }\n            }\n            return true;\n        }\n    },\n    // TODO: omitShapeWithBin\n    {\n        name: 'omitVerticalDotPlot',\n        description: 'Do not output vertical dot plot.',\n        properties: [property_1.Property.CHANNEL],\n        allowWildcardForProperties: true,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            var encodings = specM.getEncodings();\n            if (encodings.length === 1 && encodings[0].channel === channel_1.Channel.Y) {\n                return false;\n            }\n            return true;\n        }\n    },\n    // EXPENSIVE CONSTRAINTS -- check them later!\n    {\n        name: 'hasAppropriateGraphicTypeForMark',\n        description: 'Has appropriate graphic type for mark',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            var mark = specM.getMark();\n            switch (mark) {\n                case mark_1.Mark.AREA:\n                case mark_1.Mark.LINE:\n                    if (specM.isAggregate()) {\n                        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n                        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n                        var xIsMeasure = encoding_1.isMeasure(xEncQ);\n                        var yIsMeasure = encoding_1.isMeasure(yEncQ);\n                        // for aggregate line / area, we need at least one group-by axis and one measure axis.\n                        return xEncQ && yEncQ && (xIsMeasure !== yIsMeasure) &&\n                            // and the dimension axis should not be nominal\n                            // TODO: make this clause optional\n                            !(encoding_1.isFieldQuery(xEncQ) && !xIsMeasure && util_1.contains(['nominal', 'key'], xEncQ.type)) &&\n                            !(encoding_1.isFieldQuery(yEncQ) && !yIsMeasure && util_1.contains(['nominal', 'key'], yEncQ.type));\n                        // TODO: allow connected scatterplot\n                    }\n                    return true;\n                case mark_1.Mark.TEXT:\n                    // FIXME correctly when we add text\n                    return true;\n                case mark_1.Mark.BAR:\n                case mark_1.Mark.TICK:\n                    // Bar and tick should not use size.\n                    if (specM.channelUsed(channel_1.Channel.SIZE)) {\n                        return false;\n                    }\n                    else {\n                        // Tick and Bar should have one and only one measure\n                        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n                        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n                        var xIsMeasure = encoding_1.isMeasure(xEncQ);\n                        var yIsMeasure = encoding_1.isMeasure(yEncQ);\n                        if (xIsMeasure !== yIsMeasure) {\n                            return true;\n                        }\n                        return false;\n                    }\n                case mark_1.Mark.CIRCLE:\n                case mark_1.Mark.POINT:\n                case mark_1.Mark.SQUARE:\n                case mark_1.Mark.RULE:\n                    return true;\n            }\n            /* istanbul ignore next */\n            throw new Error('hasAllRequiredChannelsForMark not implemented for mark' + mark);\n        }\n    },\n    {\n        name: 'omitNonLinearScaleTypeWithStack',\n        description: 'Stacked plot should only use linear scale',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.SCALE, property_1.getEncodingNestedProp('scale', 'type'), property_1.Property.TYPE],\n        // TODO: Property.STACK\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (specM, _, __) {\n            var stack = specM.stack();\n            if (stack) {\n                for (var _i = 0, _a = specM.getEncodings(); _i < _a.length; _i++) {\n                    var encQ = _a[_i];\n                    if (encoding_1.isValueQuery(encQ))\n                        continue;\n                    if (((encoding_1.isFieldQuery(encQ) && !!encQ.aggregate) || encoding_1.isEnabledAutoCountQuery(encQ)) &&\n                        encQ.type === type_1.Type.QUANTITATIVE &&\n                        util_1.contains([channel_1.Channel.X, channel_1.Channel.Y], encQ.channel)) {\n                        if (encoding_1.scaleType(encQ) !== scale_1.ScaleType.LINEAR) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitNonSumStack',\n        description: 'Stacked plot should use summative aggregation such as sum, count, or distinct',\n        properties: [property_1.Property.CHANNEL, property_1.Property.MARK, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, __) {\n            var stack = specM.stack();\n            if (stack) {\n                var measureEncQ = specM.getEncodingQueryByChannel(stack.fieldChannel);\n                return (encoding_1.isFieldQuery(measureEncQ) && util_1.contains(aggregate_1.SUM_OPS, measureEncQ.aggregate)) || (encoding_1.isAutoCountQuery(measureEncQ) && !!measureEncQ.autoCount);\n            }\n            return true;\n        }\n    },\n    {\n        name: 'omitTableWithOcclusionIfAutoAddCount',\n        description: 'Plots without aggregation or autocount where x and y are both discrete should be omitted if autoAddCount is enabled as they often lead to occlusion',\n        properties: [property_1.Property.CHANNEL, property_1.Property.TYPE, property_1.Property.TIMEUNIT, property_1.Property.BIN, property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT],\n        allowWildcardForProperties: false,\n        strict: false,\n        satisfy: function (specM, _, opt) {\n            if (opt.autoAddCount) {\n                var xEncQ = specM.getEncodingQueryByChannel('x');\n                var yEncQ = specM.getEncodingQueryByChannel('y');\n                if ((!encoding_1.isFieldQuery(xEncQ) || encoding_1.isDimension(xEncQ)) &&\n                    (!encoding_1.isFieldQuery(yEncQ) || encoding_1.isDimension(yEncQ))) {\n                    if (!specM.isAggregate()) {\n                        return false;\n                    }\n                    else {\n                        return util_1.every(specM.getEncodings(), function (encQ) {\n                            var channel = encQ.channel;\n                            if (channel !== channel_1.Channel.X && channel !== channel_1.Channel.Y &&\n                                channel !== channel_1.Channel.ROW && channel !== channel_1.Channel.COLUMN) {\n                                // Non-position fields should not be unaggreated fields\n                                if (encoding_1.isFieldQuery(encQ) && !encQ.aggregate) {\n                                    return false;\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                }\n            }\n            return true;\n        }\n    }\n].map(function (sc) { return new SpecConstraintModel(sc); });\n// For testing\nexports.SPEC_CONSTRAINT_INDEX = exports.SPEC_CONSTRAINTS.reduce(function (m, c) {\n    m[c.name()] = c;\n    return m;\n}, {});\nvar SPEC_CONSTRAINTS_BY_PROPERTY = exports.SPEC_CONSTRAINTS.reduce(function (index, c) {\n    for (var _i = 0, _a = c.properties(); _i < _a.length; _i++) {\n        var prop = _a[_i];\n        // Initialize array and use it\n        index.set(prop, index.get(prop) || []);\n        index.get(prop).push(c);\n    }\n    return index;\n}, new propindex_1.PropIndex());\n/**\n * Check all encoding constraints for a particular property and index tuple\n */\nfunction checkSpec(prop, wildcard, specM, schema, opt) {\n    // Check encoding constraint\n    var specConstraints = SPEC_CONSTRAINTS_BY_PROPERTY.get(prop) || [];\n    for (var _i = 0, specConstraints_1 = specConstraints; _i < specConstraints_1.length; _i++) {\n        var c = specConstraints_1[_i];\n        // Check if the constraint is enabled\n        if (c.strict() || !!opt[c.name()]) {\n            // For strict constraint, or enabled non-strict, check the constraints\n            var satisfy = c.satisfy(specM, schema, opt);\n            if (!satisfy) {\n                var violatedConstraint = '(spec) ' + c.name();\n                /* istanbul ignore if */\n                if (opt.verbose) {\n                    console.log(violatedConstraint + ' failed with ' + specM.toShorthand() + ' for ' + wildcard.name);\n                }\n                return violatedConstraint;\n            }\n        }\n    }\n    return null;\n}\nexports.checkSpec = checkSpec;\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar property_1 = require(\"../property\");\nvar propindex_1 = require(\"../propindex\");\nvar util_1 = require(\"../util\");\nvar base_1 = require(\"./base\");\nexports.VALUE_CONSTRAINTS = [\n    {\n        name: 'doesNotSupportConstantValue',\n        description: 'row, column, x, y, order, and detail should not work with constant values.',\n        properties: [property_1.Property.TYPE, property_1.Property.AGGREGATE],\n        allowWildcardForProperties: false,\n        strict: true,\n        satisfy: function (valueQ, _, __, ___) {\n            return !(util_1.contains(['row', 'column', 'x', 'y', 'detail', 'order'], valueQ.channel));\n        }\n    }\n].map(function (ec) { return new base_1.EncodingConstraintModel(ec); });\nexports.VALUE_CONSTRAINT_INDEX = exports.VALUE_CONSTRAINTS.reduce(function (m, ec) {\n    m[ec.name()] = ec;\n    return m;\n}, {});\nexports.VALUE_CONSTRAINTS_BY_PROPERTY = exports.VALUE_CONSTRAINTS.reduce(function (index, c) {\n    for (var _i = 0, _a = c.properties(); _i < _a.length; _i++) {\n        var prop = _a[_i];\n        index.set(prop, index.get(prop) || []);\n        index.get(prop).push(c);\n    }\n    return index;\n}, new propindex_1.PropIndex());\n//# sourceMappingURL=value.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.version = '0.19.18';\nexports.config = require(\"./config\");\nexports.constraint = require(\"./constraint\");\nexports.enumerate = require(\"./enumerator\");\nexports.wildcard = require(\"./wildcard\");\nvar generate_1 = require(\"./generate\");\nexports.generate = generate_1.generate;\nexports.model = require(\"./model\");\nexports.nest = require(\"./nest\");\nexports.property = require(\"./property\");\nexports.query = require(\"./query\");\nexports.ranking = require(\"./ranking/ranking\");\nvar recommend_1 = require(\"./recommend\");\nexports.recommend = recommend_1.recommend;\nexports.schema = require(\"./schema\");\nexports.util = require(\"./util\");\n//# sourceMappingURL=cql.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar encoding_1 = require(\"./constraint/encoding\");\nvar spec_1 = require(\"./constraint/spec\");\nvar property_1 = require(\"./property\");\nvar propindex_1 = require(\"./propindex\");\nvar encoding_2 = require(\"./query/encoding\");\nvar ENUMERATOR_INDEX = new propindex_1.PropIndex();\nfunction getEnumerator(prop) {\n    return ENUMERATOR_INDEX.get(prop);\n}\nexports.getEnumerator = getEnumerator;\nENUMERATOR_INDEX.set('mark', function (wildcardIndex, schema, opt) {\n    return function (answerSet, specM) {\n        var markWildcard = specM.getMark();\n        // enumerate the value\n        markWildcard.enum.forEach(function (mark) {\n            specM.setMark(mark);\n            // Check spec constraint\n            var violatedSpecConstraint = spec_1.checkSpec('mark', wildcardIndex.mark, specM, schema, opt);\n            if (!violatedSpecConstraint) {\n                // emit\n                answerSet.push(specM.duplicate());\n            }\n        });\n        // Reset to avoid side effect\n        specM.resetMark();\n        return answerSet;\n    };\n});\nproperty_1.ENCODING_TOPLEVEL_PROPS.forEach(function (prop) {\n    ENUMERATOR_INDEX.set(prop, EncodingPropertyGeneratorFactory(prop));\n});\nproperty_1.ENCODING_NESTED_PROPS.forEach(function (nestedProp) {\n    ENUMERATOR_INDEX.set(nestedProp, EncodingPropertyGeneratorFactory(nestedProp));\n});\n/**\n * @param prop property type.\n * @return an answer set reducer factory for the given prop.\n */\nfunction EncodingPropertyGeneratorFactory(prop) {\n    /**\n     * @return as reducer that takes a specQueryModel as input and output an answer set array.\n     */\n    return function (wildcardIndex, schema, opt) {\n        return function (answerSet, specM) {\n            // index of encoding mappings that require enumeration\n            var indices = wildcardIndex.encodingIndicesByProperty.get(prop);\n            function enumerate(jobIndex) {\n                if (jobIndex === indices.length) {\n                    // emit and terminate\n                    answerSet.push(specM.duplicate());\n                    return;\n                }\n                var index = indices[jobIndex];\n                var wildcard = wildcardIndex.encodings[index].get(prop);\n                var encQ = specM.getEncodingQueryByIndex(index);\n                var propWildcard = specM.getEncodingProperty(index, prop);\n                if (encoding_2.isValueQuery(encQ) || (\n                // TODO: encQ.exclude\n                // If this encoding query is an excluded autoCount, there is no point enumerating other properties\n                // for this encoding query because they will be excluded anyway.\n                // Thus, we can just move on to the next encoding to enumerate.\n                (encoding_2.isDisabledAutoCountQuery(encQ)) ||\n                    // nested encoding property might have its parent set to false\n                    // therefore, we no longer have to enumerate them\n                    !propWildcard)) {\n                    enumerate(jobIndex + 1);\n                }\n                else {\n                    wildcard.enum.forEach(function (propVal) {\n                        if (propVal === null) {\n                            // our duplicate() method use JSON.stringify, parse and thus can accidentally\n                            // convert undefined in an array into null\n                            propVal = undefined;\n                        }\n                        specM.setEncodingProperty(index, prop, propVal, wildcard);\n                        // Check encoding constraint\n                        var violatedEncodingConstraint = encoding_1.checkEncoding(prop, wildcard, index, specM, schema, opt);\n                        if (violatedEncodingConstraint) {\n                            return; // do not keep searching\n                        }\n                        // Check spec constraint\n                        var violatedSpecConstraint = spec_1.checkSpec(prop, wildcard, specM, schema, opt);\n                        if (violatedSpecConstraint) {\n                            return; // do not keep searching\n                        }\n                        // If qualify all of the constraints, keep enumerating\n                        enumerate(jobIndex + 1);\n                    });\n                    // Reset to avoid side effect\n                    specM.resetEncodingProperty(index, prop, wildcard);\n                }\n            }\n            // start enumerating from 0\n            enumerate(0);\n            return answerSet;\n        };\n    };\n}\nexports.EncodingPropertyGeneratorFactory = EncodingPropertyGeneratorFactory;\n//# sourceMappingURL=enumerator.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = require(\"./config\");\nvar enumerator_1 = require(\"./enumerator\");\nvar model_1 = require(\"./model\");\nvar property_1 = require(\"./property\");\nvar stylize_1 = require(\"./stylize\");\nfunction generate(specQ, schema, opt) {\n    if (opt === void 0) { opt = config_1.DEFAULT_QUERY_CONFIG; }\n    // 1. Build a SpecQueryModel, which also contains wildcardIndex\n    var specM = model_1.SpecQueryModel.build(specQ, schema, opt);\n    var wildcardIndex = specM.wildcardIndex;\n    // 2. Enumerate each of the properties based on propPrecedence.\n    var answerSet = [specM]; // Initialize Answer Set with only the input spec query.\n    opt.propertyPrecedence.forEach(function (propKey) {\n        var prop = property_1.fromKey(propKey);\n        // If the original specQuery contains wildcard for this prop\n        if (wildcardIndex.hasProperty(prop)) {\n            // update answerset\n            var enumerator = enumerator_1.getEnumerator(prop);\n            var reducer = enumerator(wildcardIndex, schema, opt);\n            answerSet = answerSet.reduce(reducer, []);\n        }\n    });\n    if (opt.stylize) {\n        if ((opt.nominalColorScaleForHighCardinality !== null) ||\n            (opt.smallRangeStepForHighCardinalityOrFacet !== null) ||\n            (opt.xAxisOnTopForHighYCardinalityWithoutColumn !== null)) {\n            return stylize_1.stylize(answerSet, schema, opt);\n        }\n    }\n    return answerSet;\n}\nexports.generate = generate;\n//# sourceMappingURL=generate.js.map",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar property_1 = require(\"./property\");\nvar wildcard_1 = require(\"./wildcard\");\nvar wildcardindex_1 = require(\"./wildcardindex\");\nvar spec_1 = require(\"./query/spec\");\nvar encoding_1 = require(\"./query/encoding\");\nvar groupby_1 = require(\"./query/groupby\");\nvar shorthand_1 = require(\"./query/shorthand\");\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"datalib/src/util\");\nvar nest_1 = require(\"./nest\");\n/**\n * Internal class for specQuery that provides helper for the enumeration process.\n */\nvar SpecQueryModel = /** @class */ (function () {\n    function SpecQueryModel(spec, wildcardIndex, schema, opt, wildcardAssignment) {\n        this._rankingScore = {};\n        this._spec = spec;\n        this._channelFieldCount = spec.encodings.reduce(function (m, encQ) {\n            if (!wildcard_1.isWildcard(encQ.channel) && (!encoding_1.isAutoCountQuery(encQ) || encQ.autoCount !== false)) {\n                m[encQ.channel + ''] = 1;\n            }\n            return m;\n        }, {});\n        this._wildcardIndex = wildcardIndex;\n        this._assignedWildcardIndex = wildcardAssignment;\n        this._opt = opt;\n        this._schema = schema;\n    }\n    /**\n     * Build an WildcardIndex by detecting enumeration specifiers\n     * in the input specQuery and replace short wildcards with\n     * full ones that includes both names and enumValues.\n     *\n     * @return a SpecQueryModel that wraps the specQuery and the WildcardIndex.\n     */\n    SpecQueryModel.build = function (specQ, schema, opt) {\n        var wildcardIndex = new wildcardindex_1.WildcardIndex();\n        // mark\n        if (wildcard_1.isWildcard(specQ.mark)) {\n            var name_1 = wildcard_1.getDefaultName(property_1.Property.MARK);\n            specQ.mark = wildcard_1.initWildcard(specQ.mark, name_1, opt.enum.mark);\n            wildcardIndex.setMark(specQ.mark);\n        }\n        // TODO: transform\n        // encodings\n        specQ.encodings.forEach(function (encQ, index) {\n            if (encoding_1.isAutoCountQuery(encQ)) {\n                // This is only for testing purpose\n                console.warn('A field with autoCount should not be included as autoCount meant to be an internal object.');\n                encQ.type = type_1.Type.QUANTITATIVE; // autoCount is always quantitative\n            }\n            if (encoding_1.isFieldQuery(encQ) && encQ.type === undefined) {\n                // type is optional -- we automatically augment wildcard if not specified\n                encQ.type = wildcard_1.SHORT_WILDCARD;\n            }\n            // For each property of the encodingQuery, enumerate\n            property_1.ENCODING_TOPLEVEL_PROPS.forEach(function (prop) {\n                if (wildcard_1.isWildcard(encQ[prop])) {\n                    // Assign default wildcard name and enum values.\n                    var defaultWildcardName = wildcard_1.getDefaultName(prop) + index;\n                    var defaultEnumValues = wildcard_1.getDefaultEnumValues(prop, schema, opt);\n                    var wildcard = encQ[prop] = wildcard_1.initWildcard(encQ[prop], defaultWildcardName, defaultEnumValues);\n                    // Add index of the encoding mapping to the property's wildcard index.\n                    wildcardIndex.setEncodingProperty(index, prop, wildcard);\n                }\n            });\n            // For each nested property of the encoding query  (e.g., encQ.bin.maxbins)\n            property_1.ENCODING_NESTED_PROPS.forEach(function (prop) {\n                var propObj = encQ[prop.parent]; // the property object e.g., encQ.bin\n                if (propObj) {\n                    var child = prop.child;\n                    if (wildcard_1.isWildcard(propObj[child])) {\n                        // Assign default wildcard name and enum values.\n                        var defaultWildcardName = wildcard_1.getDefaultName(prop) + index;\n                        var defaultEnumValues = wildcard_1.getDefaultEnumValues(prop, schema, opt);\n                        var wildcard = propObj[child] = wildcard_1.initWildcard(propObj[child], defaultWildcardName, defaultEnumValues);\n                        // Add index of the encoding mapping to the property's wildcard index.\n                        wildcardIndex.setEncodingProperty(index, prop, wildcard);\n                    }\n                }\n            });\n        });\n        // AUTO COUNT\n        // Add Auto Count Field\n        if (opt.autoAddCount) {\n            var channel = {\n                name: wildcard_1.getDefaultName(property_1.Property.CHANNEL) + specQ.encodings.length,\n                enum: wildcard_1.getDefaultEnumValues(property_1.Property.CHANNEL, schema, opt)\n            };\n            var autoCount = {\n                name: wildcard_1.getDefaultName(property_1.Property.AUTOCOUNT) + specQ.encodings.length,\n                enum: [false, true]\n            };\n            var countEncQ = {\n                channel: channel,\n                autoCount: autoCount,\n                type: type_1.Type.QUANTITATIVE\n            };\n            specQ.encodings.push(countEncQ);\n            var index = specQ.encodings.length - 1;\n            // Add index of the encoding mapping to the property's wildcard index.\n            wildcardIndex.setEncodingProperty(index, property_1.Property.CHANNEL, channel);\n            wildcardIndex.setEncodingProperty(index, property_1.Property.AUTOCOUNT, autoCount);\n        }\n        return new SpecQueryModel(specQ, wildcardIndex, schema, opt, {});\n    };\n    Object.defineProperty(SpecQueryModel.prototype, \"wildcardIndex\", {\n        get: function () {\n            return this._wildcardIndex;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModel.prototype, \"schema\", {\n        get: function () {\n            return this._schema;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SpecQueryModel.prototype, \"specQuery\", {\n        get: function () {\n            return this._spec;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SpecQueryModel.prototype.duplicate = function () {\n        return new SpecQueryModel(util_1.duplicate(this._spec), this._wildcardIndex, this._schema, this._opt, util_1.duplicate(this._assignedWildcardIndex));\n    };\n    SpecQueryModel.prototype.setMark = function (mark) {\n        var name = this._wildcardIndex.mark.name;\n        this._assignedWildcardIndex[name] = this._spec.mark = mark;\n    };\n    SpecQueryModel.prototype.resetMark = function () {\n        var wildcard = this._spec.mark = this._wildcardIndex.mark;\n        delete this._assignedWildcardIndex[wildcard.name];\n    };\n    SpecQueryModel.prototype.getMark = function () {\n        return this._spec.mark;\n    };\n    SpecQueryModel.prototype.getEncodingProperty = function (index, prop) {\n        var encQ = this._spec.encodings[index];\n        if (property_1.isEncodingNestedProp(prop)) {\n            return encQ[prop.parent][prop.child];\n        }\n        return encQ[prop]; // encoding property (non-nested)\n    };\n    SpecQueryModel.prototype.setEncodingProperty = function (index, prop, value, wildcard) {\n        var encQ = this._spec.encodings[index];\n        if (prop === property_1.Property.CHANNEL && encQ.channel && !wildcard_1.isWildcard(encQ.channel)) {\n            // If there is an old channel\n            this._channelFieldCount[encQ.channel]--;\n        }\n        if (property_1.isEncodingNestedProp(prop)) {\n            encQ[prop.parent][prop.child] = value;\n        }\n        else if (property_1.hasNestedProperty(prop) && value === true) {\n            encQ[prop] = util_1.extend({}, encQ[prop], // copy all existing properties\n            { enum: undefined, name: undefined } // except name and values to it no longer an wildcard\n            );\n        }\n        else {\n            encQ[prop] = value;\n        }\n        this._assignedWildcardIndex[wildcard.name] = value;\n        if (prop === property_1.Property.CHANNEL) {\n            // If there is a new channel, make sure it exists and add it to the count.\n            this._channelFieldCount[value] = (this._channelFieldCount[value] || 0) + 1;\n        }\n    };\n    SpecQueryModel.prototype.resetEncodingProperty = function (index, prop, wildcard) {\n        var encQ = this._spec.encodings[index];\n        if (prop === property_1.Property.CHANNEL) {\n            this._channelFieldCount[encQ.channel]--;\n        }\n        // reset it to wildcard\n        if (property_1.isEncodingNestedProp(prop)) {\n            encQ[prop.parent][prop.child] = wildcard;\n        }\n        else {\n            encQ[prop] = wildcard;\n        }\n        // add remove value that is reset from the assignment map\n        delete this._assignedWildcardIndex[wildcard.name];\n    };\n    SpecQueryModel.prototype.channelUsed = function (channel) {\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\n        return this._channelFieldCount[channel] > 0;\n    };\n    SpecQueryModel.prototype.stack = function () {\n        return spec_1.stack(this._spec);\n    };\n    SpecQueryModel.prototype.getEncodings = function () {\n        // do not include encoding that has autoCount = false because it is not a part of the output spec.\n        return this._spec.encodings.filter(function (encQ) { return !encoding_1.isDisabledAutoCountQuery(encQ); });\n    };\n    SpecQueryModel.prototype.getEncodingQueryByChannel = function (channel) {\n        for (var _i = 0, _a = this._spec.encodings; _i < _a.length; _i++) {\n            var specEncoding = _a[_i];\n            if (specEncoding.channel === channel) {\n                return specEncoding;\n            }\n        }\n        return undefined;\n    };\n    SpecQueryModel.prototype.getEncodingQueryByIndex = function (i) {\n        return this._spec.encodings[i];\n    };\n    SpecQueryModel.prototype.isAggregate = function () {\n        return spec_1.isAggregate(this._spec);\n    };\n    SpecQueryModel.prototype.toShorthand = function (groupBy) {\n        if (groupBy) {\n            if (util_2.isString(groupBy)) {\n                return nest_1.getGroupByKey(this.specQuery, groupBy);\n            }\n            var parsedGroupBy = groupby_1.parseGroupBy(groupBy);\n            return shorthand_1.spec(this._spec, parsedGroupBy.include, parsedGroupBy.replacer);\n        }\n        return shorthand_1.spec(this._spec);\n    };\n    SpecQueryModel.prototype._encoding = function () {\n        var encoding = {};\n        for (var _i = 0, _a = this._spec.encodings; _i < _a.length; _i++) {\n            var encQ = _a[_i];\n            // Need to cast here so we can assign properties later\n            var fieldDef = {};\n            // For count field that is automatically added, convert to correct vega-lite fieldDef\n            if (encoding_1.isEnabledAutoCountQuery(encQ)) {\n                fieldDef = {\n                    aggregate: 'count',\n                    field: '*',\n                    type: 'quantitative'\n                };\n            }\n            else if (encoding_1.isValueQuery(encQ) || encoding_1.isDisabledAutoCountQuery(encQ)) {\n                continue; // Do not include this in the output.\n            }\n            // if channel is a wildcard, return null\n            if (wildcard_1.isWildcard(encQ.channel))\n                return null;\n            // assemble other property into a field def.\n            var PROPERTIES = [property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.FIELD, property_1.Property.TYPE, property_1.Property.SCALE, property_1.Property.SORT, property_1.Property.AXIS, property_1.Property.LEGEND];\n            for (var _b = 0, PROPERTIES_1 = PROPERTIES; _b < PROPERTIES_1.length; _b++) {\n                var prop = PROPERTIES_1[_b];\n                // if the property's a wildcard, return null\n                var encodingProperty = encQ[prop];\n                if (wildcard_1.isWildcard(encodingProperty)) {\n                    return null;\n                }\n                else {\n                    // all channels support this prop\n                    var isSupportedByChannel = (!shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop] || shorthand_1.PROPERTY_SUPPORTED_CHANNELS[prop][encQ.channel]);\n                    if (isSupportedByChannel) {\n                        if (encodingProperty !== undefined) {\n                            if (property_1.ENCODING_NESTED_PROP_PARENT_INDEX[prop]) {\n                                for (var childProp in encQ[prop]) {\n                                    // ensure nested properties are not wildcard before assigning to field def\n                                    if (wildcard_1.isWildcard(encQ[prop][childProp])) {\n                                        return null;\n                                    }\n                                }\n                            }\n                            fieldDef[prop] = encodingProperty;\n                        }\n                        if (prop === property_1.Property.SCALE && encoding_1.isFieldQuery(encQ) && encQ.type === type_1.Type.ORDINAL) {\n                            var scale = encQ.scale;\n                            var ordinalDomain = this._schema.fieldSchema(encQ.field).ordinalDomain;\n                            if (scale !== null && ordinalDomain) {\n                                fieldDef[property_1.Property.SCALE] = __assign({ domain: ordinalDomain }, (util_1.isObject(scale) ? scale : {}));\n                            }\n                        }\n                    }\n                }\n            }\n            if (fieldDef.bin === false) {\n                // exclude bin false\n                delete fieldDef.bin;\n            }\n            encoding[encQ.channel] = fieldDef;\n        }\n        return encoding;\n    };\n    /**\n     * Convert a query to a Vega-Lite spec if it is completed.\n     * @return a Vega-Lite spec if completed, null otherwise.\n     */\n    SpecQueryModel.prototype.toSpec = function (data) {\n        if (wildcard_1.isWildcard(this._spec.mark))\n            return null;\n        var spec = {};\n        data = data || this._spec.data;\n        if (data) {\n            spec.data = data;\n        }\n        if (this._spec.transform) {\n            spec.transform = this._spec.transform;\n        }\n        spec.mark = this._spec.mark;\n        spec.encoding = this._encoding();\n        if (spec.encoding === null) {\n            return null;\n        }\n        if (this._spec.config || this._opt.defaultSpecConfig)\n            spec.config = util_1.extend({}, this._opt.defaultSpecConfig, this._spec.config);\n        return spec;\n    };\n    SpecQueryModel.prototype.getRankingScore = function (rankingName) {\n        return this._rankingScore[rankingName];\n    };\n    SpecQueryModel.prototype.setRankingScore = function (rankingName, score) {\n        this._rankingScore[rankingName] = score;\n    };\n    return SpecQueryModel;\n}());\nexports.SpecQueryModel = SpecQueryModel;\nfunction getTopSpecQueryItem(specQuery) {\n    var topItem = specQuery.items[0];\n    while (topItem && isSpecQueryGroup(topItem)) {\n        topItem = topItem.items[0];\n    }\n    return topItem;\n}\nexports.getTopSpecQueryItem = getTopSpecQueryItem;\nfunction isSpecQueryGroup(item) {\n    return item.items !== undefined;\n}\nexports.isSpecQueryGroup = isSpecQueryGroup;\n//# sourceMappingURL=model.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"datalib/src/util\");\nvar property_1 = require(\"./property\");\nvar propindex_1 = require(\"./propindex\");\nvar groupby_1 = require(\"./query/groupby\");\nvar shorthand_1 = require(\"./query/shorthand\");\n/**\n * Registry for all possible grouping key functions.\n */\nvar groupRegistry = {};\n/**\n * Add a grouping function to the registry.\n */\nfunction registerKeyFn(name, keyFn) {\n    groupRegistry[name] = keyFn;\n}\nexports.registerKeyFn = registerKeyFn;\nexports.FIELD = 'field';\nexports.FIELD_TRANSFORM = 'fieldTransform';\nexports.ENCODING = 'encoding';\nexports.SPEC = 'spec';\n/**\n * Group the input spec query model by a key function registered in the group registry\n * @return\n */\nfunction nest(specModels, queryNest) {\n    if (queryNest) {\n        var rootGroup_1 = {\n            name: '',\n            path: '',\n            items: [],\n        };\n        var groupIndex_1 = {};\n        // global `includes` and `replaces` will get augmented by each level's groupBy.\n        // Upper level's `groupBy` will get cascaded to lower-level groupBy.\n        // `replace` can be overriden in a lower-level to support different grouping.\n        var includes_1 = [];\n        var replaces = [];\n        var replacers_1 = [];\n        for (var l = 0; l < queryNest.length; l++) {\n            includes_1.push(l > 0 ? includes_1[l - 1].duplicate() : new propindex_1.PropIndex());\n            replaces.push(l > 0 ? replaces[l - 1].duplicate() : new propindex_1.PropIndex());\n            var groupBy = queryNest[l].groupBy;\n            if (util_1.isArray(groupBy)) {\n                // If group is array, it's an array of extended group by that need to be parsed\n                var parsedGroupBy = groupby_1.parseGroupBy(groupBy, includes_1[l], replaces[l]);\n                replacers_1.push(parsedGroupBy.replacer);\n            }\n        }\n        // With includes and replacers, now we can construct the nesting tree\n        specModels.forEach(function (specM) {\n            var path = '';\n            var group = rootGroup_1;\n            for (var l = 0; l < queryNest.length; l++) {\n                var groupBy = group.groupBy = queryNest[l].groupBy;\n                group.orderGroupBy = queryNest[l].orderGroupBy;\n                var key = util_1.isArray(groupBy) ?\n                    shorthand_1.spec(specM.specQuery, includes_1[l], replacers_1[l]) :\n                    groupRegistry[groupBy](specM.specQuery);\n                path += '/' + key;\n                if (!groupIndex_1[path]) {\n                    groupIndex_1[path] = {\n                        name: key,\n                        path: path,\n                        items: [],\n                    };\n                    group.items.push(groupIndex_1[path]);\n                }\n                group = groupIndex_1[path];\n            }\n            group.items.push(specM);\n        });\n        return rootGroup_1;\n    }\n    else {\n        // no nesting, just return a flat group\n        return {\n            name: '',\n            path: '',\n            items: specModels,\n        };\n    }\n}\nexports.nest = nest;\n// TODO: move this to groupBy, rename properly, and export\nvar GROUP_BY_FIELD = [property_1.Property.FIELD];\nvar PARSED_GROUP_BY_FIELD = groupby_1.parseGroupBy(GROUP_BY_FIELD);\nfunction getGroupByKey(specM, groupBy) {\n    return groupRegistry[groupBy](specM);\n}\nexports.getGroupByKey = getGroupByKey;\nregisterKeyFn(exports.FIELD, function (specQ) {\n    return shorthand_1.spec(specQ, PARSED_GROUP_BY_FIELD.include, PARSED_GROUP_BY_FIELD.replacer);\n});\nexports.PARSED_GROUP_BY_FIELD_TRANSFORM = groupby_1.parseGroupBy(groupby_1.GROUP_BY_FIELD_TRANSFORM);\nregisterKeyFn(exports.FIELD_TRANSFORM, function (specQ) {\n    return shorthand_1.spec(specQ, exports.PARSED_GROUP_BY_FIELD_TRANSFORM.include, exports.PARSED_GROUP_BY_FIELD_TRANSFORM.replacer);\n});\nexports.PARSED_GROUP_BY_ENCODING = groupby_1.parseGroupBy(groupby_1.GROUP_BY_ENCODING);\nregisterKeyFn(exports.ENCODING, function (specQ) {\n    return shorthand_1.spec(specQ, exports.PARSED_GROUP_BY_ENCODING.include, exports.PARSED_GROUP_BY_ENCODING.replacer);\n});\nregisterKeyFn(exports.SPEC, function (specQ) { return JSON.stringify(specQ); });\n//# sourceMappingURL=nest.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar axis_1 = require(\"vega-lite/build/src/axis\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar legend_1 = require(\"vega-lite/build/src/legend\");\nvar util_1 = require(\"./util\");\nfunction isEncodingNestedProp(p) {\n    return !!p['parent'];\n}\nexports.isEncodingNestedProp = isEncodingNestedProp;\nexports.ENCODING_TOPLEVEL_PROPS = [\n    // channel\n    'channel',\n    // fn\n    'aggregate', 'autoCount', 'bin', 'timeUnit', 'hasFn',\n    // sort\n    'sort',\n    // field / type\n    'field', 'type',\n    // scale / axis / legend\n    'scale', 'axis', 'legend'\n];\nvar ENCODING_TOPLEVEL_PROPERTY_INDEX = util_1.toMap(exports.ENCODING_TOPLEVEL_PROPS);\nfunction isEncodingTopLevelProperty(p) {\n    return p in ENCODING_TOPLEVEL_PROPERTY_INDEX;\n}\nexports.isEncodingTopLevelProperty = isEncodingTopLevelProperty;\nvar ENCODING_NESTED_PROP_PARENTS = [\n    'bin', 'scale', 'sort', 'axis', 'legend'\n];\nexports.ENCODING_NESTED_PROP_PARENT_INDEX = util_1.toMap(ENCODING_NESTED_PROP_PARENTS);\nfunction hasNestedProperty(prop) {\n    return exports.ENCODING_NESTED_PROP_PARENT_INDEX[prop];\n}\nexports.hasNestedProperty = hasNestedProperty;\n// FIXME -- we should not have to manually specify these\nexports.BIN_CHILD_PROPS = ['maxbins', 'divide', 'extent', 'base', 'step', 'steps', 'minstep'];\nexports.SORT_CHILD_PROPS = ['field', 'op', 'order'];\nvar BIN_PROPS = exports.BIN_CHILD_PROPS.map(function (c) {\n    return { parent: 'bin', child: c };\n});\nexports.SORT_PROPS = exports.SORT_CHILD_PROPS.map(function (c) {\n    return { parent: 'sort', child: c };\n});\nexports.SCALE_PROPS = scale_1.SCALE_PROPERTIES.map(function (c) {\n    return { parent: 'scale', child: c };\n});\nvar AXIS_PROPS = axis_1.AXIS_PROPERTIES.map(function (c) {\n    return { parent: 'axis', child: c };\n});\nvar LEGEND_PROPS = legend_1.LEGEND_PROPERTIES.map(function (c) {\n    return { parent: 'legend', child: c };\n});\nexports.ENCODING_NESTED_PROPS = [].concat(BIN_PROPS, exports.SORT_PROPS, exports.SCALE_PROPS, AXIS_PROPS, LEGEND_PROPS);\nvar PROP_KEY_DELIMITER = '.';\nfunction toKey(p) {\n    if (isEncodingNestedProp(p)) {\n        return p.parent + PROP_KEY_DELIMITER + p.child;\n    }\n    return p;\n}\nexports.toKey = toKey;\nfunction fromKey(k) {\n    var split = k.split(PROP_KEY_DELIMITER);\n    /* istanbul ignore else */\n    if (split.length === 1) {\n        return k;\n    }\n    else if (split.length === 2) {\n        return {\n            parent: split[0],\n            child: split[1]\n        };\n    }\n    else {\n        throw 'Invalid property key with ' + split.length + ' dots: ' + k;\n    }\n}\nexports.fromKey = fromKey;\nvar ENCODING_NESTED_PROP_INDEX = exports.ENCODING_NESTED_PROPS.reduce(function (i, prop) {\n    i[prop.parent] = i[prop.parent] || [];\n    i[prop.parent][prop.child] = prop;\n    return i;\n}, {});\n// FIXME consider using a more general method\nfunction getEncodingNestedProp(parent, child) {\n    return (ENCODING_NESTED_PROP_INDEX[parent] || {})[child];\n}\nexports.getEncodingNestedProp = getEncodingNestedProp;\nfunction isEncodingProperty(prop) {\n    return isEncodingTopLevelProperty(prop) || isEncodingNestedProp(prop);\n}\nexports.isEncodingProperty = isEncodingProperty;\nexports.ALL_ENCODING_PROPS = [].concat(exports.ENCODING_TOPLEVEL_PROPS, exports.ENCODING_NESTED_PROPS);\nexports.DEFAULT_PROP_PRECEDENCE = [\n    'type',\n    'field',\n    // Field Transform\n    'bin', 'timeUnit', 'aggregate', 'autoCount',\n    // Encoding\n    'channel',\n    // Mark\n    'mark',\n    'scale', 'sort',\n    'axis', 'legend'\n].concat(BIN_PROPS, exports.SCALE_PROPS, AXIS_PROPS, LEGEND_PROPS, exports.SORT_PROPS);\nvar Property;\n(function (Property) {\n    Property.MARK = 'mark';\n    Property.TRANSFORM = 'transform';\n    // Layout\n    Property.STACK = 'stack';\n    // TODO: sub parts of stack\n    // Encoding Properties\n    Property.CHANNEL = 'channel';\n    Property.AGGREGATE = 'aggregate';\n    Property.AUTOCOUNT = 'autoCount';\n    Property.BIN = 'bin';\n    Property.HAS_FN = 'hasFn';\n    Property.TIMEUNIT = 'timeUnit';\n    Property.FIELD = 'field';\n    Property.TYPE = 'type';\n    Property.SORT = 'sort';\n    Property.SCALE = 'scale';\n    Property.AXIS = 'axis';\n    Property.LEGEND = 'legend';\n})(Property = exports.Property || (exports.Property = {}));\n//# sourceMappingURL=property.js.map",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar property_1 = require(\"./property\");\n/**\n * Dictionary that takes property as a key.\n */\nvar PropIndex = /** @class */ (function () {\n    function PropIndex(i) {\n        if (i === void 0) { i = null; }\n        this.index = i ? __assign({}, i) : {};\n    }\n    PropIndex.prototype.has = function (p) {\n        return property_1.toKey(p) in this.index;\n    };\n    PropIndex.prototype.get = function (p) {\n        return this.index[property_1.toKey(p)];\n    };\n    PropIndex.prototype.set = function (p, value) {\n        this.index[property_1.toKey(p)] = value;\n        return this;\n    };\n    PropIndex.prototype.setByKey = function (key, value) {\n        this.index[key] = value;\n    };\n    PropIndex.prototype.map = function (f) {\n        var i = new PropIndex();\n        for (var k in this.index) {\n            i.index[k] = f(this.index[k]);\n        }\n        return i;\n    };\n    PropIndex.prototype.size = function () {\n        return util_1.keys(this.index).length;\n    };\n    PropIndex.prototype.duplicate = function () {\n        return new PropIndex(this.index);\n    };\n    return PropIndex;\n}());\nexports.PropIndex = PropIndex;\n//# sourceMappingURL=propindex.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar vlFieldDef = require(\"vega-lite/build/src/fielddef\");\nvar expandedtype_1 = require(\"./expandedtype\");\nvar type_1 = require(\"vega-lite/build/src/compile/scale/type\");\nvar wildcard_1 = require(\"../wildcard\");\nfunction isValueQuery(encQ) {\n    return encQ !== null && encQ !== undefined && encQ['value'];\n}\nexports.isValueQuery = isValueQuery;\nfunction isFieldQuery(encQ) {\n    return encQ !== null && encQ !== undefined && (encQ['field'] || encQ['aggregate'] === 'count');\n}\nexports.isFieldQuery = isFieldQuery;\nfunction isAutoCountQuery(encQ) {\n    return encQ !== null && encQ !== undefined && 'autoCount' in encQ;\n}\nexports.isAutoCountQuery = isAutoCountQuery;\nfunction isDisabledAutoCountQuery(encQ) {\n    return isAutoCountQuery(encQ) && encQ.autoCount === false;\n}\nexports.isDisabledAutoCountQuery = isDisabledAutoCountQuery;\nfunction isEnabledAutoCountQuery(encQ) {\n    return isAutoCountQuery(encQ) && encQ.autoCount === true;\n}\nexports.isEnabledAutoCountQuery = isEnabledAutoCountQuery;\nfunction toFieldDef(encQ, props) {\n    if (props === void 0) { props = ['aggregate', 'bin', 'timeUnit', 'field', 'type']; }\n    if (isFieldQuery(encQ)) {\n        return props.reduce(function (fieldDef, prop) {\n            var propValue = encQ[prop];\n            if (wildcard_1.isWildcard(propValue)) {\n                throw new Error(\"Cannot convert \" + JSON.stringify(encQ) + \" to fielddef: \" + prop + \" is wildcard\");\n            }\n            else if (propValue !== undefined) {\n                if (prop === 'type') {\n                    fieldDef.type = propValue;\n                }\n                else {\n                    fieldDef[prop] = propValue;\n                }\n            }\n            return fieldDef;\n        }, {});\n    }\n    else {\n        if (encQ.autoCount === false) {\n            throw new Error(\"Cannot convert {autoCount: false} into a field def\");\n        }\n        else {\n            return props.reduce(function (fieldDef, prop) {\n                if (wildcard_1.isWildcard(encQ[prop])) {\n                    throw new Error(\"Cannot convert \" + JSON.stringify(encQ) + \" to fielddef: \" + prop + \" is wildcard\");\n                }\n                switch (prop) {\n                    case 'type':\n                        fieldDef.type = 'quantitative';\n                        break;\n                    case 'aggregate':\n                        fieldDef.aggregate = 'count';\n                        break;\n                }\n                return fieldDef;\n            }, {});\n        }\n    }\n}\nexports.toFieldDef = toFieldDef;\n/**\n * Is a field query continuous field?\n * This method is applicable only for fieldQuery without wildcard\n */\nfunction isContinuous(encQ) {\n    if (isFieldQuery(encQ)) {\n        return vlFieldDef.isContinuous(toFieldDef(encQ, ['bin', 'timeUnit', 'field', 'type']));\n    }\n    return isAutoCountQuery(encQ);\n}\nexports.isContinuous = isContinuous;\nfunction isMeasure(encQ) {\n    if (isFieldQuery(encQ)) {\n        return !isDimension(encQ) && encQ.type !== 'temporal';\n    }\n    return isAutoCountQuery(encQ);\n}\nexports.isMeasure = isMeasure;\n/**\n * Is a field query discrete field?\n * This method is applicable only for fieldQuery without wildcard\n */\nfunction isDimension(encQ) {\n    if (isFieldQuery(encQ)) {\n        var fieldDef = toFieldDef(encQ, ['bin', 'timeUnit', 'field', 'type']);\n        return vlFieldDef.isDiscrete(fieldDef) || !!fieldDef.timeUnit;\n    }\n    return false;\n}\nexports.isDimension = isDimension;\n/**\n *  Returns the true scale type of an encoding.\n *  @returns {ScaleType} If the scale type was not specified, it is inferred from the encoding's Type.\n *  @returns {undefined} If the scale type was not specified and Type (or TimeUnit if applicable) is a Wildcard, there is no clear scale type\n */\nfunction scaleType(fieldQ) {\n    var scale = fieldQ.scale === true || fieldQ.scale === wildcard_1.SHORT_WILDCARD ? {} : fieldQ.scale || {};\n    var type = fieldQ.type, channel = fieldQ.channel, timeUnit = fieldQ.timeUnit, bin = fieldQ.bin;\n    // HACK: All of markType, and scaleConfig only affect\n    // sub-type of ordinal to quantitative scales (point or band)\n    // Currently, most of scaleType usage in CompassQL doesn't care about this subtle difference.\n    // Thus, instead of making this method requiring the global mark,\n    // we will just call it with mark = undefined .\n    // Thus, currently, we will always get a point scale unless a CompassQuery specifies band.\n    var markType = undefined;\n    var scaleConfig = {};\n    if (wildcard_1.isWildcard(scale.type) || wildcard_1.isWildcard(type) || wildcard_1.isWildcard(channel) || wildcard_1.isWildcard(bin)) {\n        return undefined;\n    }\n    // If scale type is specified, then use scale.type\n    if (scale.type) {\n        return scale.type;\n    }\n    // if type is fixed and it's not temporal, we can ignore time unit.\n    if (type === 'temporal' && wildcard_1.isWildcard(timeUnit)) {\n        return undefined;\n    }\n    // if type is fixed and it's not quantitative, we can ignore bin\n    if (type === 'quantitative' && wildcard_1.isWildcard(bin)) {\n        return undefined;\n    }\n    var vegaLiteType = type === expandedtype_1.ExpandedType.KEY ? 'nominal' : type;\n    var fieldDef = { type: vegaLiteType, timeUnit: timeUnit, bin: bin };\n    return type_1.scaleType(scale.type, channel, fieldDef, markType, scaleConfig);\n}\nexports.scaleType = scaleType;\n//# sourceMappingURL=encoding.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar ExpandedType;\n(function (ExpandedType) {\n    ExpandedType.QUANTITATIVE = type_1.Type.QUANTITATIVE;\n    ExpandedType.ORDINAL = type_1.Type.ORDINAL;\n    ExpandedType.TEMPORAL = type_1.Type.TEMPORAL;\n    ExpandedType.NOMINAL = type_1.Type.NOMINAL;\n    ExpandedType.KEY = 'key';\n})(ExpandedType = exports.ExpandedType || (exports.ExpandedType = {}));\nfunction isDiscrete(fieldType) {\n    return fieldType === type_1.Type.ORDINAL || fieldType === type_1.Type.NOMINAL || fieldType === ExpandedType.KEY;\n}\nexports.isDiscrete = isDiscrete;\n//# sourceMappingURL=expandedtype.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"datalib/src/util\");\nvar shorthand_1 = require(\"./shorthand\");\nvar property_1 = require(\"../property\");\nvar propindex_1 = require(\"../propindex\");\nvar util_2 = require(\"../util\");\nexports.REPLACE_BLANK_FIELDS = { '*': '' };\nexports.REPLACE_XY_CHANNELS = { x: 'xy', y: 'xy' };\nexports.REPLACE_FACET_CHANNELS = { row: 'facet', column: 'facet' };\nexports.REPLACE_MARK_STYLE_CHANNELS = { color: 'style', opacity: 'style', shape: 'style', size: 'style' };\nfunction isExtendedGroupBy(g) {\n    return util_1.isObject(g) && !!g['property'];\n}\nexports.isExtendedGroupBy = isExtendedGroupBy;\nfunction parseGroupBy(groupBy, include, replaceIndex) {\n    include = include || new propindex_1.PropIndex();\n    replaceIndex = replaceIndex || new propindex_1.PropIndex();\n    groupBy.forEach(function (grpBy) {\n        if (isExtendedGroupBy(grpBy)) {\n            include.setByKey(grpBy.property, true);\n            replaceIndex.setByKey(grpBy.property, grpBy.replace);\n        }\n        else {\n            include.setByKey(grpBy, true);\n        }\n    });\n    return {\n        include: include,\n        replaceIndex: replaceIndex,\n        replacer: shorthand_1.getReplacerIndex(replaceIndex)\n    };\n}\nexports.parseGroupBy = parseGroupBy;\nfunction toString(groupBy) {\n    if (util_1.isArray(groupBy)) {\n        return groupBy.map(function (g) {\n            if (isExtendedGroupBy(g)) {\n                if (g.replace) {\n                    var replaceIndex_1 = util_2.keys(g.replace).reduce(function (index, valFrom) {\n                        var valTo = g.replace[valFrom];\n                        (index[valTo] = index[valTo] || []).push(valFrom);\n                        return index;\n                    }, {});\n                    return g.property + '[' + util_2.keys(replaceIndex_1).map(function (valTo) {\n                        var valsFrom = replaceIndex_1[valTo].sort();\n                        return valsFrom.join(',') + '=>' + valTo;\n                    }).join(';') + ']';\n                }\n                return g.property;\n            }\n            return g;\n        }).join(',');\n    }\n    else {\n        return groupBy;\n    }\n}\nexports.toString = toString;\nexports.GROUP_BY_FIELD_TRANSFORM = [\n    property_1.Property.FIELD, property_1.Property.TYPE,\n    property_1.Property.AGGREGATE, property_1.Property.BIN, property_1.Property.TIMEUNIT, property_1.Property.STACK\n];\nexports.GROUP_BY_ENCODING = exports.GROUP_BY_FIELD_TRANSFORM.concat([\n    {\n        property: property_1.Property.CHANNEL,\n        replace: {\n            'x': 'xy', 'y': 'xy',\n            'color': 'style', 'size': 'style', 'shape': 'style', 'opacity': 'style',\n            'row': 'facet', 'column': 'facet'\n        }\n    }\n]);\n//# sourceMappingURL=groupby.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encoding = require(\"./encoding\");\nvar normalize_1 = require(\"./normalize\");\nexports.normalize = normalize_1.normalize;\nexports.groupBy = require(\"./groupby\");\nexports.shorthand = require(\"./shorthand\");\nexports.spec = require(\"./spec\");\nexports.transform = require(\"./transform\");\n//# sourceMappingURL=index.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../util\");\n/**\n * Normalize the non-nested version of the query to a standardize nested\n */\nfunction normalize(q) {\n    if (q.groupBy) {\n        var nest = {\n            groupBy: q.groupBy\n        };\n        if (q.orderBy) {\n            nest.orderGroupBy = q.orderBy;\n        }\n        var normalizedQ = {\n            spec: util_1.duplicate(q.spec),\n            nest: [nest],\n        };\n        if (q.chooseBy) {\n            normalizedQ.chooseBy = q.chooseBy;\n        }\n        if (q.config) {\n            normalizedQ.config = q.config;\n        }\n        return normalizedQ;\n    }\n    return util_1.duplicate(q); // We will cause side effect to q.spec in SpecQueryModel.build\n}\nexports.normalize = normalize;\n//# sourceMappingURL=normalize.js.map",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar aggregate_1 = require(\"vega-lite/build/src/aggregate\");\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar timeunit_1 = require(\"vega-lite/build/src/timeunit\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar util_1 = require(\"datalib/src/util\");\nvar encoding_1 = require(\"./encoding\");\nvar spec_1 = require(\"./spec\");\nvar wildcard_1 = require(\"../wildcard\");\nvar property_1 = require(\"../property\");\nvar propindex_1 = require(\"../propindex\");\nvar util_2 = require(\"../util\");\nfunction getReplacerIndex(replaceIndex) {\n    return replaceIndex.map(function (r) { return getReplacer(r); });\n}\nexports.getReplacerIndex = getReplacerIndex;\nfunction getReplacer(replace) {\n    return function (s) {\n        if (replace[s] !== undefined) {\n            return replace[s];\n        }\n        return s;\n    };\n}\nexports.getReplacer = getReplacer;\nfunction value(v, replacer) {\n    if (wildcard_1.isWildcard(v)) {\n        // Return the enum array if it's a full wildcard, or just return SHORT_WILDCARD for short ones.\n        if (!wildcard_1.isShortWildcard(v) && v.enum) {\n            return wildcard_1.SHORT_WILDCARD + JSON.stringify(v.enum);\n        }\n        else {\n            return wildcard_1.SHORT_WILDCARD;\n        }\n    }\n    if (replacer) {\n        return replacer(v);\n    }\n    return v;\n}\nexports.value = value;\nfunction replace(v, replacer) {\n    if (replacer) {\n        return replacer(v);\n    }\n    return v;\n}\nexports.replace = replace;\nexports.REPLACE_NONE = new propindex_1.PropIndex();\nexports.INCLUDE_ALL = \n// FIXME: remove manual TRANSFORM concat once we really support enumerating transform.\n[].concat(property_1.DEFAULT_PROP_PRECEDENCE, property_1.SORT_PROPS, [property_1.Property.TRANSFORM, property_1.Property.STACK])\n    .reduce(function (pi, prop) { return pi.set(prop, true); }, new propindex_1.PropIndex());\nfunction vlSpec(vlspec, include, replace) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replace === void 0) { replace = exports.REPLACE_NONE; }\n    var specQ = spec_1.fromSpec(vlspec);\n    return spec(specQ, include, replace);\n}\nexports.vlSpec = vlSpec;\nexports.PROPERTY_SUPPORTED_CHANNELS = {\n    axis: { x: true, y: true, row: true, column: true },\n    legend: { color: true, opacity: true, size: true, shape: true },\n    scale: { x: true, y: true, color: true, opacity: true, row: true, column: true, size: true, shape: true },\n    sort: { x: true, y: true, path: true, order: true }\n};\n/**\n * Returns a shorthand for a spec query\n * @param specQ a spec query\n * @param include Dict Set listing property types (key) to be included in the shorthand\n * @param replace Dictionary of replace function for values of a particular property type (key)\n */\nfunction spec(specQ, include, replace) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replace === void 0) { replace = exports.REPLACE_NONE; }\n    var parts = [];\n    if (include.get(property_1.Property.MARK)) {\n        parts.push(value(specQ.mark, replace.get(property_1.Property.MARK)));\n    }\n    if (specQ.transform && specQ.transform.length > 0) {\n        parts.push('transform:' + JSON.stringify(specQ.transform));\n    }\n    // TODO: extract this to its own stack method\n    if (include.get(property_1.Property.STACK)) {\n        var _stack = spec_1.stack(specQ);\n        if (_stack) {\n            // TODO: Refactor this once we have child stack property.\n            // Exclude type since we don't care about type in stack\n            var includeExceptType = include.duplicate().set('type', false);\n            var field = fieldDef(_stack.fieldEncQ, includeExceptType, replace);\n            var groupby = _stack.groupByEncQ ? fieldDef(_stack.groupByEncQ, includeExceptType, replace) : undefined;\n            parts.push('stack={field:' + field + ',' +\n                (groupby ? 'by:' + groupby + ',' : '') +\n                'offset:' + _stack.offset + '}');\n        }\n    }\n    if (specQ.encodings) {\n        var encodings = specQ.encodings.reduce(function (encQs, encQ) {\n            // Exclude encoding mapping with autoCount=false as they are basically disabled.\n            if (!encoding_1.isDisabledAutoCountQuery(encQ)) {\n                var str = encoding(encQ, include, replace);\n                if (str) {\n                    encQs.push(str);\n                }\n            }\n            return encQs;\n        }, [])\n            .sort() // sort at the end to ignore order\n            .join('|');\n        if (encodings) {\n            parts.push(encodings);\n        }\n    }\n    return parts.join('|');\n}\nexports.spec = spec;\n/**\n * Returns a shorthand for an encoding query\n * @param encQ an encoding query\n * @param include Dict Set listing property types (key) to be included in the shorthand\n * @param replace Dictionary of replace function for values of a particular property type (key)\n */\nfunction encoding(encQ, include, replace) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replace === void 0) { replace = exports.REPLACE_NONE; }\n    var parts = [];\n    if (include.get(property_1.Property.CHANNEL)) {\n        parts.push(value(encQ.channel, replace.get(property_1.Property.CHANNEL)));\n    }\n    if (encoding_1.isFieldQuery(encQ)) {\n        var fieldDefStr = fieldDef(encQ, include, replace);\n        if (fieldDefStr) {\n            parts.push(fieldDefStr);\n        }\n    }\n    else if (encoding_1.isValueQuery(encQ)) {\n        parts.push(encQ.value);\n    }\n    return parts.join(':');\n}\nexports.encoding = encoding;\n/**\n * Returns a field definition shorthand for an encoding query\n * @param encQ an encoding query\n * @param include Dict Set listing property types (key) to be included in the shorthand\n * @param replace Dictionary of replace function for values of a particular property type (key)\n */\nfunction fieldDef(encQ, include, replacer) {\n    if (include === void 0) { include = exports.INCLUDE_ALL; }\n    if (replacer === void 0) { replacer = exports.REPLACE_NONE; }\n    if (include.get(property_1.Property.AGGREGATE) && encoding_1.isDisabledAutoCountQuery(encQ)) {\n        return '-';\n    }\n    var fn = func(encQ, include, replacer);\n    var props = fieldDefProps(encQ, include, replacer);\n    var fieldAndParams;\n    if (encoding_1.isFieldQuery(encQ)) {\n        // field\n        fieldAndParams = include.get('field') ? value(encQ.field, replacer.get('field')) : '...';\n        // type\n        if (include.get(property_1.Property.TYPE)) {\n            if (wildcard_1.isWildcard(encQ.type)) {\n                fieldAndParams += ',' + value(encQ.type, replacer.get(property_1.Property.TYPE));\n            }\n            else {\n                var typeShort = ((encQ.type || type_1.Type.QUANTITATIVE) + '').substr(0, 1);\n                fieldAndParams += ',' + value(typeShort, replacer.get(property_1.Property.TYPE));\n            }\n        }\n        // encoding properties\n        fieldAndParams += props.map(function (p) {\n            var val = p.value instanceof Array ? '[' + p.value + ']' : p.value;\n            return ',' + p.key + '=' + val;\n        }).join('');\n    }\n    else if (encoding_1.isAutoCountQuery(encQ)) {\n        fieldAndParams = '*,q';\n    }\n    if (!fieldAndParams) {\n        return null;\n    }\n    if (fn) {\n        var fnPrefix = util_1.isString(fn) ? fn : wildcard_1.SHORT_WILDCARD +\n            (util_2.keys(fn).length > 0 ? JSON.stringify(fn) : '');\n        return fnPrefix + '(' + fieldAndParams + ')';\n    }\n    return fieldAndParams;\n}\nexports.fieldDef = fieldDef;\n/**\n * Return function part of\n */\nfunction func(fieldQ, include, replacer) {\n    if (include.get(property_1.Property.AGGREGATE) && fieldQ.aggregate && !wildcard_1.isWildcard(fieldQ.aggregate)) {\n        return replace(fieldQ.aggregate, replacer.get(property_1.Property.AGGREGATE));\n    }\n    else if (include.get(property_1.Property.AGGREGATE) && encoding_1.isEnabledAutoCountQuery(fieldQ)) {\n        // autoCount is considered a part of aggregate\n        return replace('count', replacer.get(property_1.Property.AGGREGATE));\n        ;\n    }\n    else if (include.get(property_1.Property.TIMEUNIT) && fieldQ.timeUnit && !wildcard_1.isWildcard(fieldQ.timeUnit)) {\n        return replace(fieldQ.timeUnit, replacer.get(property_1.Property.TIMEUNIT));\n    }\n    else if (include.get(property_1.Property.BIN) && fieldQ.bin && !wildcard_1.isWildcard(fieldQ.bin)) {\n        return 'bin';\n    }\n    else {\n        var fn = null;\n        for (var _i = 0, _a = [property_1.Property.AGGREGATE, property_1.Property.AUTOCOUNT, property_1.Property.TIMEUNIT, property_1.Property.BIN]; _i < _a.length; _i++) {\n            var prop = _a[_i];\n            var val = fieldQ[prop];\n            if (include.get(prop) && fieldQ[prop] && wildcard_1.isWildcard(val)) {\n                // assign fnEnumIndex[prop] = array of enum values or just \"?\" if it is SHORT_WILDCARD\n                fn = fn || {};\n                fn[prop] = wildcard_1.isShortWildcard(val) ? val : val.enum;\n            }\n        }\n        if (fn && fieldQ.hasFn) {\n            fn.hasFn = true;\n        }\n        return fn;\n    }\n}\n/**\n * Return key-value of parameters of field defs\n */\nfunction fieldDefProps(fieldQ, include, replacer) {\n    /** Encoding properties e.g., Scale, Axis, Legend */\n    var props = [];\n    // Parameters of function such as bin will be just top-level properties\n    if (!util_2.isBoolean(fieldQ.bin) && !wildcard_1.isShortWildcard(fieldQ.bin)) {\n        var bin = fieldQ.bin;\n        for (var child in bin) {\n            var prop = property_1.getEncodingNestedProp('bin', child);\n            if (prop && include.get(prop) && bin[child] !== undefined) {\n                props.push({\n                    key: child,\n                    value: value(bin[child], replacer.get(prop))\n                });\n            }\n        }\n        // Sort to make sure that parameter are ordered consistently\n        props.sort(function (a, b) { return a.key.localeCompare(b.key); });\n    }\n    for (var _i = 0, _a = [property_1.Property.SCALE, property_1.Property.SORT, property_1.Property.AXIS, property_1.Property.LEGEND]; _i < _a.length; _i++) {\n        var parent_1 = _a[_i];\n        if (!wildcard_1.isWildcard(fieldQ.channel) && !exports.PROPERTY_SUPPORTED_CHANNELS[parent_1][fieldQ.channel]) {\n            continue;\n        }\n        if (include.get(parent_1) && fieldQ[parent_1] !== undefined) {\n            var parentValue = fieldQ[parent_1];\n            if (util_2.isBoolean(parentValue) || parentValue === null) {\n                // `scale`, `axis`, `legend` can be false/null.\n                props.push({\n                    key: parent_1 + '',\n                    value: parentValue || false // return true or false (false if null)\n                });\n            }\n            else if (util_1.isString(parentValue)) {\n                // `sort` can be a string (ascending/descending).\n                props.push({\n                    key: parent_1 + '',\n                    value: replace(JSON.stringify(parentValue), replacer.get(parent_1))\n                });\n            }\n            else {\n                var nestedPropChildren = [];\n                for (var child in parentValue) {\n                    var nestedProp = property_1.getEncodingNestedProp(parent_1, child);\n                    if (nestedProp && include.get(nestedProp) && parentValue[child] !== undefined) {\n                        nestedPropChildren.push({\n                            key: child,\n                            value: value(parentValue[child], replacer.get(nestedProp))\n                        });\n                    }\n                }\n                if (nestedPropChildren.length > 0) {\n                    var nestedPropObject = nestedPropChildren.sort(function (a, b) { return a.key.localeCompare(b.key); })\n                        .reduce(function (o, item) {\n                        o[item.key] = item.value;\n                        return o;\n                    }, {});\n                    // Sort to make sure that parameter are ordered consistently\n                    props.push({\n                        key: parent_1 + '',\n                        value: JSON.stringify(nestedPropObject)\n                    });\n                }\n            }\n        }\n    }\n    return props;\n}\nfunction parse(shorthand) {\n    // TODO(https://github.com/uwdata/compassql/issues/259):\n    // Do not split directly, but use an upgraded version of `getClosingBraceIndex()`\n    var splitShorthand = shorthand.split('|');\n    var specQ = {\n        mark: splitShorthand[0],\n        encodings: []\n    };\n    for (var i = 1; i < splitShorthand.length; i++) {\n        var part = splitShorthand[i];\n        var splitPart = splitWithTail(part, ':', 1);\n        var splitPartKey = splitPart[0];\n        var splitPartValue = splitPart[1];\n        if (channel_1.isChannel(splitPartKey) || splitPartKey === '?') {\n            var encQ = shorthandParser.encoding(splitPartKey, splitPartValue);\n            specQ.encodings.push(encQ);\n            continue;\n        }\n        if (splitPartKey === 'transform') {\n            specQ.transform = JSON.parse(splitPartValue);\n            continue;\n        }\n    }\n    return specQ;\n}\nexports.parse = parse;\n/**\n * Split a string n times into substrings with the specified delimiter and return them as an array.\n * @param str The string to be split\n * @param delim The delimiter string used to separate the string\n * @param number The value used to determine how many times the string is split\n */\nfunction splitWithTail(str, delim, count) {\n    var result = [];\n    var lastIndex = 0;\n    for (var i = 0; i < count; i++) {\n        var indexOfDelim = str.indexOf(delim, lastIndex);\n        if (indexOfDelim !== -1) {\n            result.push(str.substring(lastIndex, indexOfDelim));\n            lastIndex = indexOfDelim + 1;\n        }\n        else {\n            break;\n        }\n    }\n    result.push(str.substr(lastIndex));\n    // If the specified count is greater than the number of delimiters that exist in the string,\n    // an empty string will be pushed count minus number of delimiter occurence times.\n    if (result.length !== count + 1) {\n        while (result.length !== count + 1) {\n            result.push('');\n        }\n    }\n    return result;\n}\nexports.splitWithTail = splitWithTail;\nvar shorthandParser;\n(function (shorthandParser) {\n    function encoding(channel, fieldDefShorthand) {\n        var encQMixins = fieldDefShorthand.indexOf('(') !== -1 ?\n            fn(fieldDefShorthand) :\n            rawFieldDef(splitWithTail(fieldDefShorthand, ',', 2));\n        return __assign({ channel: channel }, encQMixins);\n    }\n    shorthandParser.encoding = encoding;\n    function rawFieldDef(fieldDefPart) {\n        var fieldQ = {};\n        fieldQ.field = fieldDefPart[0];\n        fieldQ.type = type_1.getFullName(fieldDefPart[1].toUpperCase()) || '?';\n        var partParams = fieldDefPart[2];\n        var closingBraceIndex = 0;\n        var i = 0;\n        while (i < partParams.length) {\n            var propEqualSignIndex = partParams.indexOf('=', i);\n            var parsedValue = void 0;\n            if (propEqualSignIndex !== -1) {\n                var prop = partParams.substring(i, propEqualSignIndex);\n                if (partParams[i + prop.length + 1] === '{') {\n                    var openingBraceIndex = i + prop.length + 1;\n                    closingBraceIndex = getClosingIndex(openingBraceIndex, partParams, '}');\n                    var value_1 = partParams.substring(openingBraceIndex, closingBraceIndex + 1);\n                    parsedValue = JSON.parse(value_1);\n                    // index after next comma\n                    i = closingBraceIndex + 2;\n                }\n                else if (partParams[i + prop.length + 1] === '[') {\n                    // find closing square bracket\n                    var openingBracketIndex = i + prop.length + 1;\n                    var closingBracketIndex = getClosingIndex(openingBracketIndex, partParams, ']');\n                    var value_2 = partParams.substring(openingBracketIndex, closingBracketIndex + 1);\n                    parsedValue = JSON.parse(value_2);\n                    // index after next comma\n                    i = closingBracketIndex + 2;\n                }\n                else {\n                    var propIndex = i;\n                    // Substring until the next comma (or end of the string)\n                    var nextCommaIndex = partParams.indexOf(',', i + prop.length);\n                    if (nextCommaIndex === -1) {\n                        nextCommaIndex = partParams.length;\n                    }\n                    // index after next comma\n                    i = nextCommaIndex + 1;\n                    parsedValue = JSON.parse(partParams.substring(propIndex + prop.length + 1, nextCommaIndex));\n                }\n                if (property_1.hasNestedProperty(prop)) {\n                    fieldQ[prop] = parsedValue;\n                }\n                else {\n                    // prop is a property of the aggregation function such as bin\n                    fieldQ.bin = fieldQ.bin || {};\n                    fieldQ.bin[prop] = parsedValue;\n                }\n            }\n            else {\n                // something is wrong with the format of the partParams\n                // exits loop if don't have then infintie loop\n                break;\n            }\n        }\n        return fieldQ;\n    }\n    shorthandParser.rawFieldDef = rawFieldDef;\n    function getClosingIndex(openingBraceIndex, str, closingChar) {\n        for (var i = openingBraceIndex; i < str.length; i++) {\n            if (str[i] === closingChar) {\n                return i;\n            }\n        }\n    }\n    shorthandParser.getClosingIndex = getClosingIndex;\n    function fn(fieldDefShorthand) {\n        var fieldQ = {};\n        // Aggregate, Bin, TimeUnit as wildcard case\n        if (fieldDefShorthand[0] === '?') {\n            var closingBraceIndex = getClosingIndex(1, fieldDefShorthand, '}');\n            var fnEnumIndex = JSON.parse(fieldDefShorthand.substring(1, closingBraceIndex + 1));\n            for (var encodingProperty in fnEnumIndex) {\n                if (util_2.isArray(fnEnumIndex[encodingProperty])) {\n                    fieldQ[encodingProperty] = { enum: fnEnumIndex[encodingProperty] };\n                }\n                else {\n                    fieldQ[encodingProperty] = fnEnumIndex[encodingProperty];\n                }\n            }\n            return __assign({}, fieldQ, rawFieldDef(splitWithTail(fieldDefShorthand.substring(closingBraceIndex + 2, fieldDefShorthand.length - 1), ',', 2)));\n        }\n        else {\n            var func_1 = fieldDefShorthand.substring(0, fieldDefShorthand.indexOf('('));\n            var insideFn = fieldDefShorthand.substring(func_1.length + 1, fieldDefShorthand.length - 1);\n            var insideFnParts = splitWithTail(insideFn, ',', 2);\n            if (aggregate_1.isAggregateOp(func_1)) {\n                return __assign({ aggregate: func_1 }, rawFieldDef(insideFnParts));\n            }\n            else if (timeunit_1.isTimeUnit(func_1)) {\n                return __assign({ timeUnit: func_1 }, rawFieldDef(insideFnParts));\n            }\n            else if (func_1 === 'bin') {\n                return __assign({ bin: {} }, rawFieldDef(insideFnParts));\n            }\n        }\n    }\n    shorthandParser.fn = fn;\n})(shorthandParser = exports.shorthandParser || (exports.shorthandParser = {}));\n//# sourceMappingURL=shorthand.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar wildcard_1 = require(\"../wildcard\");\nvar property_1 = require(\"../property\");\nvar util_1 = require(\"../util\");\nvar encoding_1 = require(\"./encoding\");\nvar util_2 = require(\"datalib/src/util\");\n/**\n * Convert a Vega-Lite's ExtendedUnitSpec into a CompassQL's SpecQuery\n * @param {ExtendedUnitSpec} spec\n * @returns\n */\nfunction fromSpec(spec) {\n    return util_1.extend(spec.data ? { data: spec.data } : {}, spec.transform ? { transform: spec.transform } : {}, {\n        mark: spec.mark,\n        encodings: util_1.keys(spec.encoding).map(function (channel) {\n            var encQ = { channel: channel };\n            var channelDef = spec.encoding[channel];\n            for (var prop in channelDef) {\n                if (property_1.isEncodingTopLevelProperty(prop) && channelDef[prop] !== undefined) {\n                    // Currently bin, scale, axis, legend only support boolean, but not null.\n                    // Therefore convert null to false.\n                    if (util_1.contains(['bin', 'scale', 'axis', 'legend'], prop) && channelDef[prop] === null) {\n                        encQ[prop] = false;\n                    }\n                    else {\n                        encQ[prop] = channelDef[prop];\n                    }\n                }\n            }\n            if (encoding_1.isFieldQuery(encQ) && encQ.aggregate === 'count' && !encQ.field) {\n                encQ.field = '*';\n            }\n            return encQ;\n        })\n    }, spec.config ? { config: spec.config } : {});\n}\nexports.fromSpec = fromSpec;\nfunction isAggregate(specQ) {\n    return util_1.some(specQ.encodings, function (encQ) {\n        return (encoding_1.isFieldQuery(encQ) && !wildcard_1.isWildcard(encQ.aggregate) && !!encQ.aggregate) || encoding_1.isEnabledAutoCountQuery(encQ);\n    });\n}\nexports.isAggregate = isAggregate;\n/**\n * @return the stack offset type for the specQuery\n */\nfunction stack(specQ) {\n    var config = specQ.config;\n    var stacked = config ? config.stack : undefined;\n    // Should not have stack explicitly disabled\n    if (util_1.contains(['none', null, false], stacked)) {\n        return null;\n    }\n    // Should have stackable mark\n    if (!util_1.contains(['bar', 'area'], specQ.mark)) {\n        return null;\n    }\n    // Should be aggregate plot\n    if (!isAggregate(specQ)) {\n        return null;\n    }\n    var stackBy = specQ.encodings.reduce(function (sc, encQ) {\n        if (util_1.contains(channel_1.NONSPATIAL_CHANNELS, encQ.channel) && (encoding_1.isValueQuery(encQ) || (encoding_1.isFieldQuery(encQ) && !encQ.aggregate))) {\n            sc.push({\n                channel: encQ.channel,\n                fieldDef: encQ\n            });\n        }\n        return sc;\n    }, []);\n    if (stackBy.length === 0) {\n        return null;\n    }\n    // Has only one aggregate axis\n    var xEncQ = specQ.encodings.reduce(function (f, encQ) {\n        return f || (encQ.channel === channel_1.Channel.X ? encQ : null);\n    }, null);\n    var yEncQ = specQ.encodings.reduce(function (f, encQ) {\n        return f || (encQ.channel === channel_1.Channel.Y ? encQ : null);\n    }, null);\n    // TODO(akshatsh): Check if autoCount undef is ok\n    var xIsAggregate = (encoding_1.isFieldQuery(xEncQ) && !!xEncQ.aggregate) || (encoding_1.isAutoCountQuery(xEncQ) && !!xEncQ.autoCount);\n    var yIsAggregate = (encoding_1.isFieldQuery(yEncQ) && !!yEncQ.aggregate) || (encoding_1.isAutoCountQuery(yEncQ) && !!yEncQ.autoCount);\n    if (xIsAggregate !== yIsAggregate) {\n        return {\n            groupbyChannel: xIsAggregate ? (!!yEncQ ? channel_1.Y : null) : (!!xEncQ ? channel_1.X : null),\n            groupByEncQ: xIsAggregate ? yEncQ : xEncQ,\n            fieldChannel: xIsAggregate ? channel_1.X : channel_1.Y,\n            fieldEncQ: xIsAggregate ? xEncQ : yEncQ,\n            impute: util_1.contains(['area', 'line'], specQ.mark),\n            stackBy: stackBy,\n            offset: stacked || 'zero'\n        };\n    }\n    return null;\n}\nexports.stack = stack;\nfunction hasWildcard(specQ, opt) {\n    if (opt === void 0) { opt = {}; }\n    var exclude = opt.exclude ? util_2.toMap(opt.exclude.map(property_1.toKey)) : {};\n    if (wildcard_1.isWildcard(specQ.mark) && !exclude['mark']) {\n        return true;\n    }\n    for (var _i = 0, _a = specQ.encodings; _i < _a.length; _i++) {\n        var encQ = _a[_i];\n        // TODO: implement more efficiently, just check only properties of encQ\n        for (var key in encQ) {\n            var parentProp = key;\n            if (encQ.hasOwnProperty(parentProp) && property_1.isEncodingTopLevelProperty(parentProp)) {\n                if (wildcard_1.isWildcard(encQ[parentProp]) && !exclude[parentProp]) {\n                    return true;\n                }\n                var propObj = encQ[parentProp];\n                for (var childProp in propObj) {\n                    if (propObj.hasOwnProperty(childProp) && !util_1.contains(['enum', 'name'], childProp)) {\n                        var prop = {\n                            parent: parentProp,\n                            child: childProp\n                        };\n                        if (wildcard_1.isWildcard(propObj[childProp]) && !exclude[property_1.toKey(prop)]) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\nexports.hasWildcard = hasWildcard;\n//# sourceMappingURL=spec.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=transform.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar util_1 = require(\"../util\");\nvar encoding_1 = require(\"../query/encoding\");\nexports.name = 'aggregationQuality';\nfunction score(specM, schema, opt) {\n    var feature = aggregationQualityFeature(specM, schema, opt);\n    return {\n        score: feature.score,\n        features: [feature]\n    };\n}\nexports.score = score;\nfunction aggregationQualityFeature(specM, _, __) {\n    var encodings = specM.getEncodings();\n    if (specM.isAggregate()) {\n        var isRawContinuous = function (encQ) {\n            return encoding_1.isFieldQuery(encQ) && ((encQ.type === type_1.Type.QUANTITATIVE && !encQ.bin && !encQ.aggregate) ||\n                (encQ.type === type_1.Type.TEMPORAL && !encQ.timeUnit));\n        };\n        if (util_1.some(encodings, isRawContinuous)) {\n            // These are plots that pollute continuous fields as dimension.\n            // They are often intermediate visualizations rather than what users actually want.\n            return {\n                type: exports.name,\n                score: 0.1,\n                feature: 'Aggregate with raw continuous'\n            };\n        }\n        if (util_1.some(encodings, function (encQ) { return encoding_1.isFieldQuery(encQ) && encoding_1.isDimension(encQ); })) {\n            var hasCount = util_1.some(encodings, function (encQ) {\n                return (encoding_1.isFieldQuery(encQ) && encQ.aggregate === 'count') || encoding_1.isEnabledAutoCountQuery(encQ);\n            });\n            var hasBin = util_1.some(encodings, function (encQ) {\n                return encoding_1.isFieldQuery(encQ) && !!encQ.bin;\n            });\n            if (hasCount) {\n                // If there is count, we might add additional count field, making it a little less simple\n                // then when we just apply aggregate to Q field\n                return {\n                    type: exports.name,\n                    score: 0.8,\n                    feature: 'Aggregate with count'\n                };\n            }\n            else if (hasBin) {\n                // This is not as good as binning all the Q and show heatmap\n                return {\n                    type: exports.name,\n                    score: 0.7,\n                    feature: 'Aggregate with bin but without count'\n                };\n            }\n            else {\n                return {\n                    type: exports.name,\n                    score: 0.9,\n                    feature: 'Aggregate without count and without bin'\n                };\n            }\n        }\n        // no dimension -- often not very useful\n        return {\n            type: exports.name,\n            score: 0.3,\n            feature: 'Aggregate without dimension'\n        };\n    }\n    else {\n        if (util_1.some(encodings, function (encQ) { return encoding_1.isFieldQuery(encQ) && !encoding_1.isDimension(encQ); })) {\n            // raw plots with measure -- simplest of all!\n            return {\n                type: exports.name,\n                score: 1,\n                feature: 'Raw with measure'\n            };\n        }\n        // raw plots with no measure -- often a lot of occlusion\n        return {\n            type: exports.name,\n            score: 0.2,\n            feature: 'Raw without measure'\n        };\n    }\n}\n//# sourceMappingURL=aggregation.js.map",
    "\"use strict\";\n/**\n * Field Type (with Bin and TimeUnit) and Channel Score (Cleveland / Mackinlay based)\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar config_1 = require(\"../../config\");\nvar type_1 = require(\"./type\");\nvar base_1 = require(\"./base\");\n/**\n * Effectiveness Score for preferred axis.\n */\nvar AxisScorer = /** @class */ (function (_super) {\n    __extends(AxisScorer, _super);\n    function AxisScorer() {\n        return _super.call(this, 'Axis') || this;\n    }\n    AxisScorer.prototype.initScore = function (opt) {\n        if (opt === void 0) { opt = {}; }\n        opt = __assign({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        var score = {};\n        var preferredAxes = [{\n                feature: type_1.BIN_Q,\n                opt: 'preferredBinAxis'\n            }, {\n                feature: type_1.T,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.TIMEUNIT_T,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.TIMEUNIT_O,\n                opt: 'preferredTemporalAxis'\n            }, {\n                feature: type_1.O,\n                opt: 'preferredOrdinalAxis'\n            }, {\n                feature: type_1.N,\n                opt: 'preferredNominalAxis'\n            }];\n        preferredAxes.forEach(function (pAxis) {\n            if (opt[pAxis.opt] === channel_1.Channel.X) {\n                // penalize the other axis\n                score[pAxis.feature + '_' + channel_1.Channel.Y] = -0.01;\n            }\n            else if (opt[pAxis.opt] === channel_1.Channel.Y) {\n                // penalize the other axis\n                score[pAxis.feature + '_' + channel_1.Channel.X] = -0.01;\n            }\n        });\n        return score;\n    };\n    AxisScorer.prototype.featurize = function (type, channel) {\n        return type + '_' + channel;\n    };\n    AxisScorer.prototype.getScore = function (specM, _, __) {\n        var _this = this;\n        return specM.getEncodings().reduce(function (features, encQ) {\n            var type = type_1.getExtendedType(encQ);\n            var feature = _this.featurize(type, encQ.channel);\n            var featureScore = _this.getFeatureScore(feature);\n            if (featureScore) {\n                features.push(featureScore);\n            }\n            return features;\n        }, []);\n    };\n    return AxisScorer;\n}(base_1.Scorer));\nexports.AxisScorer = AxisScorer;\n//# sourceMappingURL=axis.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Scorer = /** @class */ (function () {\n    function Scorer(type) {\n        this.type = type;\n        this.scoreIndex = this.initScore();\n    }\n    Scorer.prototype.getFeatureScore = function (feature) {\n        var type = this.type;\n        var score = this.scoreIndex[feature];\n        if (score !== undefined) {\n            return { type: type, feature: feature, score: score };\n        }\n        return undefined;\n    };\n    return Scorer;\n}());\nexports.Scorer = Scorer;\n//# sourceMappingURL=base.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar base_1 = require(\"./base\");\nvar encoding_1 = require(\"../../query/encoding\");\n/**\n * Penalize if facet channels are the only dimensions\n */\nvar DimensionScorer = /** @class */ (function (_super) {\n    __extends(DimensionScorer, _super);\n    function DimensionScorer() {\n        return _super.call(this, 'Dimension') || this;\n    }\n    DimensionScorer.prototype.initScore = function () {\n        return {\n            row: -2,\n            column: -2,\n            color: 0,\n            opacity: 0,\n            size: 0,\n            shape: 0\n        };\n    };\n    DimensionScorer.prototype.getScore = function (specM, _, __) {\n        var _this = this;\n        if (specM.isAggregate()) {\n            specM.getEncodings().reduce(function (maxFScore, encQ) {\n                if (encoding_1.isFieldQuery(encQ) && !encQ.aggregate) {\n                    var featureScore = _this.getFeatureScore(encQ.channel + '');\n                    if (featureScore && featureScore.score > maxFScore.score) {\n                        return featureScore;\n                    }\n                }\n                return maxFScore;\n            }, { type: 'Dimension', feature: 'No Dimension', score: -5 });\n        }\n        return [];\n    };\n    return DimensionScorer;\n}(base_1.Scorer));\nexports.DimensionScorer = DimensionScorer;\n//# sourceMappingURL=dimension.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar base_1 = require(\"./base\");\nvar config_1 = require(\"../../config\");\nvar channel_1 = require(\"vega-lite/build/src/channel\");\n/**\n * Effective Score for preferred facet\n */\nvar FacetScorer = /** @class */ (function (_super) {\n    __extends(FacetScorer, _super);\n    function FacetScorer() {\n        return _super.call(this, 'Facet') || this;\n    }\n    FacetScorer.prototype.initScore = function (opt) {\n        opt = __assign({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n        var score = {};\n        if (opt.preferredFacet === channel_1.Channel.ROW) {\n            // penalize the other axis\n            score[channel_1.Channel.COLUMN] = -0.01;\n        }\n        else if (opt.preferredFacet === channel_1.Channel.COLUMN) {\n            // penalize the other axis\n            score[channel_1.Channel.ROW] = -0.01;\n        }\n        return score;\n    };\n    FacetScorer.prototype.getScore = function (specM, _, __) {\n        var _this = this;\n        return specM.getEncodings().reduce(function (features, encQ) {\n            var featureScore = _this.getFeatureScore(encQ.channel);\n            if (featureScore) {\n                features.push(featureScore);\n            }\n            return features;\n        }, []);\n    };\n    return FacetScorer;\n}(base_1.Scorer));\nexports.FacetScorer = FacetScorer;\n;\n//# sourceMappingURL=facet.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar axis_1 = require(\"./axis\");\nvar dimension_1 = require(\"./dimension\");\nvar facet_1 = require(\"./facet\");\nvar sizechannel_1 = require(\"./sizechannel\");\nvar typechannel_1 = require(\"./typechannel\");\nvar mark_1 = require(\"./mark\");\nvar SCORERS = [\n    new axis_1.AxisScorer(),\n    new dimension_1.DimensionScorer(),\n    new facet_1.FacetScorer(),\n    new mark_1.MarkScorer(),\n    new sizechannel_1.SizeChannelScorer(),\n    new typechannel_1.TypeChannelScorer()\n];\n// TODO: x/y, row/column preference\n// TODO: stacking\n// TODO: Channel, Cardinality\n// TODO: Penalize over encoding\nfunction effectiveness(specM, schema, opt) {\n    var features = SCORERS.reduce(function (f, scorer) {\n        var scores = scorer.getScore(specM, schema, opt);\n        return f.concat(scores);\n    }, []);\n    return {\n        score: features.reduce(function (s, f) {\n            return s + f.score;\n        }, 0),\n        features: features\n    };\n}\nexports.effectiveness = effectiveness;\n//# sourceMappingURL=index.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar mark_1 = require(\"vega-lite/build/src/mark\");\nvar util_1 = require(\"../../util\");\nvar type_1 = require(\"./type\");\nvar base_1 = require(\"./base\");\nvar MarkScorer = /** @class */ (function (_super) {\n    __extends(MarkScorer, _super);\n    function MarkScorer() {\n        return _super.call(this, 'Mark') || this;\n    }\n    MarkScorer.prototype.initScore = function () {\n        return init();\n    };\n    MarkScorer.prototype.getScore = function (specM, _, __) {\n        var mark = specM.getMark();\n        if (mark === mark_1.Mark.CIRCLE || mark === mark_1.Mark.SQUARE) {\n            mark = mark_1.Mark.POINT;\n        }\n        var xEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.X);\n        var xType = xEncQ ? type_1.getExtendedType(xEncQ) : type_1.NONE;\n        var yEncQ = specM.getEncodingQueryByChannel(channel_1.Channel.Y);\n        var yType = yEncQ ? type_1.getExtendedType(yEncQ) : type_1.NONE;\n        var isOccluded = !specM.isAggregate(); // FIXME\n        var feature = xType + '_' + yType + '_' + isOccluded + '_' + mark;\n        var featureScore = this.getFeatureScore(feature);\n        return [featureScore];\n    };\n    return MarkScorer;\n}(base_1.Scorer));\nexports.MarkScorer = MarkScorer;\nfunction featurize(xType, yType, hasOcclusion, mark) {\n    return xType + '_' + yType + '_' + hasOcclusion + '_' + mark;\n}\nexports.featurize = featurize;\nfunction init() {\n    var MEASURES = [type_1.Q, type_1.T];\n    var DISCRETE = [type_1.BIN_Q, type_1.TIMEUNIT_O, type_1.O, type_1.N];\n    var DISCRETE_OR_NONE = DISCRETE.concat([type_1.NONE]);\n    var SCORE = {};\n    // QxQ\n    MEASURES.forEach(function (xType) {\n        MEASURES.forEach(function (yType) {\n            // has occlusion\n            var occludedQQMark = {\n                point: 0,\n                text: -0.2,\n                tick: -0.5,\n                rect: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            util_1.forEach(occludedQQMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n            });\n            // no occlusion\n            // TODO: possible to use connected scatter plot\n            var noOccludedQQMark = {\n                point: 0,\n                text: -0.2,\n                tick: -0.5,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            util_1.forEach(noOccludedQQMark, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n            });\n        });\n    });\n    // DxQ, QxD\n    MEASURES.forEach(function (xType) {\n        // HAS OCCLUSION\n        DISCRETE_OR_NONE.forEach(function (yType) {\n            var occludedDimensionMeasureMark = {\n                tick: 0,\n                point: -0.2,\n                text: -0.5,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            util_1.forEach(occludedDimensionMeasureMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, true, mark);\n                SCORE[feature2] = score;\n            });\n        });\n        [type_1.TIMEUNIT_T].forEach(function (yType) {\n            var occludedDimensionMeasureMark = {\n                // For Time Dimension with time scale, tick is not good\n                point: 0,\n                text: -0.5,\n                tick: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            util_1.forEach(occludedDimensionMeasureMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, true, mark);\n                SCORE[feature2] = score;\n            });\n        });\n        // NO OCCLUSION\n        [type_1.NONE, type_1.N, type_1.O].forEach(function (yType) {\n            var noOccludedQxN = {\n                bar: 0,\n                point: -0.2,\n                tick: -0.25,\n                text: -0.3,\n                // Line / Area can mislead trend for N\n                line: -2,\n                area: -2,\n                // Non-sense to use rule here\n                rule: -2.5\n            };\n            util_1.forEach(noOccludedQxN, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, false, mark);\n                SCORE[feature2] = score;\n            });\n        });\n        [type_1.BIN_Q].forEach(function (yType) {\n            var noOccludedQxBinQ = {\n                bar: 0,\n                point: -0.2,\n                tick: -0.25,\n                text: -0.3,\n                // Line / Area isn't the best fit for bin\n                line: -0.5,\n                area: -0.5,\n                // Non-sense to use rule here\n                rule: -2.5\n            };\n            util_1.forEach(noOccludedQxBinQ, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, false, mark);\n                SCORE[feature2] = score;\n            });\n        });\n        [type_1.TIMEUNIT_T, type_1.TIMEUNIT_O].forEach(function (yType) {\n            // For aggregate / surely no occlusion plot, Temporal with time or ordinal\n            // are not that different.\n            var noOccludedQxBinQ = {\n                line: 0,\n                area: -0.1,\n                bar: -0.2,\n                point: -0.3,\n                tick: -0.35,\n                text: -0.4,\n                // Non-sense to use rule here\n                rule: -2.5\n            };\n            util_1.forEach(noOccludedQxBinQ, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n                // also do the inverse\n                var feature2 = featurize(yType, xType, false, mark);\n                SCORE[feature2] = score;\n            });\n        });\n    });\n    [type_1.TIMEUNIT_T].forEach(function (xType) {\n        [type_1.TIMEUNIT_T].forEach(function (yType) {\n            // has occlusion\n            var ttMark = {\n                point: 0,\n                rect: -0.1,\n                text: -0.5,\n                tick: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            // No difference between has occlusion and no occlusion\n            // as most of the time, it will be the occluded case.\n            util_1.forEach(ttMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(ttMark, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n            });\n        });\n        DISCRETE_OR_NONE.forEach(function (yType) {\n            // has occlusion\n            var tdMark = {\n                tick: 0,\n                point: -0.2,\n                text: -0.5,\n                rect: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            // No difference between has occlusion and no occlusion\n            // as most of the time, it will be the occluded case.\n            util_1.forEach(tdMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(tdMark, function (score, mark) {\n                var feature = featurize(yType, xType, true, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(tdMark, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(tdMark, function (score, mark) {\n                var feature = featurize(yType, xType, false, mark);\n                SCORE[feature] = score;\n            });\n        });\n    });\n    // DxD\n    DISCRETE_OR_NONE.forEach(function (xType) {\n        DISCRETE_OR_NONE.forEach(function (yType) {\n            // has occlusion\n            var ddMark = {\n                point: 0,\n                rect: 0,\n                text: -0.1,\n                tick: -1,\n                bar: -2,\n                line: -2,\n                area: -2,\n                rule: -2.5\n            };\n            // No difference between has occlusion and no occlusion\n            util_1.forEach(ddMark, function (score, mark) {\n                var feature = featurize(xType, yType, true, mark);\n                SCORE[feature] = score;\n            });\n            util_1.forEach(ddMark, function (score, mark) {\n                var feature = featurize(xType, yType, false, mark);\n                SCORE[feature] = score;\n            });\n        });\n    });\n    return SCORE;\n}\n//# sourceMappingURL=mark.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar base_1 = require(\"./base\");\n/**\n * Effectivenss score that penalize size for bar and tick\n */\nvar SizeChannelScorer = /** @class */ (function (_super) {\n    __extends(SizeChannelScorer, _super);\n    function SizeChannelScorer() {\n        return _super.call(this, 'SizeChannel') || this;\n    }\n    SizeChannelScorer.prototype.initScore = function () {\n        return {\n            bar_size: -2,\n            tick_size: -2\n        };\n    };\n    SizeChannelScorer.prototype.getScore = function (specM, _, __) {\n        var _this = this;\n        var mark = specM.getMark();\n        return specM.getEncodings().reduce(function (featureScores, encQ) {\n            var feature = mark + '_' + encQ.channel;\n            var featureScore = _this.getFeatureScore(feature);\n            if (featureScore) {\n                featureScores.push(featureScore);\n            }\n            return featureScores;\n        }, []);\n    };\n    return SizeChannelScorer;\n}(base_1.Scorer));\nexports.SizeChannelScorer = SizeChannelScorer;\n//# sourceMappingURL=sizechannel.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar encoding_1 = require(\"../../query/encoding\");\nvar expandedtype_1 = require(\"../../query/expandedtype\");\n/**\n * Finer grained data types that takes binning and timeUnit into account.\n */\nvar ExtendedType;\n(function (ExtendedType) {\n    ExtendedType[ExtendedType[\"Q\"] = type_1.Type.QUANTITATIVE] = \"Q\";\n    ExtendedType[ExtendedType[\"BIN_Q\"] = 'bin_' + type_1.Type.QUANTITATIVE] = \"BIN_Q\";\n    ExtendedType[ExtendedType[\"T\"] = type_1.Type.TEMPORAL] = \"T\";\n    /**\n     * Time Unit Temporal Field with time scale.\n     */\n    ExtendedType[ExtendedType[\"TIMEUNIT_T\"] = 'timeUnit_time'] = \"TIMEUNIT_T\";\n    /**\n     * Time Unit Temporal Field with ordinal scale.\n     */\n    ExtendedType[ExtendedType[\"TIMEUNIT_O\"] = 'timeUnit_' + type_1.Type.ORDINAL] = \"TIMEUNIT_O\";\n    ExtendedType[ExtendedType[\"O\"] = type_1.Type.ORDINAL] = \"O\";\n    ExtendedType[ExtendedType[\"N\"] = type_1.Type.NOMINAL] = \"N\";\n    ExtendedType[ExtendedType[\"K\"] = expandedtype_1.ExpandedType.KEY] = \"K\";\n    ExtendedType[ExtendedType[\"NONE\"] = '-'] = \"NONE\";\n})(ExtendedType = exports.ExtendedType || (exports.ExtendedType = {}));\nexports.Q = ExtendedType.Q;\nexports.BIN_Q = ExtendedType.BIN_Q;\nexports.T = ExtendedType.T;\nexports.TIMEUNIT_T = ExtendedType.TIMEUNIT_T;\nexports.TIMEUNIT_O = ExtendedType.TIMEUNIT_O;\nexports.O = ExtendedType.O;\nexports.N = ExtendedType.N;\nexports.K = ExtendedType.K;\nexports.NONE = ExtendedType.NONE;\nfunction getExtendedType(fieldQ) {\n    if (fieldQ.bin) {\n        return ExtendedType.BIN_Q;\n    }\n    else if (fieldQ.timeUnit) {\n        var sType = encoding_1.scaleType(fieldQ);\n        return scale_1.hasDiscreteDomain(sType) ? ExtendedType.TIMEUNIT_O : ExtendedType.TIMEUNIT_T;\n    }\n    return fieldQ.type;\n}\nexports.getExtendedType = getExtendedType;\n//# sourceMappingURL=type.js.map",
    "\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar shorthand_1 = require(\"../../query/shorthand\");\nvar util_1 = require(\"../../util\");\nvar type_1 = require(\"./type\");\nvar base_1 = require(\"./base\");\nexports.TERRIBLE = -10;\n/**\n * Effectiveness score for relationship between\n * Field Type (with Bin and TimeUnit) and Channel Score (Cleveland / Mackinlay based)\n */\nvar TypeChannelScorer = /** @class */ (function (_super) {\n    __extends(TypeChannelScorer, _super);\n    function TypeChannelScorer() {\n        return _super.call(this, 'TypeChannel') || this;\n    }\n    TypeChannelScorer.prototype.initScore = function () {\n        var _this = this;\n        var SCORE = {};\n        // Continuous Quantitative / Temporal Fields\n        var CONTINUOUS_TYPE_CHANNEL_SCORE = {\n            x: 0,\n            y: 0,\n            size: -0.575,\n            color: -0.725,\n            text: -2,\n            opacity: -3,\n            shape: exports.TERRIBLE,\n            row: exports.TERRIBLE,\n            column: exports.TERRIBLE,\n            detail: 2 * exports.TERRIBLE\n        };\n        [type_1.Q, type_1.T, type_1.TIMEUNIT_T].forEach(function (type) {\n            util_1.keys(CONTINUOUS_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n                SCORE[_this.featurize(type, channel)] = CONTINUOUS_TYPE_CHANNEL_SCORE[channel];\n            });\n        });\n        // Discretized Quantitative / Temporal Fields / Ordinal\n        var ORDERED_TYPE_CHANNEL_SCORE = util_1.extend({}, CONTINUOUS_TYPE_CHANNEL_SCORE, {\n            row: -0.75,\n            column: -0.75,\n            shape: -3.1,\n            text: -3.2,\n            detail: -4\n        });\n        [type_1.BIN_Q, type_1.TIMEUNIT_O, type_1.O].forEach(function (type) {\n            util_1.keys(ORDERED_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n                SCORE[_this.featurize(type, channel)] = ORDERED_TYPE_CHANNEL_SCORE[channel];\n            });\n        });\n        var NOMINAL_TYPE_CHANNEL_SCORE = {\n            x: 0,\n            y: 0,\n            color: -0.6,\n            shape: -0.65,\n            row: -0.7,\n            column: -0.7,\n            text: -0.8,\n            detail: -2,\n            size: -3,\n            opacity: -3.1,\n        };\n        util_1.keys(NOMINAL_TYPE_CHANNEL_SCORE).forEach(function (channel) {\n            SCORE[_this.featurize(type_1.N, channel)] = NOMINAL_TYPE_CHANNEL_SCORE[channel];\n        });\n        return SCORE;\n    };\n    TypeChannelScorer.prototype.featurize = function (type, channel) {\n        return type + '_' + channel;\n    };\n    TypeChannelScorer.prototype.getScore = function (specM, schema, opt) {\n        var _this = this;\n        var encodingQueryByField = specM.getEncodings().reduce(function (m, encQ) {\n            var fieldKey = shorthand_1.fieldDef(encQ);\n            (m[fieldKey] = m[fieldKey] || []).push(encQ);\n            return m;\n        }, {});\n        var features = [];\n        util_1.forEach(encodingQueryByField, function (encQs) {\n            var bestFieldFeature = encQs.reduce(function (best, encQ) {\n                var type = type_1.getExtendedType(encQ);\n                var feature = _this.featurize(type, encQ.channel);\n                var featureScore = _this.getFeatureScore(feature);\n                if (best === null || featureScore.score > best.score) {\n                    return featureScore;\n                }\n                return best;\n            }, null);\n            features.push(bestFieldFeature);\n            // TODO: add plus for over-encoding of one field\n        });\n        return features;\n    };\n    return TypeChannelScorer;\n}(base_1.Scorer));\nexports.TypeChannelScorer = TypeChannelScorer;\n//# sourceMappingURL=typechannel.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar encoding_1 = require(\"../query/encoding\");\nexports.name = 'fieldOrder';\n/**\n * Return ranking score based on indices of encoded fields in the schema.\n * If there are multiple fields, prioritize field on the lower indices of encodings.\n *\n * For example, to compare two specs with two encodings each,\n * first we compare the field on the 0-th index\n * and only compare the field on the 1-th index only if the fields on the 0-th index are the same.\n */\nfunction score(specM, schema, _) {\n    var fieldWildcardIndices = specM.wildcardIndex.encodingIndicesByProperty.get('field');\n    if (!fieldWildcardIndices) {\n        return {\n            score: 0,\n            features: []\n        };\n    }\n    var encodings = specM.specQuery.encodings;\n    var numFields = schema.fieldSchemas.length;\n    var features = [];\n    var totalScore = 0, base = 1;\n    for (var i = fieldWildcardIndices.length - 1; i >= 0; i--) {\n        var index = fieldWildcardIndices[i];\n        var encoding = encodings[index];\n        // Skip ValueQuery as we only care about order of fields.\n        var field = void 0;\n        if (encoding_1.isFieldQuery(encoding)) {\n            field = encoding.field;\n        }\n        else {\n            continue;\n        }\n        var fieldWildcard = specM.wildcardIndex.encodings[index].get('field');\n        var fieldIndex = schema.fieldSchema(field).index;\n        // reverse order field with lower index should get higher score and come first\n        var score_1 = -fieldIndex * base;\n        totalScore += score_1;\n        features.push({\n            score: score_1,\n            type: 'fieldOrder',\n            feature: \"field \" + fieldWildcard.name + \" is \" + field + \" (#\" + fieldIndex + \" in the schema)\"\n        });\n        base *= numFields;\n    }\n    return {\n        score: totalScore,\n        features: features\n    };\n}\nexports.score = score;\n//# sourceMappingURL=fieldorder.js.map",
    "\"use strict\";\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar model_1 = require(\"../model\");\nvar effectiveness_1 = require(\"./effectiveness\");\n__export(require(\"./effectiveness\"));\nexports.aggregation = require(\"./aggregation\");\nexports.fieldOrder = require(\"./fieldorder\");\n/**\n * Registry for all encoding ranking functions\n */\nvar rankingRegistry = {};\n/**\n * Add an ordering function to the registry.\n */\nfunction register(name, keyFn) {\n    rankingRegistry[name] = keyFn;\n}\nexports.register = register;\nfunction get(name) {\n    return rankingRegistry[name];\n}\nexports.get = get;\nfunction rank(group, query, schema, level) {\n    if (!query.nest || level === query.nest.length) {\n        if (query.orderBy || query.chooseBy) {\n            group.items.sort(comparatorFactory(query.orderBy || query.chooseBy, schema, query.config));\n            if (query.chooseBy) {\n                if (group.items.length > 0) {\n                    // for chooseBy -- only keep the top-item\n                    group.items.splice(1);\n                }\n            }\n        }\n    }\n    else {\n        // sort lower-level nodes first because our ranking takes top-item in the subgroup\n        group.items.forEach(function (subgroup) {\n            rank(subgroup, query, schema, level + 1);\n        });\n        if (query.nest[level].orderGroupBy) {\n            group.items.sort(groupComparatorFactory(query.nest[level].orderGroupBy, schema, query.config));\n        }\n    }\n    return group;\n}\nexports.rank = rank;\nfunction comparatorFactory(name, schema, opt) {\n    return function (m1, m2) {\n        if (name instanceof Array) {\n            return getScoreDifference(name, m1, m2, schema, opt);\n        }\n        else {\n            return getScoreDifference([name], m1, m2, schema, opt);\n        }\n    };\n}\nexports.comparatorFactory = comparatorFactory;\nfunction groupComparatorFactory(name, schema, opt) {\n    return function (g1, g2) {\n        var m1 = model_1.getTopSpecQueryItem(g1);\n        var m2 = model_1.getTopSpecQueryItem(g2);\n        if (name instanceof Array) {\n            return getScoreDifference(name, m1, m2, schema, opt);\n        }\n        else {\n            return getScoreDifference([name], m1, m2, schema, opt);\n        }\n    };\n}\nexports.groupComparatorFactory = groupComparatorFactory;\nfunction getScoreDifference(name, m1, m2, schema, opt) {\n    for (var _i = 0, name_1 = name; _i < name_1.length; _i++) {\n        var rankingName = name_1[_i];\n        var scoreDifference = getScore(m2, rankingName, schema, opt).score - getScore(m1, rankingName, schema, opt).score;\n        if (scoreDifference !== 0) {\n            return scoreDifference;\n        }\n    }\n    return 0;\n}\nfunction getScore(model, rankingName, schema, opt) {\n    if (model.getRankingScore(rankingName) !== undefined) {\n        return model.getRankingScore(rankingName);\n    }\n    var fn = get(rankingName);\n    var score = fn(model, schema, opt);\n    model.setRankingScore(rankingName, score);\n    return score;\n}\nexports.getScore = getScore;\nexports.EFFECTIVENESS = 'effectiveness';\nregister(exports.EFFECTIVENESS, effectiveness_1.effectiveness);\nregister(exports.aggregation.name, exports.aggregation.score);\nregister(exports.fieldOrder.name, exports.fieldOrder.score);\n//# sourceMappingURL=ranking.js.map",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar config_1 = require(\"./config\");\nvar generate_1 = require(\"./generate\");\nvar nest_1 = require(\"./nest\");\nvar normalize_1 = require(\"./query/normalize\");\nvar ranking_1 = require(\"./ranking/ranking\");\nfunction recommend(q, schema, config) {\n    // 1. Normalize non-nested `groupBy` to always have `groupBy` inside `nest`\n    //    and merge config with the following precedence\n    //    query.config > config > DEFAULT_QUERY_CONFIG\n    q = __assign({}, normalize_1.normalize(q), { config: __assign({}, config_1.DEFAULT_QUERY_CONFIG, config, q.config) });\n    // 2. Generate\n    var answerSet = generate_1.generate(q.spec, schema, q.config);\n    var nestedAnswerSet = nest_1.nest(answerSet, q.nest);\n    var result = ranking_1.rank(nestedAnswerSet, q, schema, 0);\n    return {\n        query: q,\n        result: result\n    };\n}\nexports.recommend = recommend;\n//# sourceMappingURL=recommend.js.map",
    "\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar bin_1 = require(\"vega-lite/build/src/bin\");\nvar timeunit_1 = require(\"vega-lite/build/src/timeunit\");\nvar stats_1 = require(\"datalib/src/stats\");\nvar type_2 = require(\"datalib/src/import/type\");\nvar dlBin = require(\"datalib/src/bins/bins\");\nvar encoding_1 = require(\"./query/encoding\");\nvar expandedtype_1 = require(\"./query/expandedtype\");\nvar config_1 = require(\"./config\");\nvar util_1 = require(\"./util\");\n/**\n * Build a Schema object.\n *\n * @param data - a set of raw data in the same format that Vega-Lite / Vega takes\n * Basically, it's an array in the form of:\n *\n * [\n *   {a: 1, b:2},\n *   {a: 2, b:3},\n *   ...\n * ]\n *\n * @return a Schema object\n */\nfunction build(data, tableSchema, opt) {\n    if (tableSchema === void 0) { tableSchema = { fields: [] }; }\n    if (opt === void 0) { opt = {}; }\n    opt = util_1.extend({}, config_1.DEFAULT_QUERY_CONFIG, opt);\n    // create profiles for each variable\n    var summaries = stats_1.summary(data);\n    var types = type_2.inferAll(data); // inferAll does stronger type inference than summary\n    var tableSchemaFieldIndex = tableSchema.fields.reduce(function (m, field) {\n        m[field.name] = field;\n        return m;\n    }, {});\n    var fieldSchemas = summaries.map(function (fieldProfile, index) {\n        var name = fieldProfile.field;\n        // In Table schema, 'date' doesn't include time so use 'datetime'\n        var type = types[name] === 'date' ? PrimitiveType.DATETIME : types[name];\n        var distinct = fieldProfile.distinct;\n        var vlType;\n        if (type === PrimitiveType.NUMBER) {\n            vlType = type_1.Type.QUANTITATIVE;\n        }\n        else if (type === PrimitiveType.INTEGER) {\n            // use ordinal or nominal when cardinality of integer type is relatively low and the distinct values are less than an amount specified in options\n            if ((distinct < opt.numberNominalLimit) && (distinct / fieldProfile.count < opt.numberNominalProportion)) {\n                vlType = type_1.Type.NOMINAL;\n            }\n            else {\n                vlType = type_1.Type.QUANTITATIVE;\n            }\n        }\n        else if (type === PrimitiveType.DATETIME) {\n            vlType = type_1.Type.TEMPORAL;\n            // need to get correct min/max of date data because datalib's summary method does not\n            // calculate this correctly for date types.\n            fieldProfile.min = new Date(data[0][name]);\n            fieldProfile.max = new Date(data[0][name]);\n            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n                var dataEntry = data_1[_i];\n                var time = new Date(dataEntry[name]).getTime();\n                if (time < fieldProfile.min.getTime()) {\n                    fieldProfile.min = new Date(time);\n                }\n                if (time > fieldProfile.max.getTime()) {\n                    fieldProfile.max = new Date(time);\n                }\n            }\n        }\n        else {\n            vlType = type_1.Type.NOMINAL;\n        }\n        if (vlType === type_1.Type.NOMINAL\n            && distinct / fieldProfile.count > opt.minPercentUniqueForKey\n            && fieldProfile.count > opt.minCardinalityForKey) {\n            vlType = expandedtype_1.ExpandedType.KEY;\n        }\n        var fieldSchema = {\n            name: name,\n            // Need to keep original index for re-exporting TableSchema\n            originalIndex: index,\n            vlType: vlType,\n            type: type,\n            stats: fieldProfile,\n            timeStats: {},\n            binStats: {}\n        };\n        // extend field schema with table schema field - if present\n        var orgFieldSchema = tableSchemaFieldIndex[fieldSchema.name];\n        fieldSchema = util_1.extend(fieldSchema, orgFieldSchema);\n        return fieldSchema;\n    });\n    // calculate preset bins for quantitative and temporal data\n    for (var _i = 0, fieldSchemas_1 = fieldSchemas; _i < fieldSchemas_1.length; _i++) {\n        var fieldSchema = fieldSchemas_1[_i];\n        if (fieldSchema.vlType === type_1.Type.QUANTITATIVE) {\n            for (var _a = 0, _b = opt.enum.binProps.maxbins; _a < _b.length; _a++) {\n                var maxbins = _b[_a];\n                fieldSchema.binStats[maxbins] = binSummary(maxbins, fieldSchema.stats);\n            }\n        }\n        else if (fieldSchema.vlType === type_1.Type.TEMPORAL) {\n            for (var _c = 0, _d = opt.enum.timeUnit; _c < _d.length; _c++) {\n                var unit = _d[_c];\n                if (unit !== undefined) {\n                    fieldSchema.timeStats[unit] = timeSummary(unit, fieldSchema.stats);\n                }\n            }\n        }\n    }\n    var derivedTableSchema = __assign({}, tableSchema, { fields: fieldSchemas });\n    return new Schema(derivedTableSchema);\n}\nexports.build = build;\n// order the field schema when we construct a new Schema\n// this orders the fields in the UI\nvar order = {\n    'nominal': 0,\n    'key': 1,\n    'ordinal': 2,\n    'temporal': 3,\n    'quantitative': 4\n};\nvar Schema = /** @class */ (function () {\n    function Schema(tableSchema) {\n        this._tableSchema = tableSchema;\n        tableSchema.fields.sort(function (a, b) {\n            // first order by vlType: nominal < temporal < quantitative < ordinal\n            if (order[a.vlType] < order[b.vlType]) {\n                return -1;\n            }\n            else if (order[a.vlType] > order[b.vlType]) {\n                return 1;\n            }\n            else {\n                // then order by field (alphabetically)\n                return a.name.localeCompare(b.name);\n            }\n        });\n        // Add index for sorting\n        tableSchema.fields.forEach(function (fieldSchema, index) { return fieldSchema.index = index; });\n        this._fieldSchemaIndex = tableSchema.fields.reduce(function (m, fieldSchema) {\n            m[fieldSchema.name] = fieldSchema;\n            return m;\n        }, {});\n    }\n    /** @return a list of the field names (for enumerating). */\n    Schema.prototype.fieldNames = function () {\n        return this._tableSchema.fields.map(function (fieldSchema) { return fieldSchema.name; });\n    };\n    Object.defineProperty(Schema.prototype, \"fieldSchemas\", {\n        /** @return a list of FieldSchemas */\n        get: function () {\n            return this._tableSchema.fields;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Schema.prototype.fieldSchema = function (fieldName) {\n        return this._fieldSchemaIndex[fieldName];\n    };\n    Schema.prototype.tableSchema = function () {\n        // the fieldschemas are re-arranged\n        // but this is not allowed in table schema.\n        // so we will re-order based on original index.\n        var tableSchema = util_1.duplicate(this._tableSchema);\n        tableSchema.fields.sort(function (a, b) { return a.originalIndex - b.originalIndex; });\n        return tableSchema;\n    };\n    /**\n     * @return primitive type of the field if exist, otherwise return null\n     */\n    Schema.prototype.primitiveType = function (fieldName) {\n        return this._fieldSchemaIndex[fieldName] ? this._fieldSchemaIndex[fieldName].type : null;\n    };\n    /**\n     * @return vlType of measturement of the field if exist, otherwise return null\n     */\n    Schema.prototype.vlType = function (fieldName) {\n        return this._fieldSchemaIndex[fieldName] ? this._fieldSchemaIndex[fieldName].vlType : null;\n    };\n    /** @return cardinality of the field associated with encQ, null if it doesn't exist.\n     *  @param augmentTimeUnitDomain - TimeUnit field domains will not be augmented if explicitly set to false.\n     */\n    Schema.prototype.cardinality = function (fieldQ, augmentTimeUnitDomain, excludeInvalid) {\n        if (augmentTimeUnitDomain === void 0) { augmentTimeUnitDomain = true; }\n        if (excludeInvalid === void 0) { excludeInvalid = false; }\n        var fieldSchema = this._fieldSchemaIndex[fieldQ.field];\n        if (fieldQ.aggregate || (encoding_1.isAutoCountQuery(fieldQ) && fieldQ.autoCount)) {\n            return 1;\n        }\n        else if (fieldQ.bin) {\n            // encQ.bin will either be a boolean or a BinQuery\n            var bin = void 0;\n            if (typeof fieldQ.bin === 'boolean') {\n                // autoMaxBins defaults to 10 if channel is Wildcard\n                bin = {\n                    maxbins: bin_1.autoMaxBins(fieldQ.channel)\n                };\n            }\n            else if (fieldQ.bin === '?') {\n                bin = {\n                    enum: [true, false]\n                };\n            }\n            else {\n                bin = fieldQ.bin;\n            }\n            var maxbins = bin.maxbins;\n            if (!fieldSchema.binStats[maxbins]) {\n                // need to calculate\n                fieldSchema.binStats[maxbins] = binSummary(maxbins, fieldSchema.stats);\n            }\n            // don't need to worry about excludeInvalid here because invalid values don't affect linearly binned field's cardinality\n            return fieldSchema.binStats[maxbins].distinct;\n        }\n        else if (fieldQ.timeUnit) {\n            if (augmentTimeUnitDomain) {\n                switch (fieldQ.timeUnit) {\n                    // TODO: this should not always be the case once Vega-Lite supports turning off domain augmenting (VL issue #1385)\n                    case timeunit_1.TimeUnit.SECONDS: return 60;\n                    case timeunit_1.TimeUnit.MINUTES: return 60;\n                    case timeunit_1.TimeUnit.HOURS: return 24;\n                    case timeunit_1.TimeUnit.DAY: return 7;\n                    case timeunit_1.TimeUnit.DATE: return 31;\n                    case timeunit_1.TimeUnit.MONTH: return 12;\n                    case timeunit_1.TimeUnit.QUARTER: return 4;\n                    case timeunit_1.TimeUnit.MILLISECONDS: return 1000;\n                }\n            }\n            var unit = fieldQ.timeUnit;\n            var timeStats = fieldSchema.timeStats;\n            // if the cardinality for the timeUnit is not cached, calculate it\n            if (!timeStats || !timeStats[unit]) {\n                timeStats = __assign({}, timeStats, (_a = {}, _a[unit] = timeSummary(fieldQ.timeUnit, fieldSchema.stats), _a));\n            }\n            if (excludeInvalid) {\n                return timeStats[unit].distinct - invalidCount(timeStats[unit].unique, ['Invalid Date', null]);\n            }\n            else {\n                return timeStats[unit].distinct;\n            }\n        }\n        else {\n            if (fieldSchema) {\n                if (excludeInvalid) {\n                    return fieldSchema.stats.distinct - invalidCount(fieldSchema.stats.unique, [NaN, null]);\n                }\n                else {\n                    return fieldSchema.stats.distinct;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        var _a;\n    };\n    /**\n     * Given an EncodingQuery with a timeUnit, returns true if the date field\n     * has multiple distinct values for all parts of the timeUnit. Returns undefined\n     * if the timeUnit is undefined.\n     * i.e.\n     * ('yearmonth', [Jan 1 2000, Feb 2 2000] returns false)\n     * ('yearmonth', [Jan 1 2000, Feb 2 2001] returns true)\n     */\n    Schema.prototype.timeUnitHasVariation = function (fieldQ) {\n        if (!fieldQ.timeUnit) {\n            return;\n        }\n        // if there is no variation in `date`, there should not be variation in `day`\n        if (fieldQ.timeUnit === timeunit_1.TimeUnit.DAY) {\n            var dateEncQ = util_1.extend({}, fieldQ, { timeUnit: timeunit_1.TimeUnit.DATE });\n            if (this.cardinality(dateEncQ, false, true) <= 1) {\n                return false;\n            }\n        }\n        var fullTimeUnit = fieldQ.timeUnit;\n        for (var _i = 0, TIMEUNIT_PARTS_1 = timeunit_1.TIMEUNIT_PARTS; _i < TIMEUNIT_PARTS_1.length; _i++) {\n            var timeUnitPart = TIMEUNIT_PARTS_1[_i];\n            if (timeunit_1.containsTimeUnit(fullTimeUnit, timeUnitPart)) {\n                // Create a clone of encQ, but with singleTimeUnit\n                var singleUnitEncQ = util_1.extend({}, fieldQ, { timeUnit: timeUnitPart });\n                if (this.cardinality(singleUnitEncQ, false, true) <= 1) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    Schema.prototype.domain = function (fieldQueryParts) {\n        // TODO: differentiate for field with bin / timeUnit\n        var fieldSchema = this._fieldSchemaIndex[fieldQueryParts.field];\n        var domain = util_1.keys(fieldSchema.stats.unique);\n        if (fieldSchema.vlType === type_1.Type.QUANTITATIVE) {\n            // return [min, max], coerced into number types\n            return [+fieldSchema.stats.min, +fieldSchema.stats.max];\n        }\n        else if (fieldSchema.type === PrimitiveType.DATETIME) {\n            // return [min, max] dates\n            return [fieldSchema.stats.min, fieldSchema.stats.max];\n        }\n        else if (fieldSchema.type === PrimitiveType.INTEGER ||\n            fieldSchema.type === PrimitiveType.NUMBER) {\n            // coerce non-quantitative numerical data into number type\n            domain = domain.map(function (x) { return +x; });\n            return domain.sort(util_1.cmp);\n        }\n        else if ((fieldSchema.vlType === type_1.Type.ORDINAL) && fieldSchema.ordinalDomain) {\n            return fieldSchema.ordinalDomain;\n        }\n        return domain.map(function (x) {\n            // Convert 'null' to null as it is encoded similarly in datalib.\n            // This is wrong when it is a string 'null' but that rarely happens.\n            return x === 'null' ? null : x;\n        }).sort(util_1.cmp);\n    };\n    /**\n     * @return a Summary corresponding to the field of the given EncodingQuery\n     */\n    Schema.prototype.stats = function (fieldQ) {\n        // TODO: differentiate for field with bin / timeUnit vs without\n        var fieldSchema = this._fieldSchemaIndex[fieldQ.field];\n        return fieldSchema ? fieldSchema.stats : null;\n    };\n    return Schema;\n}());\nexports.Schema = Schema;\n/**\n * @return a summary of the binning scheme determined from the given max number of bins\n */\nfunction binSummary(maxbins, summary) {\n    var bin = dlBin({\n        min: summary.min,\n        max: summary.max,\n        maxbins: maxbins\n    });\n    // start with summary, pre-binning\n    var result = util_1.extend({}, summary);\n    result.unique = binUnique(bin, summary.unique);\n    result.distinct = (bin.stop - bin.start) / bin.step;\n    result.min = bin.start;\n    result.max = bin.stop;\n    return result;\n}\n/** @return a modified version of the passed summary with unique and distinct set according to the timeunit.\n *  Maps 'null' (string) keys to the null value and invalid dates to 'Invalid Date' in the unique dictionary.\n */\nfunction timeSummary(timeunit, summary) {\n    var result = util_1.extend({}, summary);\n    var unique = {};\n    util_1.keys(summary.unique).forEach(function (dateString) {\n        // don't convert null value because the Date constructor will actually convert it to a date\n        var date = (dateString === 'null') ? null : new Date(dateString);\n        // at this point, `date` is either the null value, a valid Date object, or \"Invalid Date\" which is a Date\n        var key;\n        if (date === null) {\n            key = null;\n        }\n        else if (isNaN(date.getTime())) {\n            key = 'Invalid Date';\n        }\n        else {\n            key = ((timeunit === timeunit_1.TimeUnit.DAY) ? date.getDay() : timeunit_1.convert(timeunit, date)).toString();\n        }\n        unique[key] = (unique[key] || 0) + summary.unique[dateString];\n    });\n    result.unique = unique;\n    result.distinct = util_1.keys(unique).length;\n    return result;\n}\n/**\n * @return a new unique object based off of the old unique count and a binning scheme\n */\nfunction binUnique(bin, oldUnique) {\n    var newUnique = {};\n    for (var value in oldUnique) {\n        var bucket = void 0;\n        if (value === null) {\n            bucket = null;\n        }\n        else if (isNaN(Number(value))) {\n            bucket = NaN;\n        }\n        else {\n            bucket = bin.value(Number(value));\n        }\n        newUnique[bucket] = (newUnique[bucket] || 0) + oldUnique[value];\n    }\n    return newUnique;\n}\n/** @return the number of items in list that occur as keys of unique */\nfunction invalidCount(unique, list) {\n    return list.reduce(function (prev, cur) {\n        return unique[cur] ? prev + 1 : prev;\n    }, 0);\n}\nvar PrimitiveType;\n(function (PrimitiveType) {\n    PrimitiveType[PrimitiveType[\"STRING\"] = 'string'] = \"STRING\";\n    PrimitiveType[PrimitiveType[\"NUMBER\"] = 'number'] = \"NUMBER\";\n    PrimitiveType[PrimitiveType[\"INTEGER\"] = 'integer'] = \"INTEGER\";\n    PrimitiveType[PrimitiveType[\"BOOLEAN\"] = 'boolean'] = \"BOOLEAN\";\n    PrimitiveType[PrimitiveType[\"DATETIME\"] = 'datetime'] = \"DATETIME\";\n})(PrimitiveType = exports.PrimitiveType || (exports.PrimitiveType = {}));\n//# sourceMappingURL=schema.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nvar encoding_1 = require(\"./query/encoding\");\nvar expandedtype_1 = require(\"./query/expandedtype\");\nfunction stylize(answerSet, schema, opt) {\n    var encQIndex = {};\n    answerSet = answerSet.map(function (specM) {\n        if (opt.smallRangeStepForHighCardinalityOrFacet) {\n            specM = smallRangeStepForHighCardinalityOrFacet(specM, schema, encQIndex, opt);\n        }\n        if (opt.nominalColorScaleForHighCardinality) {\n            specM = nominalColorScaleForHighCardinality(specM, schema, encQIndex, opt);\n        }\n        if (opt.xAxisOnTopForHighYCardinalityWithoutColumn) {\n            specM = xAxisOnTopForHighYCardinalityWithoutColumn(specM, schema, encQIndex, opt);\n        }\n        return specM;\n    });\n    return answerSet;\n}\nexports.stylize = stylize;\nfunction smallRangeStepForHighCardinalityOrFacet(specM, schema, encQIndex, opt) {\n    [channel_1.Channel.ROW, channel_1.Channel.Y, channel_1.Channel.COLUMN, channel_1.Channel.X].forEach(function (channel) {\n        encQIndex[channel] = specM.getEncodingQueryByChannel(channel);\n    });\n    var yEncQ = encQIndex[channel_1.Channel.Y];\n    if (yEncQ !== undefined && encoding_1.isFieldQuery(yEncQ)) {\n        if (encQIndex[channel_1.Channel.ROW] ||\n            schema.cardinality(yEncQ) > opt.smallRangeStepForHighCardinalityOrFacet.maxCardinality) {\n            // We check for undefined rather than\n            // yEncQ.scale = yEncQ.scale || {} to cover the case where\n            // yEncQ.scale has been set to false/null.\n            // This prevents us from incorrectly overriding scale and\n            // assigning a rangeStep when scale is set to false.\n            if (yEncQ.scale === undefined) {\n                yEncQ.scale = {};\n            }\n            // We do not want to assign a rangeStep if scale is set to false\n            // and we only apply this if the scale is (or can be) an ordinal scale.\n            var yScaleType = encoding_1.scaleType(yEncQ);\n            if (yEncQ.scale && (yScaleType === undefined || scale_1.hasDiscreteDomain(yScaleType))) {\n                if (!yEncQ.scale.rangeStep) {\n                    yEncQ.scale.rangeStep = 12;\n                }\n            }\n        }\n    }\n    var xEncQ = encQIndex[channel_1.Channel.X];\n    if (encoding_1.isFieldQuery(xEncQ)) {\n        if (encQIndex[channel_1.Channel.COLUMN] ||\n            schema.cardinality(xEncQ) > opt.smallRangeStepForHighCardinalityOrFacet.maxCardinality) {\n            // Just like y, we don't want to do this if scale is null/false\n            if (xEncQ.scale === undefined) {\n                xEncQ.scale = {};\n            }\n            // We do not want to assign a rangeStep if scale is set to false\n            // and we only apply this if the scale is (or can be) an ordinal scale.\n            var xScaleType = encoding_1.scaleType(xEncQ);\n            if (xEncQ.scale && (xScaleType === undefined || scale_1.hasDiscreteDomain(xScaleType))) {\n                if (!xEncQ.scale.rangeStep) {\n                    xEncQ.scale.rangeStep = 12;\n                }\n            }\n        }\n    }\n    return specM;\n}\nexports.smallRangeStepForHighCardinalityOrFacet = smallRangeStepForHighCardinalityOrFacet;\nfunction nominalColorScaleForHighCardinality(specM, schema, encQIndex, opt) {\n    encQIndex[channel_1.Channel.COLOR] = specM.getEncodingQueryByChannel(channel_1.Channel.COLOR);\n    var colorEncQ = encQIndex[channel_1.Channel.COLOR];\n    if (encoding_1.isFieldQuery(colorEncQ) && (colorEncQ !== undefined) && (colorEncQ.type === type_1.Type.NOMINAL || colorEncQ.type === expandedtype_1.ExpandedType.KEY) &&\n        (schema.cardinality(colorEncQ) > opt.nominalColorScaleForHighCardinality.maxCardinality)) {\n        if (colorEncQ.scale === undefined) {\n            colorEncQ.scale = {};\n        }\n        if (colorEncQ.scale) {\n            if (!colorEncQ.scale.range) {\n                colorEncQ.scale.scheme = opt.nominalColorScaleForHighCardinality.palette;\n            }\n        }\n    }\n    return specM;\n}\nexports.nominalColorScaleForHighCardinality = nominalColorScaleForHighCardinality;\nfunction xAxisOnTopForHighYCardinalityWithoutColumn(specM, schema, encQIndex, opt) {\n    [channel_1.Channel.COLUMN, channel_1.Channel.X, channel_1.Channel.Y].forEach(function (channel) {\n        encQIndex[channel] = specM.getEncodingQueryByChannel(channel);\n    });\n    if (encQIndex[channel_1.Channel.COLUMN] === undefined) {\n        var xEncQ = encQIndex[channel_1.Channel.X];\n        var yEncQ = encQIndex[channel_1.Channel.Y];\n        if (encoding_1.isFieldQuery(xEncQ) && encoding_1.isFieldQuery(yEncQ) && yEncQ !== undefined && yEncQ.field && scale_1.hasDiscreteDomain(encoding_1.scaleType(yEncQ))) {\n            if (xEncQ !== undefined) {\n                if (schema.cardinality(yEncQ) > opt.xAxisOnTopForHighYCardinalityWithoutColumn.maxCardinality) {\n                    if (xEncQ.axis === undefined) {\n                        xEncQ.axis = {};\n                    }\n                    if (xEncQ.axis && !xEncQ.axis.orient) {\n                        xEncQ.axis.orient = 'top';\n                    }\n                }\n            }\n        }\n    }\n    return specM;\n}\nexports.xAxisOnTopForHighYCardinalityWithoutColumn = xAxisOnTopForHighYCardinalityWithoutColumn;\n//# sourceMappingURL=stylize.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"datalib/src/util\");\nvar util_2 = require(\"datalib/src/util\");\nexports.cmp = util_2.cmp;\nexports.keys = util_2.keys;\nexports.duplicate = util_2.duplicate;\nexports.extend = util_2.extend;\nexports.isObject = util_2.isObject;\nexports.isArray = util_2.isArray;\nexports.isBoolean = util_2.isBoolean;\nexports.toMap = util_2.toMap;\nfunction contains(array, item) {\n    return array.indexOf(item) !== -1;\n}\nexports.contains = contains;\n;\nfunction every(arr, f) {\n    for (var i = 0; i < arr.length; i++) {\n        if (!f(arr[i], i)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.every = every;\n;\nfunction forEach(obj, f, thisArg) {\n    if (obj.forEach) {\n        obj.forEach.call(thisArg, f);\n    }\n    else {\n        for (var k in obj) {\n            f.call(thisArg, obj[k], k, obj);\n        }\n    }\n}\nexports.forEach = forEach;\n;\nfunction some(arr, f) {\n    var i = 0, k;\n    for (k in arr) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.some = some;\n;\nfunction nestedMap(array, f) {\n    return array.map(function (a) {\n        if (util_1.isArray(a)) {\n            return nestedMap(a, f);\n        }\n        return f(a);\n    });\n}\nexports.nestedMap = nestedMap;\n/** Returns the array without the elements in item */\nfunction without(array, excludedItems) {\n    return array.filter(function (item) {\n        return !contains(excludedItems, item);\n    });\n}\nexports.without = without;\n//# sourceMappingURL=util.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar property_1 = require(\"./property\");\nvar util_1 = require(\"./util\");\nvar axis_1 = require(\"vega-lite/build/src/axis\");\nvar channel_1 = require(\"vega-lite/build/src/channel\");\nvar mark_1 = require(\"vega-lite/build/src/mark\");\nvar scale_1 = require(\"vega-lite/build/src/scale\");\nvar legend_1 = require(\"vega-lite/build/src/legend\");\nvar timeunit_1 = require(\"vega-lite/build/src/timeunit\");\nvar type_1 = require(\"vega-lite/build/src/type\");\nexports.SHORT_WILDCARD = '?';\nfunction isWildcard(prop) {\n    return isShortWildcard(prop) || isWildcardDef(prop);\n}\nexports.isWildcard = isWildcard;\nfunction isShortWildcard(prop) {\n    return prop === exports.SHORT_WILDCARD;\n}\nexports.isShortWildcard = isShortWildcard;\nfunction isWildcardDef(prop) {\n    return prop !== undefined && (!!prop.enum || !!prop.name) && !util_1.isArray(prop);\n}\nexports.isWildcardDef = isWildcardDef;\nfunction initWildcard(prop, defaultName, defaultEnumValues) {\n    return util_1.extend({}, {\n        name: defaultName,\n        enum: defaultEnumValues\n    }, prop === exports.SHORT_WILDCARD ? {} : prop);\n}\nexports.initWildcard = initWildcard;\n/**\n * Initial short names from list of full camelCaseNames.\n * For each camelCaseNames, return unique short names based on initial (e.g., `ccn`)\n */\nfunction initNestedPropName(fullNames) {\n    var index = {};\n    var has = {};\n    var _loop_1 = function (fullName) {\n        var initialIndices = [0];\n        for (var i = 0; i < fullName.length; i++) {\n            if (fullName.charAt(i).toUpperCase() === fullName.charAt(i)) {\n                initialIndices.push(i);\n            }\n        }\n        var shortName = initialIndices.map(function (i) { return fullName.charAt(i); }).join('').toLowerCase();\n        if (!has[shortName]) {\n            index[fullName] = shortName;\n            has[shortName] = true;\n            return \"continue\";\n        }\n        // If duplicate, add last character and try again!\n        if (initialIndices[initialIndices.length - 1] !== fullName.length - 1) {\n            shortName = initialIndices.concat([fullName.length - 1]).map(function (i) { return fullName.charAt(i); }).join('').toLowerCase();\n            if (!has[shortName]) {\n                index[fullName] = shortName;\n                has[shortName] = true;\n                return \"continue\";\n            }\n        }\n        for (var i = 1; !index[fullName]; i++) {\n            var shortNameWithNo = shortName + '_' + i;\n            if (!has[shortNameWithNo]) {\n                index[fullName] = shortNameWithNo;\n                has[shortNameWithNo] = true;\n                break;\n            }\n        }\n    };\n    for (var _i = 0, fullNames_1 = fullNames; _i < fullNames_1.length; _i++) {\n        var fullName = fullNames_1[_i];\n        _loop_1(fullName);\n    }\n    return index;\n}\nexports.DEFAULT_NAME = {\n    mark: 'm',\n    channel: 'c',\n    aggregate: 'a',\n    autoCount: '#',\n    hasFn: 'h',\n    bin: 'b',\n    sort: 'so',\n    scale: 's',\n    axis: 'ax',\n    legend: 'l',\n    timeUnit: 'tu',\n    field: 'f',\n    type: 't',\n    binProps: {\n        maxbins: 'mb',\n        min: 'mi',\n        max: 'ma',\n        base: 'b',\n        step: 's',\n        steps: 'ss',\n        minstep: 'ms',\n        divide: 'd'\n    },\n    sortProps: {\n        field: 'f',\n        op: 'o',\n        order: 'or'\n    },\n    scaleProps: initNestedPropName(scale_1.SCALE_PROPERTIES),\n    axisProps: initNestedPropName(axis_1.AXIS_PROPERTIES),\n    legendProps: initNestedPropName(legend_1.LEGEND_PROPERTIES)\n};\nfunction getDefaultName(prop) {\n    if (property_1.isEncodingNestedProp(prop)) {\n        return exports.DEFAULT_NAME[prop.parent] + '-' + exports.DEFAULT_NAME[prop.parent + 'Props'][prop.child];\n    }\n    if (exports.DEFAULT_NAME[prop]) {\n        return exports.DEFAULT_NAME[prop];\n    }\n    /* istanbul ignore next */\n    throw new Error('Default name undefined for ' + prop);\n}\nexports.getDefaultName = getDefaultName;\nvar DEFAULT_BOOLEAN_ENUM = [false, true];\nvar DEFAULT_BIN_PROPS_ENUM = {\n    maxbins: [5, 10, 20],\n    extent: [undefined],\n    base: [10],\n    step: [undefined],\n    steps: [undefined],\n    minstep: [undefined],\n    divide: [[5, 2]]\n};\nvar DEFAULT_SORT_PROPS = {\n    field: [undefined],\n    op: ['min', 'mean'],\n    order: ['ascending', 'descending']\n};\nvar DEFAULT_SCALE_PROPS_ENUM = {\n    type: [undefined, scale_1.ScaleType.LOG],\n    domain: [undefined],\n    base: [undefined],\n    exponent: [1, 2],\n    clamp: DEFAULT_BOOLEAN_ENUM,\n    nice: DEFAULT_BOOLEAN_ENUM,\n    reverse: DEFAULT_BOOLEAN_ENUM,\n    round: DEFAULT_BOOLEAN_ENUM,\n    zero: DEFAULT_BOOLEAN_ENUM,\n    padding: [undefined],\n    paddingInner: [undefined],\n    paddingOuter: [undefined],\n    interpolate: [undefined],\n    range: [undefined],\n    rangeStep: [17, 21],\n    scheme: [undefined],\n};\nvar DEFAULT_AXIS_PROPS_ENUM = {\n    zindex: [1, 0],\n    offset: [undefined],\n    orient: [undefined],\n    values: [undefined],\n    domain: DEFAULT_BOOLEAN_ENUM,\n    grid: DEFAULT_BOOLEAN_ENUM,\n    format: [undefined],\n    labels: DEFAULT_BOOLEAN_ENUM,\n    labelAngle: [undefined],\n    labelOverlap: [undefined],\n    labelPadding: [undefined],\n    maxExtent: [undefined],\n    minExtent: [undefined],\n    position: [undefined],\n    ticks: DEFAULT_BOOLEAN_ENUM,\n    tickCount: [undefined],\n    tickSize: [undefined],\n    title: [undefined],\n    titleMaxLength: [undefined],\n    titlePadding: [undefined]\n};\nvar DEFAULT_LEGEND_PROPS_ENUM = {\n    entryPadding: [undefined],\n    orient: ['left', 'right'],\n    offset: [undefined],\n    format: [undefined],\n    values: [undefined],\n    tickCount: [undefined],\n    title: [undefined],\n    type: [undefined],\n    zindex: [undefined]\n};\n// Use FullEnumIndex to make sure we have all properties specified here!\nexports.DEFAULT_ENUM_INDEX = {\n    mark: [mark_1.Mark.POINT, mark_1.Mark.BAR, mark_1.Mark.LINE, mark_1.Mark.AREA, mark_1.Mark.TICK, mark_1.Mark.TEXT],\n    channel: [channel_1.X, channel_1.Y, channel_1.ROW, channel_1.COLUMN, channel_1.SIZE, channel_1.COLOR],\n    aggregate: [undefined, 'mean'],\n    autoCount: DEFAULT_BOOLEAN_ENUM,\n    bin: DEFAULT_BOOLEAN_ENUM,\n    hasFn: DEFAULT_BOOLEAN_ENUM,\n    timeUnit: [undefined, timeunit_1.TimeUnit.YEAR, timeunit_1.TimeUnit.MONTH, timeunit_1.TimeUnit.MINUTES, timeunit_1.TimeUnit.SECONDS],\n    field: [undefined],\n    type: [type_1.Type.NOMINAL, type_1.Type.ORDINAL, type_1.Type.QUANTITATIVE, type_1.Type.TEMPORAL],\n    sort: ['ascending', 'descending'],\n    scale: [true],\n    axis: DEFAULT_BOOLEAN_ENUM,\n    legend: DEFAULT_BOOLEAN_ENUM,\n    binProps: DEFAULT_BIN_PROPS_ENUM,\n    sortProps: DEFAULT_SORT_PROPS,\n    scaleProps: DEFAULT_SCALE_PROPS_ENUM,\n    axisProps: DEFAULT_AXIS_PROPS_ENUM,\n    legendProps: DEFAULT_LEGEND_PROPS_ENUM\n};\n// TODO: rename this to getDefaultEnum\nfunction getDefaultEnumValues(prop, schema, opt) {\n    if (prop === 'field' || (property_1.isEncodingNestedProp(prop) && prop.parent === 'sort' && prop.child === 'field')) {\n        // For field, by default enumerate all fields\n        return schema.fieldNames();\n    }\n    var val;\n    if (property_1.isEncodingNestedProp(prop)) {\n        val = opt.enum[prop.parent + 'Props'][prop.child];\n    }\n    else {\n        val = opt.enum[prop];\n    }\n    if (val !== undefined) {\n        return val;\n    }\n    /* istanbul ignore next */\n    throw new Error('No default enumValues for ' + JSON.stringify(prop));\n}\nexports.getDefaultEnumValues = getDefaultEnumValues;\n//# sourceMappingURL=wildcard.js.map",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar property_1 = require(\"./property\");\nvar propindex_1 = require(\"./propindex\");\nvar WildcardIndex = /** @class */ (function () {\n    function WildcardIndex() {\n        this._mark = undefined;\n        this._encodings = {};\n        this._encodingIndicesByProperty = new propindex_1.PropIndex();\n    }\n    WildcardIndex.prototype.setEncodingProperty = function (index, prop, wildcard) {\n        var encodingsIndex = this._encodings;\n        // Init encoding index and set prop\n        var encIndex = encodingsIndex[index] = encodingsIndex[index] || new propindex_1.PropIndex();\n        encIndex.set(prop, wildcard);\n        // Initialize indicesByProperty[prop] and add index\n        var indicesByProp = this._encodingIndicesByProperty;\n        indicesByProp.set(prop, (indicesByProp.get(prop) || []));\n        indicesByProp.get(prop).push(index);\n        return this;\n    };\n    WildcardIndex.prototype.hasEncodingProperty = function (index, prop) {\n        return !!this._encodings[index] && this._encodings[index].has(prop);\n    };\n    WildcardIndex.prototype.hasProperty = function (prop) {\n        if (property_1.isEncodingProperty(prop)) {\n            return this.encodingIndicesByProperty.has(prop);\n        }\n        if (prop === 'mark') {\n            return !!this.mark;\n        }\n        /* istanbul ignore next */\n        throw new Error('Unimplemented for property ' + prop);\n    };\n    WildcardIndex.prototype.isEmpty = function () {\n        return !this.mark && this.encodingIndicesByProperty.size() === 0;\n    };\n    WildcardIndex.prototype.setMark = function (mark) {\n        this._mark = mark;\n        return this;\n    };\n    Object.defineProperty(WildcardIndex.prototype, \"mark\", {\n        get: function () {\n            return this._mark;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WildcardIndex.prototype, \"encodings\", {\n        get: function () {\n            return this._encodings;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(WildcardIndex.prototype, \"encodingIndicesByProperty\", {\n        get: function () {\n            return this._encodingIndicesByProperty;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    return WildcardIndex;\n}());\nexports.WildcardIndex = WildcardIndex;\n//# sourceMappingURL=wildcardindex.js.map",
    "",
    "(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define('d3-time', ['exports'], factory) :\n  factory((global.d3_time = {}));\n}(this, function (exports) { 'use strict';\n\n  var t0 = new Date;\n  var t1 = new Date;\n  function newInterval(floori, offseti, count, field) {\n\n    function interval(date) {\n      return floori(date = new Date(+date)), date;\n    }\n\n    interval.floor = interval;\n\n    interval.round = function(date) {\n      var d0 = new Date(+date),\n          d1 = new Date(date - 1);\n      floori(d0), floori(d1), offseti(d1, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    };\n\n    interval.ceil = function(date) {\n      return floori(date = new Date(date - 1)), offseti(date, 1), date;\n    };\n\n    interval.offset = function(date, step) {\n      return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;\n    };\n\n    interval.range = function(start, stop, step) {\n      var range = [];\n      start = new Date(start - 1);\n      stop = new Date(+stop);\n      step = step == null ? 1 : Math.floor(step);\n      if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date\n      offseti(start, 1), floori(start);\n      if (start < stop) range.push(new Date(+start));\n      while (offseti(start, step), floori(start), start < stop) range.push(new Date(+start));\n      return range;\n    };\n\n    interval.filter = function(test) {\n      return newInterval(function(date) {\n        while (floori(date), !test(date)) date.setTime(date - 1);\n      }, function(date, step) {\n        while (--step >= 0) while (offseti(date, 1), !test(date));\n      });\n    };\n\n    if (count) {\n      interval.count = function(start, end) {\n        t0.setTime(+start), t1.setTime(+end);\n        floori(t0), floori(t1);\n        return Math.floor(count(t0, t1));\n      };\n\n      interval.every = function(step) {\n        step = Math.floor(step);\n        return !isFinite(step) || !(step > 0) ? null\n            : !(step > 1) ? interval\n            : interval.filter(field\n                ? function(d) { return field(d) % step === 0; }\n                : function(d) { return interval.count(0, d) % step === 0; });\n      };\n    }\n\n    return interval;\n  };\n\n  var millisecond = newInterval(function() {\n    // noop\n  }, function(date, step) {\n    date.setTime(+date + step);\n  }, function(start, end) {\n    return end - start;\n  });\n\n  // An optimized implementation for this simple case.\n  millisecond.every = function(k) {\n    k = Math.floor(k);\n    if (!isFinite(k) || !(k > 0)) return null;\n    if (!(k > 1)) return millisecond;\n    return newInterval(function(date) {\n      date.setTime(Math.floor(date / k) * k);\n    }, function(date, step) {\n      date.setTime(+date + step * k);\n    }, function(start, end) {\n      return (end - start) / k;\n    });\n  };\n\n  var second = newInterval(function(date) {\n    date.setMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getSeconds();\n  });\n\n  var minute = newInterval(function(date) {\n    date.setSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getMinutes();\n  });\n\n  var hour = newInterval(function(date) {\n    date.setMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getHours();\n  });\n\n  var day = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setDate(date.getDate() + step);\n  }, function(start, end) {\n    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 864e5;\n  }, function(date) {\n    return date.getDate() - 1;\n  });\n\n  function weekday(i) {\n    return newInterval(function(date) {\n      date.setHours(0, 0, 0, 0);\n      date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setDate(date.getDate() + step * 7);\n    }, function(start, end) {\n      return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * 6e4) / 6048e5;\n    });\n  }\n\n  var sunday = weekday(0);\n  var monday = weekday(1);\n  var tuesday = weekday(2);\n  var wednesday = weekday(3);\n  var thursday = weekday(4);\n  var friday = weekday(5);\n  var saturday = weekday(6);\n\n  var month = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setDate(1);\n  }, function(date, step) {\n    date.setMonth(date.getMonth() + step);\n  }, function(start, end) {\n    return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;\n  }, function(date) {\n    return date.getMonth();\n  });\n\n  var year = newInterval(function(date) {\n    date.setHours(0, 0, 0, 0);\n    date.setMonth(0, 1);\n  }, function(date, step) {\n    date.setFullYear(date.getFullYear() + step);\n  }, function(start, end) {\n    return end.getFullYear() - start.getFullYear();\n  }, function(date) {\n    return date.getFullYear();\n  });\n\n  var utcSecond = newInterval(function(date) {\n    date.setUTCMilliseconds(0);\n  }, function(date, step) {\n    date.setTime(+date + step * 1e3);\n  }, function(start, end) {\n    return (end - start) / 1e3;\n  }, function(date) {\n    return date.getUTCSeconds();\n  });\n\n  var utcMinute = newInterval(function(date) {\n    date.setUTCSeconds(0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 6e4);\n  }, function(start, end) {\n    return (end - start) / 6e4;\n  }, function(date) {\n    return date.getUTCMinutes();\n  });\n\n  var utcHour = newInterval(function(date) {\n    date.setUTCMinutes(0, 0, 0);\n  }, function(date, step) {\n    date.setTime(+date + step * 36e5);\n  }, function(start, end) {\n    return (end - start) / 36e5;\n  }, function(date) {\n    return date.getUTCHours();\n  });\n\n  var utcDay = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n  }, function(date, step) {\n    date.setUTCDate(date.getUTCDate() + step);\n  }, function(start, end) {\n    return (end - start) / 864e5;\n  }, function(date) {\n    return date.getUTCDate() - 1;\n  });\n\n  function utcWeekday(i) {\n    return newInterval(function(date) {\n      date.setUTCHours(0, 0, 0, 0);\n      date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);\n    }, function(date, step) {\n      date.setUTCDate(date.getUTCDate() + step * 7);\n    }, function(start, end) {\n      return (end - start) / 6048e5;\n    });\n  }\n\n  var utcSunday = utcWeekday(0);\n  var utcMonday = utcWeekday(1);\n  var utcTuesday = utcWeekday(2);\n  var utcWednesday = utcWeekday(3);\n  var utcThursday = utcWeekday(4);\n  var utcFriday = utcWeekday(5);\n  var utcSaturday = utcWeekday(6);\n\n  var utcMonth = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCDate(1);\n  }, function(date, step) {\n    date.setUTCMonth(date.getUTCMonth() + step);\n  }, function(start, end) {\n    return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;\n  }, function(date) {\n    return date.getUTCMonth();\n  });\n\n  var utcYear = newInterval(function(date) {\n    date.setUTCHours(0, 0, 0, 0);\n    date.setUTCMonth(0, 1);\n  }, function(date, step) {\n    date.setUTCFullYear(date.getUTCFullYear() + step);\n  }, function(start, end) {\n    return end.getUTCFullYear() - start.getUTCFullYear();\n  }, function(date) {\n    return date.getUTCFullYear();\n  });\n\n  var milliseconds = millisecond.range;\n  var seconds = second.range;\n  var minutes = minute.range;\n  var hours = hour.range;\n  var days = day.range;\n  var sundays = sunday.range;\n  var mondays = monday.range;\n  var tuesdays = tuesday.range;\n  var wednesdays = wednesday.range;\n  var thursdays = thursday.range;\n  var fridays = friday.range;\n  var saturdays = saturday.range;\n  var weeks = sunday.range;\n  var months = month.range;\n  var years = year.range;\n\n  var utcMillisecond = millisecond;\n  var utcMilliseconds = milliseconds;\n  var utcSeconds = utcSecond.range;\n  var utcMinutes = utcMinute.range;\n  var utcHours = utcHour.range;\n  var utcDays = utcDay.range;\n  var utcSundays = utcSunday.range;\n  var utcMondays = utcMonday.range;\n  var utcTuesdays = utcTuesday.range;\n  var utcWednesdays = utcWednesday.range;\n  var utcThursdays = utcThursday.range;\n  var utcFridays = utcFriday.range;\n  var utcSaturdays = utcSaturday.range;\n  var utcWeeks = utcSunday.range;\n  var utcMonths = utcMonth.range;\n  var utcYears = utcYear.range;\n\n  var version = \"0.1.1\";\n\n  exports.version = version;\n  exports.milliseconds = milliseconds;\n  exports.seconds = seconds;\n  exports.minutes = minutes;\n  exports.hours = hours;\n  exports.days = days;\n  exports.sundays = sundays;\n  exports.mondays = mondays;\n  exports.tuesdays = tuesdays;\n  exports.wednesdays = wednesdays;\n  exports.thursdays = thursdays;\n  exports.fridays = fridays;\n  exports.saturdays = saturdays;\n  exports.weeks = weeks;\n  exports.months = months;\n  exports.years = years;\n  exports.utcMillisecond = utcMillisecond;\n  exports.utcMilliseconds = utcMilliseconds;\n  exports.utcSeconds = utcSeconds;\n  exports.utcMinutes = utcMinutes;\n  exports.utcHours = utcHours;\n  exports.utcDays = utcDays;\n  exports.utcSundays = utcSundays;\n  exports.utcMondays = utcMondays;\n  exports.utcTuesdays = utcTuesdays;\n  exports.utcWednesdays = utcWednesdays;\n  exports.utcThursdays = utcThursdays;\n  exports.utcFridays = utcFridays;\n  exports.utcSaturdays = utcSaturdays;\n  exports.utcWeeks = utcWeeks;\n  exports.utcMonths = utcMonths;\n  exports.utcYears = utcYears;\n  exports.millisecond = millisecond;\n  exports.second = second;\n  exports.minute = minute;\n  exports.hour = hour;\n  exports.day = day;\n  exports.sunday = sunday;\n  exports.monday = monday;\n  exports.tuesday = tuesday;\n  exports.wednesday = wednesday;\n  exports.thursday = thursday;\n  exports.friday = friday;\n  exports.saturday = saturday;\n  exports.week = sunday;\n  exports.month = month;\n  exports.year = year;\n  exports.utcSecond = utcSecond;\n  exports.utcMinute = utcMinute;\n  exports.utcHour = utcHour;\n  exports.utcDay = utcDay;\n  exports.utcSunday = utcSunday;\n  exports.utcMonday = utcMonday;\n  exports.utcTuesday = utcTuesday;\n  exports.utcWednesday = utcWednesday;\n  exports.utcThursday = utcThursday;\n  exports.utcFriday = utcFriday;\n  exports.utcSaturday = utcSaturday;\n  exports.utcWeek = utcSunday;\n  exports.utcMonth = utcMonth;\n  exports.utcYear = utcYear;\n  exports.interval = newInterval;\n\n}));",
    "var util = require('../util'),\n    time = require('../time'),\n    EPSILON = 1e-15;\n\nfunction bins(opt) {\n  if (!opt) { throw Error(\"Missing binning options.\"); }\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, level, minstep, precision, v, i, eps;\n\n  if (opt.step) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n\n    // increase step size if too many bins\n    while (Math.ceil(span/step) > maxb) { step *= base; }\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n}\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbins.date = function(opt) {\n  if (!opt) { throw Error(\"Missing date binning options.\"); }\n\n  // find time step, then bin\n  var units = opt.utc ? time.utc : time,\n      dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin),\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      spec = bins({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  spec.unit = unit;\n  spec.index = date_index;\n  if (!opt.raw) spec.value = date_value;\n  return spec;\n};\n\nmodule.exports = bins;\n",
    "var util = require('./util'),\n    gen = module.exports;\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n    max = min === undefined ? 1 : min;\n    min = 0;\n  }\n  var d = max - min;\n  var f = function() {\n    return min + d * Math.random();\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x >= min && x <= max) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    return x < min ? 0 : x > max ? 1 : (x - min) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? min + p*d : NaN;\n  };\n  return f;\n};\n\ngen.random.integer = function(a, b) {\n  if (b === undefined) {\n    b = a;\n    a = 0;\n  }\n  var d = b - a;\n  var f = function() {\n    return a + Math.floor(d * Math.random());\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    return (x === Math.floor(x) && x >= a && x < b) ? 1/d : 0;\n  };\n  f.cdf = function(x) {\n    var v = Math.floor(x);\n    return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;\n  };\n  f.icdf = function(p) {\n    return (p >= 0 && p <= 1) ? a - 1 + Math.floor(p*d) : NaN;\n  };\n  return f;\n};\n\ngen.random.normal = function(mean, stdev) {\n  mean = mean || 0;\n  stdev = stdev || 1;\n  var next;\n  var f = function() {\n    var x = 0, y = 0, rds, c;\n    if (next !== undefined) {\n      x = next;\n      next = undefined;\n      return x;\n    }\n    do {\n      x = Math.random()*2-1;\n      y = Math.random()*2-1;\n      rds = x*x + y*y;\n    } while (rds === 0 || rds > 1);\n    c = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n    next = mean + y*c*stdev;\n    return mean + x*c*stdev;\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  f.pdf = function(x) {\n    var exp = Math.exp(Math.pow(x-mean, 2) / (-2 * Math.pow(stdev, 2)));\n    return (1 / (stdev * Math.sqrt(2*Math.PI))) * exp;\n  };\n  f.cdf = function(x) {\n    // Approximation from West (2009)\n    // Better Approximations to Cumulative Normal Functions\n    var cd,\n        z = (x - mean) / stdev,\n        Z = Math.abs(z);\n    if (Z > 37) {\n      cd = 0;\n    } else {\n      var sum, exp = Math.exp(-Z*Z/2);\n      if (Z < 7.07106781186547) {\n        sum = 3.52624965998911e-02 * Z + 0.700383064443688;\n        sum = sum * Z + 6.37396220353165;\n        sum = sum * Z + 33.912866078383;\n        sum = sum * Z + 112.079291497871;\n        sum = sum * Z + 221.213596169931;\n        sum = sum * Z + 220.206867912376;\n        cd = exp * sum;\n        sum = 8.83883476483184e-02 * Z + 1.75566716318264;\n        sum = sum * Z + 16.064177579207;\n        sum = sum * Z + 86.7807322029461;\n        sum = sum * Z + 296.564248779674;\n        sum = sum * Z + 637.333633378831;\n        sum = sum * Z + 793.826512519948;\n        sum = sum * Z + 440.413735824752;\n        cd = cd / sum;\n      } else {\n        sum = Z + 0.65;\n        sum = Z + 4 / sum;\n        sum = Z + 3 / sum;\n        sum = Z + 2 / sum;\n        sum = Z + 1 / sum;\n        cd = exp / sum / 2.506628274631;\n      }\n    }\n    return z > 0 ? 1 - cd : cd;\n  };\n  f.icdf = function(p) {\n    // Approximation of Probit function using inverse error function.\n    if (p <= 0 || p >= 1) return NaN;\n    var x = 2*p - 1,\n        v = (8 * (Math.PI - 3)) / (3 * Math.PI * (4-Math.PI)),\n        a = (2 / (Math.PI*v)) + (Math.log(1 - Math.pow(x,2)) / 2),\n        b = Math.log(1 - (x*x)) / v,\n        s = (x > 0 ? 1 : -1) * Math.sqrt(Math.sqrt((a*a) - b) - a);\n    return mean + stdev * Math.SQRT2 * s;\n  };\n  return f;\n};\n\ngen.random.bootstrap = function(domain, smooth) {\n  // Generates a bootstrap sample from a set of observations.\n  // Smooth bootstrapping adds random zero-centered noise to the samples.\n  var val = domain.filter(util.isValid),\n      len = val.length,\n      err = smooth ? gen.random.normal(0, smooth) : null;\n  var f = function() {\n    return val[~~(Math.random()*len)] + (err ? err() : 0);\n  };\n  f.samples = function(n) {\n    return gen.zeros(n).map(f);\n  };\n  return f;\n};",
    "var util = require('../util');\n\nvar TYPES = '__types__';\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  function(x) { return x == null || x === '' ? null : x + ''; }\n};\n\nvar TESTS = {\n  boolean: function(x) { return x==='true' || x==='false' || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction annotation(data, types) {\n  if (!types) return data && data[TYPES] || null;\n  data[TYPES] = types;\n}\n\nfunction fieldNames(datum) {\n  return util.keys(datum);\n}\n\nfunction bracket(fieldName) {\n  return '[' + fieldName + ']';\n}\n\nfunction type(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var v, i, n;\n\n  // if data array has type annotations, use them\n  if (values[TYPES]) {\n    v = f(values[TYPES]);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0, n=values.length; !util.isValid(v) && i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n\n  return util.isDate(v) ? 'date' :\n    util.isNumber(v)    ? 'number' :\n    util.isBoolean(v)   ? 'boolean' :\n    util.isString(v)    ? 'string' : null;\n}\n\nfunction typeAll(data, fields) {\n  if (!data.length) return;\n  var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);\n  return fields.reduce(function(types, f) {\n    return (types[f] = type(data, get(f)), types);\n  }, {});\n}\n\nfunction infer(values, f) {\n  values = util.array(values);\n  f = util.$(f);\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isValid(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction inferAll(data, fields) {\n  var get = fields ? util.identity : (fields = fieldNames(data[0]), bracket);\n  return fields.reduce(function(types, f) {\n    types[f] = infer(data, get(f));\n    return types;\n  }, {});\n}\n\ntype.annotation = annotation;\ntype.all = typeAll;\ntype.infer = infer;\ntype.inferAll = inferAll;\ntype.parsers = PARSERS;\nmodule.exports = type;\n",
    "var util = require('./util');\nvar type = require('./import/type');\nvar gen = require('./generate');\n\nvar stats = module.exports;\n\n// Collect unique values.\n// Output: an array of unique values, in first-observed order\nstats.unique = function(values, f, results) {\n  f = util.$(f);\n  results = results || [];\n  var u = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    results.push(v);\n  }\n  return results;\n};\n\n// Return the length of the input array.\nstats.count = function(values) {\n  return values && values.length || 0;\n};\n\n// Count the number of non-null, non-undefined, non-NaN values.\nstats.count.valid = function(values, f) {\n  f = util.$(f);\n  var v, i, n, valid = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) valid += 1;\n  }\n  return valid;\n};\n\n// Count the number of null or undefined values.\nstats.count.missing = function(values, f) {\n  f = util.$(f);\n  var v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\n// Null, undefined and NaN are each considered distinct values.\nstats.count.distinct = function(values, f) {\n  f = util.$(f);\n  var u = {}, v, i, n, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Construct a map from distinct values to occurrence counts.\nstats.count.map = function(values, f) {\n  f = util.$(f);\n  var map = {}, v, i, n;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    map[v] = (v in map) ? map[v] + 1 : 1;\n  }\n  return map;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  return stats.quantile(values, 0.5);\n};\n\n// Computes the quartile boundaries of an array of numbers.\nstats.quartile = function(values, f) {\n  if (f) values = values.map(util.$(f));\n  values = values.filter(util.isValid).sort(util.cmp);\n  var q = stats.quantile;\n  return [q(values, 0.25), q(values, 0.50), q(values, 0.75)];\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  f = util.$(f);\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the sum of an array of numbers.\nstats.sum = function(values, f) {\n  f = util.$(f);\n  for (var sum=0, i=0, n=values.length, v; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) sum += v;\n  }\n  return sum;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  f = util.$(f);\n  var mean = 0, delta, i, n, c, v;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the geometric mean of an array of numbers.\nstats.mean.geometric = function(values, f) {\n  f = util.$(f);\n  var mean = 1, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v <= 0) {\n        throw Error(\"Geometric mean only defined for positive values.\");\n      }\n      mean *= v;\n      ++c;\n    }\n  }\n  mean = c > 0 ? Math.pow(mean, 1/c) : 0;\n  return mean;\n};\n\n// Compute the harmonic mean of an array of numbers.\nstats.mean.harmonic = function(values, f) {\n  f = util.$(f);\n  var mean = 0, c, n, v, i;\n  for (i=0, c=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      mean += 1/v;\n      ++c;\n    }\n  }\n  return c / mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  f = util.$(f);\n  if (!util.isArray(values) || values.length < 2) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum value in an array.\nstats.min = function(values, f) {\n  return stats.extent(values, f)[0];\n};\n\n// Find the maximum value in an array.\nstats.max = function(values, f) {\n  return stats.extent(values, f)[1];\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  f = util.$(f);\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  f = util.$(f);\n  var x = -1, y = -1, a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isValid(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error('Array lengths must match.');\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (v === v) sum += v;\n    }\n  } else {\n    a = util.$(a);\n    b = util.$(b);\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (v === v) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b) || util.isString(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      L2 = e === 2 || e == null,\n      n = values.length, s = 0, d, i;\n  if (f) {\n    a = util.$(a);\n    b = util.$(b);\n  }\n  for (i=0; i<n; ++i) {\n    d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n    s += L2 ? d*d : Math.pow(Math.abs(d), e);\n  }\n  return L2 ? Math.sqrt(s) : Math.pow(s, 1/e);\n};\n\n// Compute the Cohen's d effect size between two arrays of numbers.\nstats.cohensd = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      x1 = stats.mean(X),\n      x2 = stats.mean(Y),\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y);\n\n  if ((n1+n2-2) <= 0) {\n    // if both arrays are size 1, or one is empty, there's no effect size\n    return 0;\n  }\n  // pool standard deviation\n  var s1 = stats.variance(X),\n      s2 = stats.variance(Y),\n      s = Math.sqrt((((n1-1)*s1) + ((n2-1)*s2)) / (n1+n2-2));\n  // if there is no variance, there's no effect size\n  return s===0 ? 0 : (x1 - x2) / s;\n};\n\n// Computes the covariance between two arrays of numbers\nstats.covariance = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xm = stats.mean(X),\n      ym = stats.mean(Y),\n      sum = 0, c = 0, i, x, y, vx, vy;\n\n  if (n !== Y.length) {\n    throw Error('Input lengths must match.');\n  }\n\n  for (i=0; i<n; ++i) {\n    x = X[i]; vx = util.isValid(x);\n    y = Y[i]; vy = util.isValid(y);\n    if (vx && vy) {\n      sum += (x-xm) * (y-ym);\n      ++c;\n    } else if (vx || vy) {\n      throw Error('Valid values must align.');\n    }\n  }\n  return sum / (c-1);\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  f = util.$(f) || util.identity;\n  var a = values.map(function(v, i) {\n      return {idx: i, val: f(v)};\n    })\n    .sort(util.comparator('val'));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(util.$(b)) : a;\n  a = fn ? values.map(util.$(a)) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Simple linear regression.\n// Returns a \"fit\" object with slope (m), intercept (b),\n// r value (R), and sum-squared residual error (rss).\nstats.linearRegression = function(values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n = X.length,\n      xy = stats.covariance(X, Y), // will throw err if valid vals don't align\n      sx = stats.stdev(X),\n      sy = stats.stdev(Y),\n      slope = xy / (sx*sx),\n      icept = stats.mean(Y) - slope * stats.mean(X),\n      fit = {slope: slope, intercept: icept, R: xy / (sx*sy), rss: 0},\n      res, i;\n\n  for (i=0; i<n; ++i) {\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      res = (slope*X[i] + icept) - Y[i];\n      fit.rss += res * res;\n    }\n  }\n\n  return fit;\n};\n\n// Namespace for bootstrap\nstats.bootstrap = {};\n\n// Construct a bootstrapped confidence interval at a given percentile level\n// Arguments are an array, an optional n (defaults to 1000),\n//  an optional alpha (defaults to 0.05), and an optional smoothing parameter\nstats.bootstrap.ci = function(values, a, b, c, d) {\n  var X, N, alpha, smooth, bs, means, i;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    N = b;\n    alpha = c;\n    smooth = d;\n  } else {\n    X = values;\n    N = a;\n    alpha = b;\n    smooth = c;\n  }\n  N = N ? +N : 1000;\n  alpha = alpha || 0.05;\n\n  bs = gen.random.bootstrap(X, smooth);\n  for (i=0, means = Array(N); i<N; ++i) {\n    means[i] = stats.mean(bs.samples(X.length));\n  }\n  means.sort(util.numcmp);\n  return [\n    stats.quantile(means, alpha/2),\n    stats.quantile(means, 1-(alpha/2))\n  ];\n};\n\n// Namespace for z-tests\nstats.z = {};\n\n// Construct a z-confidence interval at a given significance level\n// Arguments are an array and an optional alpha (defaults to 0.05).\nstats.z.ci = function(values, a, b) {\n  var X = values, alpha = a;\n  if (util.isFunction(a) || util.isString(a)) {\n    X = values.map(util.$(a));\n    alpha = b;\n  }\n  alpha = alpha || 0.05;\n\n  var z = alpha===0.05 ? 1.96 : gen.random.normal(0, 1).icdf(1-(alpha/2)),\n      mu = stats.mean(X),\n      SE = stats.stdev(X) / Math.sqrt(stats.count.valid(X));\n  return [mu - (z*SE), mu + (z*SE)];\n};\n\n// Perform a z-test of means. Returns the p-value.\n// If a single array is provided, performs a one-sample location test.\n// If two arrays or a table and two accessors are provided, performs\n// a two-sample location test. A paired test is performed if specified\n// by the options hash.\n// The options hash format is: {paired: boolean, nullh: number}.\n// http://en.wikipedia.org/wiki/Z-test\n// http://en.wikipedia.org/wiki/Paired_difference_test\nstats.z.test = function(values, a, b, opt) {\n  if (util.isFunction(b) || util.isString(b)) { // table and accessors\n    return (opt && opt.paired ? ztestP : ztest2)(opt, values, a, b);\n  } else if (util.isArray(a)) { // two arrays\n    return (b && b.paired ? ztestP : ztest2)(b, values, a);\n  } else if (util.isFunction(a) || util.isString(a)) {\n    return ztest1(b, values, a); // table and accessor\n  } else {\n    return ztest1(a, values); // one array\n  }\n};\n\n// Perform a z-test of means. Returns the p-value.\n// Assuming we have a list of values, and a null hypothesis. If no null\n// hypothesis, assume our null hypothesis is mu=0.\nfunction ztest1(opt, X, f) {\n  var nullH = opt && opt.nullh || 0,\n      gaussian = gen.random.normal(0, 1),\n      mu = stats.mean(X,f),\n      SE = stats.stdev(X,f) / Math.sqrt(stats.count.valid(X,f));\n\n  if (SE===0) {\n    // Test not well defined when standard error is 0.\n    return (mu - nullH) === 0 ? 1 : 0;\n  }\n  // Two-sided, so twice the one-sided cdf.\n  var z = (mu - nullH) / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Perform a two sample paired z-test of means. Returns the p-value.\nfunction ztestP(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count(X),\n      n2 = stats.count(Y),\n      diffs = Array(), i;\n\n  if (n1 !== n2) {\n    throw Error('Array lengths must match.');\n  }\n  for (i=0; i<n1; ++i) {\n    // Only valid differences should contribute to the test statistic\n    if (util.isValid(X[i]) && util.isValid(Y[i])) {\n      diffs.push(X[i] - Y[i]);\n    }\n  }\n  return stats.z.test(diffs, opt && opt.nullh || 0);\n}\n\n// Perform a two sample z-test of means. Returns the p-value.\nfunction ztest2(opt, values, a, b) {\n  var X = b ? values.map(util.$(a)) : values,\n      Y = b ? values.map(util.$(b)) : a,\n      n1 = stats.count.valid(X),\n      n2 = stats.count.valid(Y),\n      gaussian = gen.random.normal(0, 1),\n      meanDiff = stats.mean(X) - stats.mean(Y) - (opt && opt.nullh || 0),\n      SE = Math.sqrt(stats.variance(X)/n1 + stats.variance(Y)/n2);\n\n  if (SE===0) {\n    // Not well defined when pooled standard error is 0.\n    return meanDiff===0 ? 1 : 0;\n  }\n  // Two-tailed, so twice the one-sided cdf.\n  var z = meanDiff / SE;\n  return 2 * gaussian.cdf(-Math.abs(z));\n}\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  f = util.$(f);\n  var i, p, s = 0, H = 0, n = counts.length;\n  for (i=0; i<n; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<n; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p) H += p * Math.log(p);\n  }\n  return -H / Math.LN2;\n};\n\n// Compute the mutual information between two discrete variables.\n// Returns an array of the form [MI, MI_distance]\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(util.$(a)) : values,\n      y = counts ? values.map(util.$(b)) : a,\n      z = counts ? values.map(util.$(counts)) : b;\n\n  var px = {},\n      py = {},\n      n = z.length,\n      s = 0, I = 0, H = 0, p, t, i;\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] = 0;\n    py[y[i]] = 0;\n  }\n\n  for (i=0; i<n; ++i) {\n    px[x[i]] += z[i];\n    py[y[i]] += z[i];\n    s += z[i];\n  }\n\n  t = 1 / (s * Math.LN2);\n  for (i=0; i<n; ++i) {\n    if (z[i] === 0) continue;\n    p = (s * z[i]) / (px[x[i]] * py[y[i]]);\n    I += z[i] * t * Math.log(p);\n    H += z[i] * t * Math.log(z[i]/s);\n  }\n\n  return [I, 1 + I/H];\n};\n\n// Compute the mutual information between two discrete variables.\nstats.mutual.info = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[0];\n};\n\n// Compute the mutual information distance between two discrete variables.\n// MI_distance is defined as 1 - I(a,b) / H(a,b).\nstats.mutual.dist = function(values, a, b, counts) {\n  return stats.mutual(values, a, b, counts)[1];\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var mean = 0,\n      valid = 0,\n      missing = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x;\n\n  // compute summary stats\n  for (i=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (v == null) {\n      ++missing;\n    } else if (util.isValid(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n      delta = x - mean;\n      mean = mean + delta / (++valid);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (valid - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    type:     type(values, f),\n    unique:   u,\n    count:    values.length,\n    valid:    valid,\n    missing:  missing,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    q1:       stats.quantile(vals, 0.25),\n    q3:       stats.quantile(vals, 0.75),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd\n  };\n};\n\n// Compute profiles for all variables in a data set.\nstats.summary = function(data, fields) {\n  fields = fields || util.keys(data[0]);\n  var s = fields.map(function(f) {\n    var p = stats.profile(data, util.$(f));\n    return (p.field = f, p);\n  });\n  return (s.__summary__ = true, s);\n};\n",
    "var d3_time = require('d3-time');\n\nvar tempDate = new Date(),\n    baseDate = new Date(0, 0, 1).setFullYear(0), // Jan 1, 0 AD\n    utcBaseDate = new Date(Date.UTC(0, 0, 1)).setUTCFullYear(0);\n\nfunction date(d) {\n  return (tempDate.setTime(+d), tempDate);\n}\n\n// create a time unit entry\nfunction entry(type, date, unit, step, min, max) {\n  var e = {\n    type: type,\n    date: date,\n    unit: unit\n  };\n  if (step) {\n    e.step = step;\n  } else {\n    e.minstep = 1;\n  }\n  if (min != null) e.min = min;\n  if (max != null) e.max = max;\n  return e;\n}\n\nfunction create(type, unit, base, step, min, max) {\n  return entry(type,\n    function(d) { return unit.offset(base, d); },\n    function(d) { return unit.count(base, d); },\n    step, min, max);\n}\n\nvar locale = [\n  create('second', d3_time.second, baseDate),\n  create('minute', d3_time.minute, baseDate),\n  create('hour',   d3_time.hour,   baseDate),\n  create('day',    d3_time.day,    baseDate, [1, 7]),\n  create('month',  d3_time.month,  baseDate, [1, 3, 6]),\n  create('year',   d3_time.year,   baseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(1970, 0, 1, 0, 0, d); },\n    function(d) { return date(d).getSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(1970, 0, 1, 0, d); },\n    function(d) { return date(d).getMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(1970, 0, 1, d); },\n    function(d) { return date(d).getHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(1970, 0, 4+d); },\n    function(d) { return date(d).getDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(1970, 0, d); },\n    function(d) { return date(d).getDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(1970, d % 12, 1); },\n    function(d) { return date(d).getMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar utc = [\n  create('second', d3_time.utcSecond, utcBaseDate),\n  create('minute', d3_time.utcMinute, utcBaseDate),\n  create('hour',   d3_time.utcHour,   utcBaseDate),\n  create('day',    d3_time.utcDay,    utcBaseDate, [1, 7]),\n  create('month',  d3_time.utcMonth,  utcBaseDate, [1, 3, 6]),\n  create('year',   d3_time.utcYear,   utcBaseDate),\n\n  // periodic units\n  entry('seconds',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, 0, d)); },\n    function(d) { return date(d).getUTCSeconds(); },\n    null, 0, 59\n  ),\n  entry('minutes',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, 0, d)); },\n    function(d) { return date(d).getUTCMinutes(); },\n    null, 0, 59\n  ),\n  entry('hours',\n    function(d) { return new Date(Date.UTC(1970, 0, 1, d)); },\n    function(d) { return date(d).getUTCHours(); },\n    null, 0, 23\n  ),\n  entry('weekdays',\n    function(d) { return new Date(Date.UTC(1970, 0, 4+d)); },\n    function(d) { return date(d).getUTCDay(); },\n    [1], 0, 6\n  ),\n  entry('dates',\n    function(d) { return new Date(Date.UTC(1970, 0, d)); },\n    function(d) { return date(d).getUTCDate(); },\n    [1], 1, 31\n  ),\n  entry('months',\n    function(d) { return new Date(Date.UTC(1970, d % 12, 1)); },\n    function(d) { return date(d).getUTCMonth(); },\n    [1], 0, 11\n  )\n];\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nfunction find(units, span, minb, maxb) {\n  var step = STEPS[0], i, n, bins;\n\n  for (i=1, n=STEPS.length; i<n; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return units[STEPS[i-1][1]];\n      }\n      if (bins >= minb) {\n        return units[step[1]];\n      }\n    }\n  }\n  return units[STEPS[n-1][1]];\n}\n\nfunction toUnitMap(units) {\n  var map = {}, i, n;\n  for (i=0, n=units.length; i<n; ++i) {\n    map[units[i].type] = units[i];\n  }\n  map.find = function(span, minb, maxb) {\n    return find(units, span, minb, maxb);\n  };\n  return map;\n}\n\nmodule.exports = toUnitMap(locale);\nmodule.exports.utc = toUnitMap(utc);",
    "var u = module.exports;\n\n// utility functions\n\nvar FNAME = '__name__';\n\nu.namedfunc = function(name, f) { return (f[FNAME] = name, f); };\n\nu.name = function(f) { return f==null ? null : f[FNAME]; };\n\nu.identity = function(x) { return x; };\n\nu.true = u.namedfunc('true', function() { return true; });\n\nu.false = u.namedfunc('false', function() { return false; });\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.length = function(x) {\n  return x != null && x.length != null ? x.length : null;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list, f) {\n  return (f = u.$(f)) ?\n    list.reduce(function(obj, x) { return (obj[f(x)] = 1, obj); }, {}) :\n    list.reduce(function(obj, x) { return (obj[x] = 1, obj); }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  var n = values.length;\n  if (!n) return '';\n  for (var s=String(values[0]), i=1; i<n; ++i) {\n    s += '|' + String(values[i]);\n  }\n  return s;\n};\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) === '[object Function]';\n};\n\nu.isString = function(obj) {\n  return typeof value === 'string' || toString.call(obj) === '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) === '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return typeof obj === 'number' || toString.call(obj) === '[object Number]';\n};\n\nu.isBoolean = function(obj) {\n  return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) === '[object Date]';\n};\n\nu.isValid = function(obj) {\n  return obj != null && obj === obj;\n};\n\nu.isBuffer = (typeof Buffer === 'function' && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) {\n  return s == null || s === '' ? null : +s;\n};\n\nu.boolean = function(s) {\n  return s == null || s === '' ? null : s==='false' ? false : !!s;\n};\n\n// parse a date with optional d3.time-format format\nu.date = function(s, format) {\n  var d = format ? format : Date;\n  return s == null || s === '' ? null : d.parse(s);\n};\n\nu.array = function(x) {\n  return x != null ? (u.isArray(x) ? x : [x]) : [];\n};\n\nu.str = function(x) {\n  return u.isArray(x) ? '[' + x.map(u.str) + ']'\n    : u.isObject(x) || u.isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n};\n\n// data access functions\n\nvar field_re = /\\[(.*?)\\]|[^.\\[]+/g;\n\nu.field = function(f) {\n  return String(f).match(field_re).map(function(d) {\n    return d[0] !== '[' ? d :\n      d[1] !== \"'\" && d[1] !== '\"' ? d.slice(1, -1) :\n      d.slice(2, -2).replace(/\\\\([\"'])/g, '$1');\n  });\n};\n\nu.accessor = function(f) {\n  /* jshint evil: true */\n  return f==null || u.isFunction(f) ? f :\n    u.namedfunc(f, Function('x', 'return x[' + u.field(f).map(u.str).join('][') + '];'));\n};\n\n// short-cut for accessor\nu.$ = u.accessor;\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1 ?\n    function(x, v) {\n      for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n      x[s[i]] = v;\n    } :\n    function(x, v) { x[f] = v; };\n};\n\n\nu.$func = function(name, op) {\n  return function(f) {\n    f = u.$(f) || u.identity;\n    var n = name + (u.name(f) ? '_'+u.name(f) : '');\n    return u.namedfunc(n, function(d) { return op(f(d)); });\n  };\n};\n\nu.$valid  = u.$func('valid', u.isValid);\nu.$length = u.$func('length', u.length);\n\nu.$in = function(f, values) {\n  f = u.$(f);\n  var map = u.isArray(values) ? u.toMap(values) : values;\n  return function(d) { return !!map[f(d)]; };\n};\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === '-') { s = -1; f = f.slice(1); }\n    else if (f[0] === '+') { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a, b) {\n    var i, n, f, c;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i];\n      c = u.cmp(f(a), f(b));\n      if (c) return c * sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  return (a < b || a == null) && b != null ? -1 :\n    (a > b || b == null) && a != null ? 1 :\n    ((b = b instanceof Date ? +b : b),\n     (a = a instanceof Date ? +a : a)) !== a && b === b ? -1 :\n    b !== b && a === a ? 1 : 0;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n// permutes an array using a Knuth shuffle\nu.permute = function(a) {\n  var m = a.length,\n      swap,\n      i;\n\n  while (m) {\n    i = Math.floor(Math.random() * m--);\n    swap = a[m];\n    a[m] = a[i];\n    a[i] = swap;\n  }\n};\n\n// string functions\n\nu.pad = function(s, length, pos, padchar) {\n  padchar = padchar || \" \";\n  var d = length - s.length;\n  if (d <= 0) return s;\n  switch (pos) {\n    case 'left':\n      return strrep(d, padchar) + s;\n    case 'middle':\n    case 'center':\n      return strrep(Math.floor(d/2), padchar) +\n         s + strrep(Math.ceil(d/2), padchar);\n    default:\n      return s + strrep(d, padchar);\n  }\n};\n\nfunction strrep(n, str) {\n  var s = \"\", i;\n  for (i=0; i<n; ++i) s += str;\n  return s;\n}\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : '\\u2026';\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case 'left':\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case 'middle':\n    case 'center':\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) +\n        ellipsis + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join('').trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n",
    "var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nmodule.exports = function (obj, opts) {\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\nvar isArray = Array.isArray || function (x) {\n    return {}.toString.call(x) === '[object Array]';\n};\n\nvar objectKeys = Object.keys || function (obj) {\n    var has = Object.prototype.hasOwnProperty || function () { return true };\n    var keys = [];\n    for (var key in obj) {\n        if (has.call(obj, key)) keys.push(key);\n    }\n    return keys;\n};\n",
    "exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n",
    "var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n",
    "var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n",
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n                t[p[i]] = s[p[i]];\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [0, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function (m, exports) {\r\n        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n    };\r\n\r\n    __values = function (o) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n        if (m) return m.call(o);\r\n        return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator];\r\n        return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n});",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar AGGREGATE_OP_INDEX = {\n    values: 1,\n    count: 1,\n    valid: 1,\n    missing: 1,\n    distinct: 1,\n    sum: 1,\n    mean: 1,\n    average: 1,\n    variance: 1,\n    variancep: 1,\n    stdev: 1,\n    stdevp: 1,\n    median: 1,\n    q1: 1,\n    q3: 1,\n    ci0: 1,\n    ci1: 1,\n    min: 1,\n    max: 1,\n    argmin: 1,\n    argmax: 1,\n};\nexports.AGGREGATE_OPS = util_1.flagKeys(AGGREGATE_OP_INDEX);\nfunction isAggregateOp(a) {\n    return !!AGGREGATE_OP_INDEX[a];\n}\nexports.isAggregateOp = isAggregateOp;\nexports.COUNTING_OPS = ['count', 'valid', 'missing', 'distinct'];\nfunction isCountingAggregateOp(aggregate) {\n    return aggregate && util_1.contains(exports.COUNTING_OPS, aggregate);\n}\nexports.isCountingAggregateOp = isCountingAggregateOp;\n/** Additive-based aggregation operations.  These can be applied to stack. */\nexports.SUM_OPS = [\n    'count',\n    'sum',\n    'distinct',\n    'valid',\n    'missing'\n];\n/**\n * Aggregation operators that always produce values within the range [domainMin, domainMax].\n */\nexports.SHARED_DOMAIN_OPS = [\n    'mean',\n    'average',\n    'median',\n    'q1',\n    'q3',\n    'min',\n    'max',\n];\nexports.SHARED_DOMAIN_OP_INDEX = util_1.toSet(exports.SHARED_DOMAIN_OPS);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWdncmVnYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2FnZ3JlZ2F0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtCQUF1RDtBQVN2RCxJQUFNLGtCQUFrQixHQUFzQjtJQUM1QyxNQUFNLEVBQUUsQ0FBQztJQUNULEtBQUssRUFBRSxDQUFDO0lBQ1IsS0FBSyxFQUFFLENBQUM7SUFDUixPQUFPLEVBQUUsQ0FBQztJQUNWLFFBQVEsRUFBRSxDQUFDO0lBQ1gsR0FBRyxFQUFFLENBQUM7SUFDTixJQUFJLEVBQUUsQ0FBQztJQUNQLE9BQU8sRUFBRSxDQUFDO0lBQ1YsUUFBUSxFQUFFLENBQUM7SUFDWCxTQUFTLEVBQUUsQ0FBQztJQUNaLEtBQUssRUFBRSxDQUFDO0lBQ1IsTUFBTSxFQUFFLENBQUM7SUFDVCxNQUFNLEVBQUUsQ0FBQztJQUNULEVBQUUsRUFBRSxDQUFDO0lBQ0wsRUFBRSxFQUFFLENBQUM7SUFDTCxHQUFHLEVBQUUsQ0FBQztJQUNOLEdBQUcsRUFBRSxDQUFDO0lBQ04sR0FBRyxFQUFFLENBQUM7SUFDTixHQUFHLEVBQUUsQ0FBQztJQUNOLE1BQU0sRUFBRSxDQUFDO0lBQ1QsTUFBTSxFQUFFLENBQUM7Q0FDVixDQUFDO0FBRVcsUUFBQSxhQUFhLEdBQUcsZUFBUSxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFFMUQsdUJBQThCLENBQVM7SUFDckMsTUFBTSxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNqQyxDQUFDO0FBRkQsc0NBRUM7QUFFWSxRQUFBLFlBQVksR0FBa0IsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUVyRiwrQkFBc0MsU0FBaUI7SUFDckQsTUFBTSxDQUFDLFNBQVMsSUFBSSxlQUFRLENBQUMsb0JBQVksRUFBRSxTQUFTLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBRkQsc0RBRUM7QUFFRCw2RUFBNkU7QUFDaEUsUUFBQSxPQUFPLEdBQWtCO0lBQ2xDLE9BQU87SUFDUCxLQUFLO0lBQ0wsVUFBVTtJQUNWLE9BQU87SUFDUCxTQUFTO0NBQ1osQ0FBQztBQUVGOztHQUVHO0FBQ1UsUUFBQSxpQkFBaUIsR0FBa0I7SUFDNUMsTUFBTTtJQUNOLFNBQVM7SUFDVCxRQUFRO0lBQ1IsSUFBSTtJQUNKLElBQUk7SUFDSixLQUFLO0lBQ0wsS0FBSztDQUNSLENBQUM7QUFFVyxRQUFBLHNCQUFzQixHQUFHLFlBQUssQ0FBQyx5QkFBaUIsQ0FBQyxDQUFDIn0=",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A dictionary listing whether a certain axis property is applicable for only main axes or only grid axes.\n * (Properties not listed are applicable for both)\n */\nexports.AXIS_PROPERTY_TYPE = {\n    grid: 'grid',\n    labelOverlap: 'main',\n    offset: 'main',\n    title: 'main'\n};\nexports.AXIS_PROPERTIES = [\n    'domain', 'format', 'grid', 'labelPadding', 'labels', 'labelOverlap', 'maxExtent', 'minExtent', 'offset', 'orient', 'position', 'tickCount', 'ticks', 'tickSize', 'title', 'titlePadding', 'values', 'zindex'\n];\nexports.VG_AXIS_PROPERTIES = [].concat(exports.AXIS_PROPERTIES, ['gridScale']);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXhpcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9heGlzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBK0RBOzs7R0FHRztBQUNVLFFBQUEsa0JBQWtCLEdBRzNCO0lBQ0YsSUFBSSxFQUFFLE1BQU07SUFDWixZQUFZLEVBQUUsTUFBTTtJQUNwQixNQUFNLEVBQUUsTUFBTTtJQUNkLEtBQUssRUFBRSxNQUFNO0NBQ2QsQ0FBQztBQWtDVyxRQUFBLGVBQWUsR0FBMkI7SUFDckQsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxjQUFjLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBRSxRQUFRO0NBQzlNLENBQUM7QUFFVyxRQUFBLGtCQUFrQixHQUFxQixFQUFFLENBQUMsTUFBTSxDQUFDLHVCQUFlLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDIn0=",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"./channel\");\nvar util_1 = require(\"./util\");\nfunction binToString(bin) {\n    if (util_1.isBoolean(bin)) {\n        return 'bin';\n    }\n    return 'bin' + util_1.keys(bin).map(function (p) { return \"_\" + p + \"_\" + bin[p]; }).join('');\n}\nexports.binToString = binToString;\nfunction autoMaxBins(channel) {\n    switch (channel) {\n        case channel_1.ROW:\n        case channel_1.COLUMN:\n        case channel_1.SIZE:\n        case channel_1.COLOR:\n        case channel_1.OPACITY:\n        // Facets and Size shouldn't have too many bins\n        // We choose 6 like shape to simplify the rule\n        case channel_1.SHAPE:\n            return 6; // Vega's \"shape\" has 6 distinct values\n        default:\n            return 10;\n    }\n}\nexports.autoMaxBins = autoMaxBins;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmluLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Jpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHFDQUE0RTtBQUM1RSwrQkFBdUM7QUE2RHZDLHFCQUE0QixHQUF3QjtJQUNsRCxFQUFFLENBQUMsQ0FBQyxnQkFBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQixNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUNELE1BQU0sQ0FBQyxLQUFLLEdBQUcsV0FBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLE1BQUksQ0FBQyxTQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUcsRUFBakIsQ0FBaUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNoRSxDQUFDO0FBTEQsa0NBS0M7QUFFRCxxQkFBNEIsT0FBZ0I7SUFDMUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUNoQixLQUFLLGFBQUcsQ0FBQztRQUNULEtBQUssZ0JBQU0sQ0FBQztRQUNaLEtBQUssY0FBSSxDQUFDO1FBQ1YsS0FBSyxlQUFLLENBQUM7UUFDWCxLQUFLLGlCQUFPLENBQUM7UUFDWCwrQ0FBK0M7UUFDL0MsOENBQThDO1FBQ2hELEtBQUssZUFBSztZQUNSLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyx1Q0FBdUM7UUFDbkQ7WUFDRSxNQUFNLENBQUMsRUFBRSxDQUFDO0lBQ2QsQ0FBQztBQUNILENBQUM7QUFkRCxrQ0FjQyJ9",
    "\"use strict\";\n/*\n * Constants and utilities for encoding channels (Visual variables)\n * such as 'x', 'y', 'color'.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar util_1 = require(\"./util\");\nvar Channel;\n(function (Channel) {\n    // Facet\n    Channel.ROW = 'row';\n    Channel.COLUMN = 'column';\n    // Position\n    Channel.X = 'x';\n    Channel.Y = 'y';\n    Channel.X2 = 'x2';\n    Channel.Y2 = 'y2';\n    // Mark property with scale\n    Channel.COLOR = 'color';\n    Channel.SHAPE = 'shape';\n    Channel.SIZE = 'size';\n    Channel.OPACITY = 'opacity';\n    // Non-scale channel\n    Channel.TEXT = 'text';\n    Channel.ORDER = 'order';\n    Channel.DETAIL = 'detail';\n    Channel.TOOLTIP = 'tooltip';\n})(Channel = exports.Channel || (exports.Channel = {}));\nexports.X = Channel.X;\nexports.Y = Channel.Y;\nexports.X2 = Channel.X2;\nexports.Y2 = Channel.Y2;\nexports.ROW = Channel.ROW;\nexports.COLUMN = Channel.COLUMN;\nexports.SHAPE = Channel.SHAPE;\nexports.SIZE = Channel.SIZE;\nexports.COLOR = Channel.COLOR;\nexports.TEXT = Channel.TEXT;\nexports.DETAIL = Channel.DETAIL;\nexports.ORDER = Channel.ORDER;\nexports.OPACITY = Channel.OPACITY;\nexports.TOOLTIP = Channel.TOOLTIP;\nvar UNIT_CHANNEL_INDEX = {\n    x: 1,\n    y: 1,\n    x2: 1,\n    y2: 1,\n    size: 1,\n    shape: 1,\n    color: 1,\n    order: 1,\n    opacity: 1,\n    text: 1,\n    detail: 1,\n    tooltip: 1\n};\nvar FACET_CHANNEL_INDEX = {\n    row: 1,\n    column: 1\n};\nvar CHANNEL_INDEX = tslib_1.__assign({}, UNIT_CHANNEL_INDEX, FACET_CHANNEL_INDEX);\nexports.CHANNELS = util_1.flagKeys(CHANNEL_INDEX);\nvar _o = CHANNEL_INDEX.order, _d = CHANNEL_INDEX.detail, SINGLE_DEF_CHANNEL_INDEX = tslib_1.__rest(CHANNEL_INDEX, [\"order\", \"detail\"]);\n/**\n * Channels that cannot have an array of channelDef.\n * model.fieldDef, getFieldDef only work for these channels.\n *\n * (The only two channels that can have an array of channelDefs are \"detail\" and \"order\".\n * Since there can be multiple fieldDefs for detail and order, getFieldDef/model.fieldDef\n * are not applicable for them.  Similarly, selection projecttion won't work with \"detail\" and \"order\".)\n */\nexports.SINGLE_DEF_CHANNELS = util_1.flagKeys(SINGLE_DEF_CHANNEL_INDEX);\nfunction isChannel(str) {\n    return !!CHANNEL_INDEX[str];\n}\nexports.isChannel = isChannel;\n// CHANNELS without COLUMN, ROW\nexports.UNIT_CHANNELS = util_1.flagKeys(UNIT_CHANNEL_INDEX);\n// NONSPATIAL_CHANNELS = UNIT_CHANNELS without X, Y, X2, Y2;\nvar _x = UNIT_CHANNEL_INDEX.x, _y = UNIT_CHANNEL_INDEX.y, \n// x2 and y2 share the same scale as x and y\n_x2 = UNIT_CHANNEL_INDEX.x2, _y2 = UNIT_CHANNEL_INDEX.y2, \n// The rest of unit channels then have scale\nNONSPATIAL_CHANNEL_INDEX = tslib_1.__rest(UNIT_CHANNEL_INDEX, [\"x\", \"y\", \"x2\", \"y2\"]);\nexports.NONSPATIAL_CHANNELS = util_1.flagKeys(NONSPATIAL_CHANNEL_INDEX);\n// SPATIAL_SCALE_CHANNELS = X and Y;\nvar SPATIAL_SCALE_CHANNEL_INDEX = { x: 1, y: 1 };\nexports.SPATIAL_SCALE_CHANNELS = util_1.flagKeys(SPATIAL_SCALE_CHANNEL_INDEX);\n// NON_SPATIAL_SCALE_CHANNEL = SCALE_CHANNELS without X, Y\nvar \n// x2 and y2 share the same scale as x and y\n// text and tooltip has format instead of scale\n_t = NONSPATIAL_CHANNEL_INDEX.text, _tt = NONSPATIAL_CHANNEL_INDEX.tooltip, \n// detail and order have no scale\n_dd = NONSPATIAL_CHANNEL_INDEX.detail, _oo = NONSPATIAL_CHANNEL_INDEX.order, NONSPATIAL_SCALE_CHANNEL_INDEX = tslib_1.__rest(NONSPATIAL_CHANNEL_INDEX, [\"text\", \"tooltip\", \"detail\", \"order\"]);\nexports.NONSPATIAL_SCALE_CHANNELS = util_1.flagKeys(NONSPATIAL_SCALE_CHANNEL_INDEX);\n// Declare SCALE_CHANNEL_INDEX\nvar SCALE_CHANNEL_INDEX = tslib_1.__assign({}, SPATIAL_SCALE_CHANNEL_INDEX, NONSPATIAL_SCALE_CHANNEL_INDEX);\n/** List of channels with scales */\nexports.SCALE_CHANNELS = util_1.flagKeys(SCALE_CHANNEL_INDEX);\nfunction isScaleChannel(channel) {\n    return !!SCALE_CHANNEL_INDEX[channel];\n}\nexports.isScaleChannel = isScaleChannel;\n/**\n * Return whether a channel supports a particular mark type.\n * @param channel  channel name\n * @param mark the mark type\n * @return whether the mark supports the channel\n */\nfunction supportMark(channel, mark) {\n    return mark in getSupportedMark(channel);\n}\nexports.supportMark = supportMark;\n/**\n * Return a dictionary showing whether a channel supports mark type.\n * @param channel\n * @return A dictionary mapping mark types to boolean values.\n */\nfunction getSupportedMark(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.COLOR:\n        case exports.DETAIL:\n        case exports.TOOLTIP:\n        case exports.ORDER: // TODO: revise (order might not support rect, which is not stackable?)\n        case exports.OPACITY:\n        case exports.ROW:\n        case exports.COLUMN:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, rect: true, line: true, area: true, text: true\n            };\n        case exports.X2:\n        case exports.Y2:\n            return {\n                rule: true, bar: true, rect: true, area: true\n            };\n        case exports.SIZE:\n            return {\n                point: true, tick: true, rule: true, circle: true, square: true,\n                bar: true, text: true, line: true\n            };\n        case exports.SHAPE:\n            return { point: true };\n        case exports.TEXT:\n            return { text: true };\n    }\n}\nexports.getSupportedMark = getSupportedMark;\nfunction rangeType(channel) {\n    switch (channel) {\n        case exports.X:\n        case exports.Y:\n        case exports.SIZE:\n        case exports.OPACITY:\n        // X2 and Y2 use X and Y scales, so they similarly have continuous range.\n        case exports.X2:\n        case exports.Y2:\n            return 'continuous';\n        case exports.ROW:\n        case exports.COLUMN:\n        case exports.SHAPE:\n        // TEXT and TOOLTIP have no scale but have discrete output\n        case exports.TEXT:\n        case exports.TOOLTIP:\n            return 'discrete';\n        // Color can be either continuous or discrete, depending on scale type.\n        case exports.COLOR:\n            return 'flexible';\n        // No scale, no range type.\n        case exports.DETAIL:\n        case exports.ORDER:\n            return undefined;\n    }\n    /* istanbul ignore next: should never reach here. */\n    throw new Error('getSupportedRole not implemented for ' + channel);\n}\nexports.rangeType = rangeType;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhbm5lbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jaGFubmVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7O0dBR0c7OztBQU9ILCtCQUFnRDtBQUVoRCxJQUFpQixPQUFPLENBc0J2QjtBQXRCRCxXQUFpQixPQUFPO0lBQ3RCLFFBQVE7SUFDSyxXQUFHLEdBQVUsS0FBSyxDQUFDO0lBQ25CLGNBQU0sR0FBYSxRQUFRLENBQUM7SUFFekMsV0FBVztJQUNFLFNBQUMsR0FBUSxHQUFHLENBQUM7SUFDYixTQUFDLEdBQVEsR0FBRyxDQUFDO0lBQ2IsVUFBRSxHQUFTLElBQUksQ0FBQztJQUNoQixVQUFFLEdBQVMsSUFBSSxDQUFDO0lBRTdCLDJCQUEyQjtJQUNkLGFBQUssR0FBWSxPQUFPLENBQUM7SUFDekIsYUFBSyxHQUFZLE9BQU8sQ0FBQztJQUN6QixZQUFJLEdBQVcsTUFBTSxDQUFDO0lBQ3RCLGVBQU8sR0FBYyxTQUFTLENBQUM7SUFFNUMsb0JBQW9CO0lBQ1AsWUFBSSxHQUFXLE1BQU0sQ0FBQztJQUN0QixhQUFLLEdBQVksT0FBTyxDQUFDO0lBQ3pCLGNBQU0sR0FBYSxRQUFRLENBQUM7SUFDNUIsZUFBTyxHQUFjLFNBQVMsQ0FBQztBQUM5QyxDQUFDLEVBdEJnQixPQUFPLEdBQVAsZUFBTyxLQUFQLGVBQU8sUUFzQnZCO0FBSVksUUFBQSxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNkLFFBQUEsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDZCxRQUFBLEVBQUUsR0FBRyxPQUFPLENBQUMsRUFBRSxDQUFDO0FBQ2hCLFFBQUEsRUFBRSxHQUFHLE9BQU8sQ0FBQyxFQUFFLENBQUM7QUFDaEIsUUFBQSxHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQztBQUNsQixRQUFBLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO0FBQ3hCLFFBQUEsS0FBSyxHQUFHLE9BQU8s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",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar channel_1 = require(\"../../channel\");\nvar log = require(\"../../log\");\nvar scale_1 = require(\"../../scale\");\nvar scale_2 = require(\"../../scale\");\nvar type_1 = require(\"../../type\");\nvar util = require(\"../../util\");\nvar util_1 = require(\"../../util\");\n/**\n * Determine if there is a specified scale type and if it is appropriate,\n * or determine default type if type is unspecified or inappropriate.\n */\n// NOTE: CompassQL uses this method.\nfunction scaleType(specifiedType, channel, fieldDef, mark, scaleConfig) {\n    var defaultScaleType = defaultType(channel, fieldDef, mark, scaleConfig);\n    if (!channel_1.isScaleChannel(channel)) {\n        // There is no scale for these channels\n        return null;\n    }\n    if (specifiedType !== undefined) {\n        // Check if explicitly specified scale type is supported by the channel\n        if (!scale_1.channelSupportScaleType(channel, specifiedType)) {\n            log.warn(log.message.scaleTypeNotWorkWithChannel(channel, specifiedType, defaultScaleType));\n            return defaultScaleType;\n        }\n        // Check if explicitly specified scale type is supported by the data type\n        if (!fieldDefMatchScaleType(specifiedType, fieldDef)) {\n            log.warn(log.message.scaleTypeNotWorkWithFieldDef(specifiedType, defaultScaleType));\n            return defaultScaleType;\n        }\n        return specifiedType;\n    }\n    return defaultScaleType;\n}\nexports.scaleType = scaleType;\n/**\n * Determine appropriate default scale type.\n */\n// NOTE: Voyager uses this method.\nfunction defaultType(channel, fieldDef, mark, scaleConfig) {\n    switch (fieldDef.type) {\n        case 'nominal':\n        case 'ordinal':\n            if (channel === 'color' || channel_1.rangeType(channel) === 'discrete') {\n                if (channel === 'shape' && fieldDef.type === 'ordinal') {\n                    log.warn(log.message.discreteChannelCannotEncode(channel, 'ordinal'));\n                }\n                return 'ordinal';\n            }\n            if (util.contains(['x', 'y'], channel)) {\n                if (mark === 'rect') {\n                    // The rect mark should fit into a band.\n                    return 'band';\n                }\n                if (mark === 'bar') {\n                    return 'band';\n                }\n            }\n            // Otherwise, use ordinal point scale so we can easily get center positions of the marks.\n            return 'point';\n        case 'temporal':\n            if (channel === 'color') {\n                return 'sequential';\n            }\n            else if (channel_1.rangeType(channel) === 'discrete') {\n                log.warn(log.message.discreteChannelCannotEncode(channel, 'temporal'));\n                // TODO: consider using quantize (equivalent to binning) once we have it\n                return 'ordinal';\n            }\n            return 'time';\n        case 'quantitative':\n            if (channel === 'color') {\n                if (fieldDef.bin) {\n                    return 'bin-ordinal';\n                }\n                // Use `sequential` as the default color scale for continuous data\n                // since it supports both array range and scheme range.\n                return 'sequential';\n            }\n            else if (channel_1.rangeType(channel) === 'discrete') {\n                log.warn(log.message.discreteChannelCannotEncode(channel, 'quantitative'));\n                // TODO: consider using quantize (equivalent to binning) once we have it\n                return 'ordinal';\n            }\n            // x and y use a linear scale because selections don't work with bin scales.\n            // Binned scales apply discretization but pan/zoom apply transformations to a [min, max] extent domain.\n            if (fieldDef.bin && channel !== 'x' && channel !== 'y') {\n                return 'bin-linear';\n            }\n            return 'linear';\n    }\n    /* istanbul ignore next: should never reach this */\n    throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\nfunction fieldDefMatchScaleType(specifiedType, fieldDef) {\n    var type = fieldDef.type;\n    if (util_1.contains([type_1.Type.ORDINAL, type_1.Type.NOMINAL], type)) {\n        return specifiedType === undefined || scale_2.hasDiscreteDomain(specifiedType);\n    }\n    else if (type === type_1.Type.TEMPORAL) {\n        return util_1.contains([scale_1.ScaleType.TIME, scale_1.ScaleType.UTC, scale_1.ScaleType.SEQUENTIAL, undefined], specifiedType);\n    }\n    else if (type === type_1.Type.QUANTITATIVE) {\n        if (fieldDef.bin) {\n            return util_1.contains([scale_1.ScaleType.BIN_LINEAR, scale_1.ScaleType.BIN_ORDINAL, scale_1.ScaleType.LINEAR], specifiedType);\n        }\n        return util_1.contains([scale_1.ScaleType.LOG, scale_1.ScaleType.POW, scale_1.ScaleType.SQRT, scale_1.ScaleType.QUANTILE, scale_1.ScaleType.QUANTIZE, scale_1.ScaleType.LINEAR, scale_1.ScaleType.SEQUENTIAL, undefined], specifiedType);\n    }\n    return true;\n}\nexports.fieldDefMatchScaleType = fieldDefMatchScaleType;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb21waWxlL3NjYWxlL3R5cGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5Q0FBaUU7QUFFakUsK0JBQWlDO0FBRWpDLHFDQUE0RTtBQUM1RSxxQ0FBOEM7QUFDOUMsbUNBQWdDO0FBQ2hDLGlDQUFtQztBQUNuQyxtQ0FBb0M7QUFLcEM7OztHQUdHO0FBQ0gsb0NBQW9DO0FBQ3BDLG1CQUNFLGFBQXdCLEVBQUUsT0FBZ0IsRUFBRSxRQUEwQixFQUN0RSxJQUFVLEVBQUUsV0FBd0I7SUFHcEMsSUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFFM0UsRUFBRSxDQUFDLENBQUMsQ0FBQyx3QkFBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUM3Qix1Q0FBdUM7UUFDdkMsTUFBTSxDQUFDLElBQUksQ0FBQztJQUNkLENBQUM7SUFDRCxFQUFFLENBQUMsQ0FBQyxhQUFhLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztRQUNoQyx1RUFBdUU7UUFDdkUsRUFBRSxDQUFDLENBQUMsQ0FBQywrQkFBdUIsQ0FBQyxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3JELEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLGdCQUFnQixDQUFDLENBQUMsQ0FBQztZQUM1RixNQUFNLENBQUMsZ0JBQWdCLENBQUM7UUFDMUIsQ0FBQztRQUVELHlFQUF5RTtRQUN6RSxFQUFFLENBQUMsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLGFBQWEsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDckQsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLDRCQUE0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",
    "\"use strict\";\n// DateTime definition object\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar log = require(\"./log\");\nvar util_1 = require(\"./util\");\n/*\n * A designated year that starts on Sunday.\n */\nvar SUNDAY_YEAR = 2006;\nfunction isDateTime(o) {\n    return !!o && (!!o.year || !!o.quarter || !!o.month || !!o.date || !!o.day ||\n        !!o.hours || !!o.minutes || !!o.seconds || !!o.milliseconds);\n}\nexports.isDateTime = isDateTime;\nexports.MONTHS = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];\nexports.SHORT_MONTHS = exports.MONTHS.map(function (m) { return m.substr(0, 3); });\nexports.DAYS = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];\nexports.SHORT_DAYS = exports.DAYS.map(function (d) { return d.substr(0, 3); });\nfunction normalizeQuarter(q) {\n    if (util_1.isNumber(q)) {\n        if (q > 4) {\n            log.warn(log.message.invalidTimeUnit('quarter', q));\n        }\n        // We accept 1-based quarter, so need to readjust to 0-based quarter\n        return (q - 1) + '';\n    }\n    else {\n        // Invalid quarter\n        throw new Error(log.message.invalidTimeUnit('quarter', q));\n    }\n}\nfunction normalizeMonth(m) {\n    if (util_1.isNumber(m)) {\n        // We accept 1-based month, so need to readjust to 0-based month\n        return (m - 1) + '';\n    }\n    else {\n        var lowerM = m.toLowerCase();\n        var monthIndex = exports.MONTHS.indexOf(lowerM);\n        if (monthIndex !== -1) {\n            return monthIndex + ''; // 0 for january, ...\n        }\n        var shortM = lowerM.substr(0, 3);\n        var shortMonthIndex = exports.SHORT_MONTHS.indexOf(shortM);\n        if (shortMonthIndex !== -1) {\n            return shortMonthIndex + '';\n        }\n        // Invalid month\n        throw new Error(log.message.invalidTimeUnit('month', m));\n    }\n}\nfunction normalizeDay(d) {\n    if (util_1.isNumber(d)) {\n        // mod so that this can be both 0-based where 0 = sunday\n        // and 1-based where 7=sunday\n        return (d % 7) + '';\n    }\n    else {\n        var lowerD = d.toLowerCase();\n        var dayIndex = exports.DAYS.indexOf(lowerD);\n        if (dayIndex !== -1) {\n            return dayIndex + ''; // 0 for january, ...\n        }\n        var shortD = lowerD.substr(0, 3);\n        var shortDayIndex = exports.SHORT_DAYS.indexOf(shortD);\n        if (shortDayIndex !== -1) {\n            return shortDayIndex + '';\n        }\n        // Invalid day\n        throw new Error(log.message.invalidTimeUnit('day', d));\n    }\n}\n/**\n * Return Vega Expression for a particular date time.\n * @param d\n * @param normalize whether to normalize quarter, month, day.\n */\nfunction dateTimeExpr(d, normalize) {\n    if (normalize === void 0) { normalize = false; }\n    var units = [];\n    if (normalize && d.day !== undefined) {\n        if (util_1.keys(d).length > 1) {\n            log.warn(log.message.droppedDay(d));\n            d = util_1.duplicate(d);\n            delete d.day;\n        }\n    }\n    if (d.year !== undefined) {\n        units.push(d.year);\n    }\n    else if (d.day !== undefined) {\n        // Set year to 2006 for working with day since January 1 2006 is a Sunday\n        units.push(SUNDAY_YEAR);\n    }\n    else {\n        units.push(0);\n    }\n    if (d.month !== undefined) {\n        var month = normalize ? normalizeMonth(d.month) : d.month;\n        units.push(month);\n    }\n    else if (d.quarter !== undefined) {\n        var quarter = normalize ? normalizeQuarter(d.quarter) : d.quarter;\n        units.push(quarter + '*3');\n    }\n    else {\n        units.push(0); // months start at zero in JS\n    }\n    if (d.date !== undefined) {\n        units.push(d.date);\n    }\n    else if (d.day !== undefined) {\n        // HACK: Day only works as a standalone unit\n        // This is only correct because we always set year to 2006 for day\n        var day = normalize ? normalizeDay(d.day) : d.day;\n        units.push(day + '+1');\n    }\n    else {\n        units.push(1); // Date starts at 1 in JS\n    }\n    // Note: can't use TimeUnit enum here as importing it will create\n    // circular dependency problem!\n    for (var _i = 0, _a = ['hours', 'minutes', 'seconds', 'milliseconds']; _i < _a.length; _i++) {\n        var timeUnit = _a[_i];\n        if (d[timeUnit] !== undefined) {\n            units.push(d[timeUnit]);\n        }\n        else {\n            units.push(0);\n        }\n    }\n    if (d.utc) {\n        return \"utc(\" + units.join(', ') + \")\";\n    }\n    else {\n        return \"datetime(\" + units.join(', ') + \")\";\n    }\n}\nexports.dateTimeExpr = dateTimeExpr;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXRpbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZGF0ZXRpbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLDZCQUE2Qjs7QUFFN0IsMkJBQTZCO0FBQzdCLCtCQUFpRDtBQUdqRDs7R0FFRztBQUNILElBQU0sV0FBVyxHQUFHLElBQUksQ0FBQztBQThHekIsb0JBQTJCLENBQU07SUFDL0IsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUc7UUFDeEUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBSEQsZ0NBR0M7QUFFWSxRQUFBLE1BQU0sR0FBRyxDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUM7QUFDcEksUUFBQSxZQUFZLEdBQUcsY0FBTSxDQUFDLEdBQUcsQ0FBQyxVQUFDLENBQUMsSUFBSyxPQUFBLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFkLENBQWMsQ0FBQyxDQUFDO0FBRWpELFFBQUEsSUFBSSxHQUFHLENBQUMsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxRQUFR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",
    "\"use strict\";\n// utility for a field definition object\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar aggregate_1 = require(\"./aggregate\");\nvar bin_1 = require(\"./bin\");\nvar channel_1 = require(\"./channel\");\nvar log = require(\"./log\");\nvar timeunit_1 = require(\"./timeunit\");\nvar type_1 = require(\"./type\");\nvar util_1 = require(\"./util\");\nfunction isRepeatRef(field) {\n    return field && !util_1.isString(field) && 'repeat' in field;\n}\nexports.isRepeatRef = isRepeatRef;\nfunction isConditionalDef(channelDef) {\n    return !!channelDef && !!channelDef.condition;\n}\nexports.isConditionalDef = isConditionalDef;\n/**\n * Return if a channelDef is a ConditionalValueDef with ConditionFieldDef\n */\nfunction hasConditionFieldDef(channelDef) {\n    return !!channelDef && !!channelDef.condition && isFieldDef(channelDef.condition);\n}\nexports.hasConditionFieldDef = hasConditionFieldDef;\nfunction isFieldDef(channelDef) {\n    return !!channelDef && (!!channelDef['field'] || channelDef['aggregate'] === 'count');\n}\nexports.isFieldDef = isFieldDef;\nfunction isValueDef(channelDef) {\n    return channelDef && 'value' in channelDef && channelDef['value'] !== undefined;\n}\nexports.isValueDef = isValueDef;\nfunction isScaleFieldDef(channelDef) {\n    return !!channelDef && (!!channelDef['scale'] || !!channelDef['sort']);\n}\nexports.isScaleFieldDef = isScaleFieldDef;\nfunction field(fieldDef, opt) {\n    if (opt === void 0) { opt = {}; }\n    var field = fieldDef.field;\n    var prefix = opt.prefix;\n    var suffix = opt.suffix;\n    if (isCount(fieldDef)) {\n        field = 'count_*';\n    }\n    else {\n        var fn = undefined;\n        if (!opt.nofn) {\n            if (fieldDef.bin) {\n                fn = bin_1.binToString(fieldDef.bin);\n                suffix = opt.binSuffix || '';\n            }\n            else if (fieldDef.aggregate) {\n                fn = String(opt.aggregate || fieldDef.aggregate);\n            }\n            else if (fieldDef.timeUnit) {\n                fn = String(fieldDef.timeUnit);\n            }\n        }\n        if (fn) {\n            field = fn + \"_\" + field;\n        }\n    }\n    if (suffix) {\n        field = field + \"_\" + suffix;\n    }\n    if (prefix) {\n        field = prefix + \"_\" + field;\n    }\n    if (opt.expr) {\n        field = opt.expr + \"[\" + util_1.stringValue(field) + \"]\";\n    }\n    return field;\n}\nexports.field = field;\nfunction isDiscrete(fieldDef) {\n    switch (fieldDef.type) {\n        case 'nominal':\n        case 'ordinal':\n            return true;\n        case 'quantitative':\n            return !!fieldDef.bin;\n        case 'temporal':\n            return false;\n    }\n    throw new Error(log.message.invalidFieldType(fieldDef.type));\n}\nexports.isDiscrete = isDiscrete;\nfunction isContinuous(fieldDef) {\n    return !isDiscrete(fieldDef);\n}\nexports.isContinuous = isContinuous;\nfunction isCount(fieldDef) {\n    return fieldDef.aggregate === 'count';\n}\nexports.isCount = isCount;\nfunction title(fieldDef, config) {\n    if (isCount(fieldDef)) {\n        return config.countTitle;\n    }\n    var fn = fieldDef.aggregate || fieldDef.timeUnit || (fieldDef.bin && 'bin');\n    if (fn) {\n        return fn.toUpperCase() + '(' + fieldDef.field + ')';\n    }\n    else {\n        return fieldDef.field;\n    }\n}\nexports.title = title;\nfunction defaultType(fieldDef, channel) {\n    if (fieldDef.timeUnit) {\n        return 'temporal';\n    }\n    if (fieldDef.bin) {\n        return 'quantitative';\n    }\n    switch (channel_1.rangeType(channel)) {\n        case 'continuous':\n            return 'quantitative';\n        case 'discrete':\n            return 'nominal';\n        case 'flexible':// color\n            return 'nominal';\n        default:\n            return 'quantitative';\n    }\n}\nexports.defaultType = defaultType;\n/**\n * Returns the fieldDef -- either from the outer channelDef or from the condition of channelDef.\n * @param channelDef\n */\nfunction getFieldDef(channelDef) {\n    if (isFieldDef(channelDef)) {\n        return channelDef;\n    }\n    else if (hasConditionFieldDef(channelDef)) {\n        return channelDef.condition;\n    }\n    return undefined;\n}\nexports.getFieldDef = getFieldDef;\n/**\n * Convert type to full, lowercase type, or augment the fieldDef with a default type if missing.\n */\nfunction normalize(channelDef, channel) {\n    // If a fieldDef contains a field, we need type.\n    if (isFieldDef(channelDef)) {\n        return normalizeFieldDef(channelDef, channel);\n    }\n    else if (hasConditionFieldDef(channelDef)) {\n        return tslib_1.__assign({}, channelDef, { \n            // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>\n            condition: normalizeFieldDef(channelDef.condition, channel) });\n    }\n    return channelDef;\n}\nexports.normalize = normalize;\nfunction normalizeFieldDef(fieldDef, channel) {\n    // Drop invalid aggregate\n    if (fieldDef.aggregate && !aggregate_1.isAggregateOp(fieldDef.aggregate)) {\n        var aggregate = fieldDef.aggregate, fieldDefWithoutAggregate = tslib_1.__rest(fieldDef, [\"aggregate\"]);\n        log.warn(log.message.invalidAggregate(fieldDef.aggregate));\n        fieldDef = fieldDefWithoutAggregate;\n    }\n    // Normalize Time Unit\n    if (fieldDef.timeUnit) {\n        fieldDef = tslib_1.__assign({}, fieldDef, { timeUnit: timeunit_1.normalizeTimeUnit(fieldDef.timeUnit) });\n    }\n    // Normalize bin\n    if (fieldDef.bin) {\n        fieldDef = tslib_1.__assign({}, fieldDef, { bin: normalizeBin(fieldDef.bin, channel) });\n    }\n    // Normalize Type\n    if (fieldDef.type) {\n        var fullType = type_1.getFullName(fieldDef.type);\n        if (fieldDef.type !== fullType) {\n            // convert short type to full type\n            fieldDef = tslib_1.__assign({}, fieldDef, { type: fullType });\n        }\n        if (fieldDef.type !== 'quantitative') {\n            if (aggregate_1.isCountingAggregateOp(fieldDef.aggregate)) {\n                log.warn(log.message.invalidFieldTypeForCountAggregate(fieldDef.type, fieldDef.aggregate));\n                fieldDef = tslib_1.__assign({}, fieldDef, { type: 'quantitative' });\n            }\n        }\n    }\n    else {\n        // If type is empty / invalid, then augment with default type\n        var newType = defaultType(fieldDef, channel);\n        log.warn(log.message.emptyOrInvalidFieldType(fieldDef.type, channel, newType));\n        fieldDef = tslib_1.__assign({}, fieldDef, { type: newType });\n    }\n    var _a = channelCompatibility(fieldDef, channel), compatible = _a.compatible, warning = _a.warning;\n    if (!compatible) {\n        log.warn(warning);\n    }\n    return fieldDef;\n}\nexports.normalizeFieldDef = normalizeFieldDef;\nfunction normalizeBin(bin, channel) {\n    if (util_1.isBoolean(bin)) {\n        return { maxbins: bin_1.autoMaxBins(channel) };\n    }\n    else if (!bin.maxbins && !bin.step) {\n        return tslib_1.__assign({}, bin, { maxbins: bin_1.autoMaxBins(channel) });\n    }\n    else {\n        return bin;\n    }\n}\nexports.normalizeBin = normalizeBin;\nvar COMPATIBLE = { compatible: true };\nfunction channelCompatibility(fieldDef, channel) {\n    switch (channel) {\n        case 'row':\n        case 'column':\n            if (isContinuous(fieldDef) && !fieldDef.timeUnit) {\n                // TODO:(https://github.com/vega/vega-lite/issues/2011):\n                // with timeUnit it's not always strictly continuous\n                return {\n                    compatible: false,\n                    warning: log.message.facetChannelShouldBeDiscrete(channel)\n                };\n            }\n            return COMPATIBLE;\n        case 'x':\n        case 'y':\n        case 'color':\n        case 'text':\n        case 'detail':\n        case 'tooltip':\n            return COMPATIBLE;\n        case 'opacity':\n        case 'size':\n        case 'x2':\n        case 'y2':\n            if (isDiscrete(fieldDef) && !fieldDef.bin) {\n                return {\n                    compatible: false,\n                    warning: \"Channel \" + channel + \" should not be used with discrete field.\"\n                };\n            }\n            return COMPATIBLE;\n        case 'shape':\n            if (fieldDef.type !== 'nominal') {\n                return {\n                    compatible: false,\n                    warning: 'Shape channel should be used with nominal data only'\n                };\n            }\n            return COMPATIBLE;\n        case 'order':\n            if (fieldDef.type === 'nominal') {\n                return {\n                    compatible: false,\n                    warning: \"Channel order is inappropriate for nominal field, which has no inherent order.\"\n                };\n            }\n            return COMPATIBLE;\n    }\n    throw new Error('channelCompatability not implemented for channel ' + channel);\n}\nexports.channelCompatibility = channelCompatibility;\nfunction isNumberFieldDef(fieldDef) {\n    return fieldDef.type === 'quantitative' || !!fieldDef.bin;\n}\nexports.isNumberFieldDef = isNumberFieldDef;\nfunction isTimeFieldDef(fieldDef) {\n    return fieldDef.type === 'temporal' || !!fieldDef.timeUnit;\n}\nexports.isTimeFieldDef = isTimeFieldDef;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmllbGRkZWYuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZmllbGRkZWYudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLHdDQUF3Qzs7O0FBRXhDLHlDQUE4RTtBQUU5RSw2QkFBMEQ7QUFDMUQscUNBQTZDO0FBSzdDLDJCQUE2QjtBQUs3Qix1Q0FBdUQ7QUFDdkQsK0JBQXlDO0FBQ3pDLCtCQUF3RDtBQXdFeEQscUJBQTRCLEtBQVk7SUFDdEMsTUFBTSxDQUFDLEtBQUssSUFBSSxDQUFDLGVBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxRQUFRLElBQUksS0FBSyxDQUFDO0FBQ3hELENBQUM7QUFGRCxrQ0FFQztBQXlJRCwwQkFBb0MsVUFBeUI7SUFDM0QsTUFBTSxDQUFDLENBQUMsQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7QUFDaEQsQ0FBQztBQUZELDRDQUVDO0FBRUQ7O0dBRUc7QUFDSCw4QkFBd0MsVUFBeUI7SUFDL0QsTUFBTSxDQUFDLENBQUMsQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxTQUFTLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUNwRixDQUFDO0FBRkQsb0RBRUM7QUFFRCxvQkFBOEIsVUFBeUI7SUFDckQsTUFBTSxDQUFDLENBQUMsQ0FBQyxVQUFVLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxJQUFJLFVBQVUsQ0FBQyxXQUFXLENBQUMsS0FBSyxPQUFPLENBQUMsQ0FBQztBQUN4RixDQUFDO0FBRkQsZ0NBRUM7QUFFRCxvQkFBOEIsVUFBeUI7SUFDckQsTUFBTSxDQUFDLFVBQVUsSUFBSSxPQUFPLElBQUksVUFBVSxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxTQUFTLENBQUM7QUFDbEYsQ0FBQztBQUZELGdDQUVDO0FBRUQseUJBQWdDLFVBQTJCO0lBQ3ZELE1BQU0sQ0FB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",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defaultLegendConfig = {};\nexports.LEGEND_PROPERTIES = ['entryPadding', 'format', 'offset', 'orient', 'tickCount', 'title', 'type', 'values', 'zindex'];\nexports.VG_LEGEND_PROPERTIES = [].concat(['fill', 'stroke', 'shape', 'size', 'opacity', 'encode'], exports.LEGEND_PROPERTIES);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGVnZW5kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xlZ2VuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQXlFYSxRQUFBLG1CQUFtQixHQUFpQixFQUFFLENBQUM7QUFFdkMsUUFBQSxpQkFBaUIsR0FBaUMsQ0FBQyxjQUFjLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBRW5KLFFBQUEsb0JBQW9CLEdBQXNCLEVBQUUsQ0FBQyxNQUFNLENBQzlELENBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxRQUFRLENBQUMsRUFDeEQseUJBQWlCLENBQ2xCLENBQUMifQ==",
    "\"use strict\";\n/**\n * Vega-Lite's singleton logger utility.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar vega_util_1 = require(\"vega-util\");\n/**\n * Main (default) Vega Logger instance for Vega-Lite\n */\nvar main = vega_util_1.logger(vega_util_1.Warn);\nvar current = main;\n/**\n * Logger tool for checking if the code throws correct warning\n */\nvar LocalLogger = /** @class */ (function () {\n    function LocalLogger() {\n        this.warns = [];\n        this.infos = [];\n        this.debugs = [];\n    }\n    LocalLogger.prototype.level = function () {\n        return this;\n    };\n    LocalLogger.prototype.warn = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this.warns).push.apply(_a, args);\n        return this;\n        var _a;\n    };\n    LocalLogger.prototype.info = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this.infos).push.apply(_a, args);\n        return this;\n        var _a;\n    };\n    LocalLogger.prototype.debug = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this.debugs).push.apply(_a, args);\n        return this;\n        var _a;\n    };\n    return LocalLogger;\n}());\nexports.LocalLogger = LocalLogger;\nfunction runLocalLogger(f) {\n    var localLogger = current = new LocalLogger();\n    f(localLogger);\n    reset();\n}\nexports.runLocalLogger = runLocalLogger;\nfunction wrap(f) {\n    return function () {\n        var logger = current = new LocalLogger();\n        f(logger);\n        reset();\n    };\n}\nexports.wrap = wrap;\n/**\n * Set the singleton logger to be a custom logger\n */\nfunction set(logger) {\n    current = logger;\n    return current;\n}\nexports.set = set;\n/**\n * Reset the main logger to use the default Vega Logger\n */\nfunction reset() {\n    current = main;\n    return current;\n}\nexports.reset = reset;\nfunction warn() {\n    var _ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        _[_i] = arguments[_i];\n    }\n    current.warn.apply(current, arguments);\n}\nexports.warn = warn;\nfunction info() {\n    var _ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        _[_i] = arguments[_i];\n    }\n    current.info.apply(current, arguments);\n}\nexports.info = info;\nfunction debug() {\n    var _ = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        _[_i] = arguments[_i];\n    }\n    current.debug.apply(current, arguments);\n}\nexports.debug = debug;\n/**\n * Collection of all Vega-Lite Error Messages\n */\nvar message;\n(function (message) {\n    message.INVALID_SPEC = 'Invalid spec';\n    // SELECTION\n    function cannotProjectOnChannelWithoutField(channel) {\n        return \"Cannot project a selection on encoding channel \\\"\" + channel + \"\\\", which has no field.\";\n    }\n    message.cannotProjectOnChannelWithoutField = cannotProjectOnChannelWithoutField;\n    function selectionNotFound(name) {\n        return \"Cannot find a selection named \\\"\" + name + \"\\\"\";\n    }\n    message.selectionNotFound = selectionNotFound;\n    // REPEAT\n    function noSuchRepeatedValue(field) {\n        return \"Unknown repeated value \\\"\" + field + \"\\\".\";\n    }\n    message.noSuchRepeatedValue = noSuchRepeatedValue;\n    // TITLE\n    function cannotSetTitleAnchor(type) {\n        return \"Cannot set title \\\"anchor\\\" for a \" + type + \" spec\";\n    }\n    message.cannotSetTitleAnchor = cannotSetTitleAnchor;\n    // DATA\n    function unrecognizedParse(p) {\n        return \"Unrecognized parse \\\"\" + p + \"\\\".\";\n    }\n    message.unrecognizedParse = unrecognizedParse;\n    function differentParse(field, local, ancestor) {\n        return \"An ancestor parsed field \\\"\" + field + \"\\\" as \" + ancestor + \" but a child wants to parse the field as \" + local + \".\";\n    }\n    message.differentParse = differentParse;\n    // TRANSFORMS\n    function invalidTransformIgnored(transform) {\n        return \"Ignoring an invalid transform: \" + JSON.stringify(transform) + \".\";\n    }\n    message.invalidTransformIgnored = invalidTransformIgnored;\n    message.NO_FIELDS_NEEDS_AS = 'If \"from.fields\" is not specified, \"as\" has to be a string that specifies the key to be used for the the data from the secondary source.';\n    // ENCODING & FACET\n    function invalidFieldType(type) {\n        return \"Invalid field type \\\"\" + type + \"\\\"\";\n    }\n    message.invalidFieldType = invalidFieldType;\n    function invalidFieldTypeForCountAggregate(type, aggregate) {\n        return \"Invalid field type \\\"\" + type + \"\\\" for aggregate: \\\"\" + aggregate + \"\\\", using \\\"quantitative\\\" instead.\";\n    }\n    message.invalidFieldTypeForCountAggregate = invalidFieldTypeForCountAggregate;\n    function invalidAggregate(aggregate) {\n        return \"Invalid aggregation operator \\\"\" + aggregate + \"\\\"\";\n    }\n    message.invalidAggregate = invalidAggregate;\n    function emptyOrInvalidFieldType(type, channel, newType) {\n        return \"Invalid field type \\\"\" + type + \"\\\" for channel \\\"\" + channel + \"\\\", using \\\"\" + newType + \"\\\" instead.\";\n    }\n    message.emptyOrInvalidFieldType = emptyOrInvalidFieldType;\n    function emptyFieldDef(fieldDef, channel) {\n        return \"Dropping \" + JSON.stringify(fieldDef) + \" from channel \\\"\" + channel + \"\\\" since it does not contain data field or value.\";\n    }\n    message.emptyFieldDef = emptyFieldDef;\n    function incompatibleChannel(channel, markOrFacet, when) {\n        return channel + \" dropped as it is incompatible with \\\"\" + markOrFacet + \"\\\"\" + (when ? \" when \" + when : '') + \".\";\n    }\n    message.incompatibleChannel = incompatibleChannel;\n    function facetChannelShouldBeDiscrete(channel) {\n        return channel + \" encoding should be discrete (ordinal / nominal / binned).\";\n    }\n    message.facetChannelShouldBeDiscrete = facetChannelShouldBeDiscrete;\n    function discreteChannelCannotEncode(channel, type) {\n        return \"Using discrete channel \\\"\" + channel + \"\\\" to encode \\\"\" + type + \"\\\" field can be misleading as it does not encode \" + (type === 'ordinal' ? 'order' : 'magnitude') + \".\";\n    }\n    message.discreteChannelCannotEncode = discreteChannelCannotEncode;\n    // Mark\n    message.BAR_WITH_POINT_SCALE_AND_RANGESTEP_NULL = 'Bar mark should not be used with point scale when rangeStep is null. Please use band scale instead.';\n    function unclearOrientContinuous(mark) {\n        return \"Cannot clearly determine orientation for \\\"\" + mark + \"\\\" since both x and y channel encode continous fields. In this case, we use vertical by default\";\n    }\n    message.unclearOrientContinuous = unclearOrientContinuous;\n    function unclearOrientDiscreteOrEmpty(mark) {\n        return \"Cannot clearly determine orientation for \\\"\" + mark + \"\\\" since both x and y channel encode discrete or empty fields.\";\n    }\n    message.unclearOrientDiscreteOrEmpty = unclearOrientDiscreteOrEmpty;\n    function orientOverridden(original, actual) {\n        return \"Specified orient \\\"\" + original + \"\\\" overridden with \\\"\" + actual + \"\\\"\";\n    }\n    message.orientOverridden = orientOverridden;\n    // SCALE\n    message.CANNOT_UNION_CUSTOM_DOMAIN_WITH_FIELD_DOMAIN = 'custom domain scale cannot be unioned with default field-based domain';\n    function cannotUseScalePropertyWithNonColor(prop) {\n        return \"Cannot use the scale property \\\"\" + prop + \"\\\" with non-color channel.\";\n    }\n    message.cannotUseScalePropertyWithNonColor = cannotUseScalePropertyWithNonColor;\n    function unaggregateDomainHasNoEffectForRawField(fieldDef) {\n        return \"Using unaggregated domain with raw field has no effect (\" + JSON.stringify(fieldDef) + \").\";\n    }\n    message.unaggregateDomainHasNoEffectForRawField = unaggregateDomainHasNoEffectForRawField;\n    function unaggregateDomainWithNonSharedDomainOp(aggregate) {\n        return \"Unaggregated domain not applicable for \\\"\" + aggregate + \"\\\" since it produces values outside the origin domain of the source data.\";\n    }\n    message.unaggregateDomainWithNonSharedDomainOp = unaggregateDomainWithNonSharedDomainOp;\n    function unaggregatedDomainWithLogScale(fieldDef) {\n        return \"Unaggregated domain is currently unsupported for log scale (\" + JSON.stringify(fieldDef) + \").\";\n    }\n    message.unaggregatedDomainWithLogScale = unaggregatedDomainWithLogScale;\n    message.CANNOT_USE_RANGE_WITH_POSITION = 'Cannot use a custom \"range\" with x or y channel.  Please customize width, height, padding, or rangeStep instead.';\n    function cannotUseSizeFieldWithBandSize(positionChannel) {\n        return \"Using size field when \" + positionChannel + \"-channel has a band scale is not supported.\";\n    }\n    message.cannotUseSizeFieldWithBandSize = cannotUseSizeFieldWithBandSize;\n    function cannotApplySizeToNonOrientedMark(mark) {\n        return \"Cannot apply size to non-oriented mark \\\"\" + mark + \"\\\".\";\n    }\n    message.cannotApplySizeToNonOrientedMark = cannotApplySizeToNonOrientedMark;\n    function rangeStepDropped(channel) {\n        return \"rangeStep for \\\"\" + channel + \"\\\" is dropped as top-level \" + (channel === 'x' ? 'width' : 'height') + \" is provided.\";\n    }\n    message.rangeStepDropped = rangeStepDropped;\n    function scaleTypeNotWorkWithChannel(channel, scaleType, defaultScaleType) {\n        return \"Channel \\\"\" + channel + \"\\\" does not work with \\\"\" + scaleType + \"\\\" scale. We are using \\\"\" + defaultScaleType + \"\\\" scale instead.\";\n    }\n    message.scaleTypeNotWorkWithChannel = scaleTypeNotWorkWithChannel;\n    function scaleTypeNotWorkWithFieldDef(scaleType, defaultScaleType) {\n        return \"FieldDef does not work with \\\"\" + scaleType + \"\\\" scale. We are using \\\"\" + defaultScaleType + \"\\\" scale instead.\";\n    }\n    message.scaleTypeNotWorkWithFieldDef = scaleTypeNotWorkWithFieldDef;\n    function scalePropertyNotWorkWithScaleType(scaleType, propName, channel) {\n        return channel + \"-scale's \\\"\" + propName + \"\\\" is dropped as it does not work with \" + scaleType + \" scale.\";\n    }\n    message.scalePropertyNotWorkWithScaleType = scalePropertyNotWorkWithScaleType;\n    function scaleTypeNotWorkWithMark(mark, scaleType) {\n        return \"Scale type \\\"\" + scaleType + \"\\\" does not work with mark \\\"\" + mark + \"\\\".\";\n    }\n    message.scaleTypeNotWorkWithMark = scaleTypeNotWorkWithMark;\n    function mergeConflictingProperty(property, propertyOf, v1, v2) {\n        return \"Conflicting \" + propertyOf + \" property \\\"\" + property + \"\\\" (\\\"\" + v1 + \"\\\" and \\\"\" + v2 + \"\\\").  Using \\\"\" + v1 + \"\\\".\";\n    }\n    message.mergeConflictingProperty = mergeConflictingProperty;\n    function independentScaleMeansIndependentGuide(channel) {\n        return \"Setting the scale to be independent for \\\"\" + channel + \"\\\" means we also have to set the guide (axis or legend) to be independent.\";\n    }\n    message.independentScaleMeansIndependentGuide = independentScaleMeansIndependentGuide;\n    function conflictedDomain(channel) {\n        return \"Cannot set \" + channel + \"-scale's \\\"domain\\\" as it is binned. Please use \\\"bin\\\"'s \\\"extent\\\" instead.\";\n    }\n    message.conflictedDomain = conflictedDomain;\n    function domainSortDropped(sort) {\n        return \"Dropping sort property \\\"\" + JSON.stringify(sort) + \"\\\" as unioned domains only support boolean or op 'count'.\";\n    }\n    message.domainSortDropped = domainSortDropped;\n    message.UNABLE_TO_MERGE_DOMAINS = 'Unable to merge domains';\n    message.MORE_THAN_ONE_SORT = 'Domains that should be unioned has conflicting sort properties. Sort will be set to true.';\n    // AXIS\n    message.INVALID_CHANNEL_FOR_AXIS = 'Invalid channel for axis.';\n    // STACK\n    function cannotStackRangedMark(channel) {\n        return \"Cannot stack \\\"\" + channel + \"\\\" if there is already \\\"\" + channel + \"2\\\"\";\n    }\n    message.cannotStackRangedMark = cannotStackRangedMark;\n    function cannotStackNonLinearScale(scaleType) {\n        return \"Cannot stack non-linear scale (\" + scaleType + \")\";\n    }\n    message.cannotStackNonLinearScale = cannotStackNonLinearScale;\n    function cannotStackNonSummativeAggregate(aggregate) {\n        return \"Cannot stack when the aggregate function is non-summative (\\\"\" + aggregate + \"\\\")\";\n    }\n    message.cannotStackNonSummativeAggregate = cannotStackNonSummativeAggregate;\n    // TIMEUNIT\n    function invalidTimeUnit(unitName, value) {\n        return \"Invalid \" + unitName + \": \\\"\" + value + \"\\\"\";\n    }\n    message.invalidTimeUnit = invalidTimeUnit;\n    function dayReplacedWithDate(fullTimeUnit) {\n        return \"Time unit \\\"\" + fullTimeUnit + \"\\\" is not supported. We are replacing it with \" + fullTimeUnit.replace('day', 'date') + \".\";\n    }\n    message.dayReplacedWithDate = dayReplacedWithDate;\n    function droppedDay(d) {\n        return \"Dropping day from datetime \" + JSON.stringify(d) + \" as day cannot be combined with other units.\";\n    }\n    message.droppedDay = droppedDay;\n})(message = exports.message || (exports.message = {}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2xvZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7O0dBRUc7O0FBRUgsdUNBQXdEO0FBY3hEOztHQUVHO0FBQ0gsSUFBTSxJQUFJLEdBQUcsa0JBQU0sQ0FBQyxnQkFBSSxDQUFDLENBQUM7QUFDMUIsSUFBSSxPQUFPLEdBQW9CLElBQUksQ0FBQztBQUVwQzs7R0FFRztBQUNIO0lBQUE7UUFDUyxVQUFLLEdBQVUsRUFBRSxDQUFDO1FBQ2xCLFVBQUssR0FBVSxFQUFFLENBQUM7UUFDbEIsV0FBTSxHQUFVLEVBQUUsQ0FBQztJQW9CNUIsQ0FBQztJQWxCUSwyQkFBSyxHQUFaO1FBQ0UsTUFBTSxDQUFDLElBQUksQ0FBQztJQUNkLENBQUM7SUFFTSwwQkFBSSxHQUFYO1FBQVksY0FBYzthQUFkLFVBQWMsRUFBZCxxQkFBYyxFQUFkLElBQWM7WUFBZCx5QkFBYzs7UUFDeEIsQ0FBQSxLQUFBLElBQUksQ0FBQyxLQUFLLENBQUEsQ0FBQyxJQUFJLFdBQUksSUFBSSxFQUFFO1FBQ3pCLE1BQU0sQ0FBQyxJQUFJLENBQUM7O0lBQ2QsQ0FBQztJQUVNLDBCQUFJLEdBQVg7UUFBWSxjQUFjO2FBQWQsVUFBYyxFQUFkLHFCQUFjLEVBQWQsSUFBYztZQUFkLHlCQUFjOztRQUN4QixDQUFBLEtBQUEsSUFBSSxDQUFDLEtBQUssQ0FBQSxDQUFDLElBQUksV0FBSSxJQUFJLEVBQUU7UUFDekIsTUFBTSxDQUFDLElBQUksQ0FBQzs7SUFDZCxDQUFDO0lBRU0sMkJBQUssR0FBWjtRQUFhLGNBQWM7YUFBZCxVQUFjLEVBQWQscUJBQWMsRUFBZCxJQUFjO1lBQWQseUJBQWM7O1FBQ3pCLENBQUEsS0FBQSxJQUFJLENBQUMsTUFBTSxDQUFBLENBQUMsSUFBSSxXQUFJLElBQUksRUFBRTtRQUMxQixNQUFNLENBQUMsSUFBSSxDQUFDOztJQUNkLENBQUM7SUFDSCxrQkFBQztBQUFELENBQUMs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",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isLogicalOr(op) {\n    return !!op.or;\n}\nexports.isLogicalOr = isLogicalOr;\nfunction isLogicalAnd(op) {\n    return !!op.and;\n}\nexports.isLogicalAnd = isLogicalAnd;\nfunction isLogicalNot(op) {\n    return !!op.not;\n}\nexports.isLogicalNot = isLogicalNot;\nfunction forEachLeave(op, fn) {\n    if (isLogicalNot(op)) {\n        forEachLeave(op.not, fn);\n    }\n    else if (isLogicalAnd(op)) {\n        for (var _i = 0, _a = op.and; _i < _a.length; _i++) {\n            var subop = _a[_i];\n            forEachLeave(subop, fn);\n        }\n    }\n    else if (isLogicalOr(op)) {\n        for (var _b = 0, _c = op.or; _b < _c.length; _b++) {\n            var subop = _c[_b];\n            forEachLeave(subop, fn);\n        }\n    }\n    else {\n        fn(op);\n    }\n}\nexports.forEachLeave = forEachLeave;\nfunction normalizeLogicalOperand(op, normalizer) {\n    if (isLogicalNot(op)) {\n        return { not: normalizeLogicalOperand(op.not, normalizer) };\n    }\n    else if (isLogicalAnd(op)) {\n        return { and: op.and.map(function (o) { return normalizeLogicalOperand(o, normalizer); }) };\n    }\n    else if (isLogicalOr(op)) {\n        return { or: op.or.map(function (o) { return normalizeLogicalOperand(o, normalizer); }) };\n    }\n    else {\n        return normalizer(op);\n    }\n}\nexports.normalizeLogicalOperand = normalizeLogicalOperand;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9naWNhbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9sb2dpY2FsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBY0EscUJBQTRCLEVBQXVCO0lBQ2pELE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUNqQixDQUFDO0FBRkQsa0NBRUM7QUFFRCxzQkFBNkIsRUFBdUI7SUFDbEQsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDO0FBQ2xCLENBQUM7QUFGRCxvQ0FFQztBQUVELHNCQUE2QixFQUF1QjtJQUNsRCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7QUFDbEIsQ0FBQztBQUZELG9DQUVDO0FBRUQsc0JBQWdDLEVBQXFCLEVBQUUsRUFBbUI7SUFDeEUsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNyQixZQUFZLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDNUIsR0FBRyxDQUFDLENBQWdCLFVBQU0sRUFBTixLQUFBLEVBQUUsQ0FBQyxHQUFHLEVBQU4sY0FBTSxFQUFOLElBQU07WUFBckIsSUFBTSxLQUFLLFNBQUE7WUFDZCxZQUFZLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1NBQ3pCO0lBQ0gsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNCLEdBQUcsQ0FBQyxDQUFnQixVQUFLLEVBQUwsS0FBQSxFQUFFLENBQUMsRUFBRSxFQUFMLGNBQUssRUFBTCxJQUFLO1lBQXBCLElBQU0sS0FBSyxTQUFBO1lBQ2QsWUFBWSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztTQUN6QjtJQUNILENBQUM7SUFBQyxJQUFJLENBQUMsQ0FBQztRQUNOLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNULENBQUM7QUFDSCxDQUFDO0FBZEQsb0NBY0M7QUFFRCxpQ0FBMkMsRUFBcUIsRUFBRSxVQUF1QjtJQUN2RixFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JCLE1BQU0sQ0FBQyxFQUFDLEdBQUcsRUFBRSx1QkFBdUIsQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxFQUFDLENBQUM7SUFDNUQsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVCLE1BQU0sQ0FBQyxFQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLHVCQUF1QixDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsRUFBdEMsQ0FBc0MsQ0FBQyxFQUFDLENBQUM7SUFDeEUsQ0FBQztJQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNCLE1BQU0sQ0FBQyxFQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLHVCQUF1QixDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsRUFBdEMsQ0FBc0MsQ0FBQyxFQUFDLENBQUM7SUFDdEUsQ0FBQztJQUFDLElBQUksQ0FBQyxDQUFDO1FBQ04sTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN4QixDQUFDO0FBQ0gsQ0FBQztBQVZELDBEQVVDIn0=",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"./util\");\nvar Mark;\n(function (Mark) {\n    Mark.AREA = 'area';\n    Mark.BAR = 'bar';\n    Mark.LINE = 'line';\n    Mark.POINT = 'point';\n    Mark.RECT = 'rect';\n    Mark.RULE = 'rule';\n    Mark.TEXT = 'text';\n    Mark.TICK = 'tick';\n    Mark.CIRCLE = 'circle';\n    Mark.SQUARE = 'square';\n})(Mark = exports.Mark || (exports.Mark = {}));\nexports.AREA = Mark.AREA;\nexports.BAR = Mark.BAR;\nexports.LINE = Mark.LINE;\nexports.POINT = Mark.POINT;\nexports.TEXT = Mark.TEXT;\nexports.TICK = Mark.TICK;\nexports.RECT = Mark.RECT;\nexports.RULE = Mark.RULE;\nexports.CIRCLE = Mark.CIRCLE;\nexports.SQUARE = Mark.SQUARE;\n// Using mapped type to declare index, ensuring we always have all marks when we add more.\nvar MARK_INDEX = {\n    area: 1,\n    bar: 1,\n    line: 1,\n    point: 1,\n    text: 1,\n    tick: 1,\n    rect: 1,\n    rule: 1,\n    circle: 1,\n    square: 1\n};\nfunction isMark(m) {\n    return !!MARK_INDEX[m];\n}\nexports.isMark = isMark;\nexports.PRIMITIVE_MARKS = util_1.flagKeys(MARK_INDEX);\nfunction isMarkDef(mark) {\n    return mark['type'];\n}\nexports.isMarkDef = isMarkDef;\nvar PRIMITIVE_MARK_INDEX = util_1.toSet(exports.PRIMITIVE_MARKS);\nfunction isPrimitiveMark(mark) {\n    var markType = isMarkDef(mark) ? mark.type : mark;\n    return markType in PRIMITIVE_MARK_INDEX;\n}\nexports.isPrimitiveMark = isPrimitiveMark;\nexports.STROKE_CONFIG = ['stroke', 'strokeWidth',\n    'strokeDash', 'strokeDashOffset', 'strokeOpacity'];\nexports.FILL_CONFIG = ['fill', 'fillOpacity'];\nexports.FILL_STROKE_CONFIG = [].concat(exports.STROKE_CONFIG, exports.FILL_CONFIG);\nexports.VL_ONLY_MARK_CONFIG_PROPERTIES = ['filled', 'color'];\nexports.VL_ONLY_MARK_SPECIFIC_CONFIG_PROPERTY_INDEX = {\n    bar: ['binSpacing', 'continuousBandSize', 'discreteBandSize'],\n    text: ['shortTimeLabels'],\n    tick: ['bandSize', 'thickness']\n};\nexports.defaultMarkConfig = {\n    color: '#4c78a8',\n};\nexports.defaultBarConfig = {\n    binSpacing: 1,\n    continuousBandSize: 2\n};\nexports.defaultTickConfig = {\n    thickness: 1\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFyay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYXJrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsK0JBQXVDO0FBR3ZDLElBQWlCLElBQUksQ0FXcEI7QUFYRCxXQUFpQixJQUFJO0lBQ04sU0FBSSxHQUFXLE1BQU0sQ0FBQztJQUN0QixRQUFHLEdBQVUsS0FBSyxDQUFDO0lBQ25CLFNBQUksR0FBVyxNQUFNLENBQUM7SUFDdEIsVUFBSyxHQUFZLE9BQU8sQ0FBQztJQUN6QixTQUFJLEdBQVcsTUFBTSxDQUFDO0lBQ3RCLFNBQUksR0FBVyxNQUFNLENBQUM7SUFDdEIsU0FBSSxHQUFXLE1BQU0sQ0FBQztJQUN0QixTQUFJLEdBQVcsTUFBTSxDQUFDO0lBQ3RCLFdBQU0sR0FBYSxRQUFRLENBQUM7SUFDNUIsV0FBTSxHQUFhLFFBQVEsQ0FBQztBQUMzQyxDQUFDLEVBWGdCLElBQUksR0FBSixZQUFJLEtBQUosWUFBSSxRQVdwQjtBQVFZLFFBQUEsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDakIsUUFBQSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUNmLFFBQUEsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDakIsUUFBQSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztBQUNuQixRQUFBLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQ2pCLFFBQUEsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDakIsUUFBQSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztBQUNqQixRQUFBLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBRWpCLFFBQUEsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDckIsUUFBQSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUVsQywwRkFBMEY7QUFDMUYsSUFBTSxVQUFVLEdBQXFCO0lBQ25DLElBQUksRUFBRSxDQUFDO0lBQ1AsR0FBRyxFQUFFLENBQUM7SUFDTixJQUFJLEVBQUUsQ0FBQztJQUNQLEtBQUssRUFBRSxDQUFDO0lBQ1IsSUFBSSxFQUFFLENBQUM7SUFDUCxJQUFJLEVBQUUsQ0FBQztJQUNQLElBQUksRUFBRSxDQUFDO0lBQ1AsSUFBSSxFQUFFLENBQUM7SUFDUCxNQUFNLEVBQUUsQ0FBQztJQUNULE1BQU0sRUFBRSxDQUFDO0NBQ1YsQ0FBQztBQUVGLGdCQUF1QixDQUFTO0lBQzlCLE1BQU0sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLENBQUM7QUFGRCx3QkFFQztBQUVZLFFBQUEsZUFBZSxHQUFHLGVBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQXlFcEQsbUJBQTBCLElBQWE7SUFDckMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN0QixDQUFDO0FBRkQsOEJBRUM7QUFFRCxJQUFNLG9CQUFvQixHQUFHLFlBQUssQ0FBQyx1QkFBZSxDQUFDLENBQUM7QUFFcEQseUJBQWdDLElBQXVEO0lBQ3JGLElBQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztJQUNwRCxNQUFNLENBQUMsUUFBUSxJQUFJLG9CQUFvQixDQUFDO0FBQzFDLENBQUM7QUFIRCwwQ0FHQztBQUVZLFFBQUEsYUFBYSxHQUFHLENBQUMsUUFBUSxFQUFFLGFBQWE7SUFDbkQsWUFBWSxFQUFFLGtCQUFrQixFQUFFLGVBQWUsQ0FBQyxDQUFDO0FBRXhDLFFBQUEsV0FBVyxHQUFHLENBQUMsTUFBTSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0FBRXRDLFFBQUEsa0JBQWtCLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxxQkFBYSxFQUFFLG1CQUFXLENBQUMsQ0FBQztBQUUzRCxRQUFBLDhCQUE4QixHQUF5QixDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztBQUUzRSxRQUFBLDJDQUEyQyxHQUVwRDtJQUNGLEdBQUcsRUFBRSxDQUFDLFlBQVksRUFBRSxvQkFBb0IsRUFBRSxrQkFBa0IsQ0FBQztJQUM3RCxJQUFJLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztJQUN6QixJQUFJLEVBQUUsQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDO0NBQ2hDLENBQUM7QUF3QlcsUUFBQSxpQkFBaUIsR0FBZTtJQUMzQyxLQUFLLEVBQUUsU0FBUztDQUNqQixDQUFDO0FBZ0VXLFFBQUEsZ0JBQWdCLEdBQWM7SUFDekMsVUFBVSxFQUFFLENBQUM7SUFDYixrQkFBa0IsRUFBRSxDQUFDO0NBQ3RCLENBQUM7QUF3Q1csUUFBQSxpQkFBaUIsR0FBZTtJQUMzQyxTQUFTLEVBQUUsQ0FBQztDQUNiLENBQUMifQ==",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar channel_1 = require(\"./channel\");\nvar log = require(\"./log\");\nvar util_1 = require(\"./util\");\nvar ScaleType;\n(function (ScaleType) {\n    // Continuous - Quantitative\n    ScaleType.LINEAR = 'linear';\n    ScaleType.BIN_LINEAR = 'bin-linear';\n    ScaleType.LOG = 'log';\n    ScaleType.POW = 'pow';\n    ScaleType.SQRT = 'sqrt';\n    // Continuous - Time\n    ScaleType.TIME = 'time';\n    ScaleType.UTC = 'utc';\n    // sequential\n    ScaleType.SEQUENTIAL = 'sequential';\n    // Quantile, Quantize, threshold\n    ScaleType.QUANTILE = 'quantile';\n    ScaleType.QUANTIZE = 'quantize';\n    ScaleType.THRESHOLD = 'threshold';\n    ScaleType.ORDINAL = 'ordinal';\n    ScaleType.BIN_ORDINAL = 'bin-ordinal';\n    ScaleType.POINT = 'point';\n    ScaleType.BAND = 'band';\n})(ScaleType = exports.ScaleType || (exports.ScaleType = {}));\n/**\n * Index for scale categories -- only scale of the same categories can be merged together.\n * Current implementation is trying to be conservative and avoid merging scale type that might not work together\n */\nvar SCALE_CATEGORY_INDEX = {\n    linear: 'numeric',\n    log: 'numeric',\n    pow: 'numeric',\n    sqrt: 'numeric',\n    'bin-linear': 'bin-linear',\n    time: 'time',\n    utc: 'time',\n    sequential: 'sequential',\n    ordinal: 'ordinal',\n    'bin-ordinal': 'bin-ordinal',\n    point: 'ordinal-position',\n    band: 'ordinal-position'\n};\nexports.SCALE_TYPES = util_1.keys(SCALE_CATEGORY_INDEX);\n/**\n * Whether the two given scale types can be merged together.\n */\nfunction scaleCompatible(scaleType1, scaleType2) {\n    var scaleCategory1 = SCALE_CATEGORY_INDEX[scaleType1];\n    var scaleCategory2 = SCALE_CATEGORY_INDEX[scaleType2];\n    return scaleCategory1 === scaleCategory2 ||\n        (scaleCategory1 === 'ordinal-position' && scaleCategory2 === 'time') ||\n        (scaleCategory2 === 'ordinal-position' && scaleCategory1 === 'time');\n}\nexports.scaleCompatible = scaleCompatible;\n/**\n * Index for scale predecence -- high score = higher priority for merging.\n */\nvar SCALE_PRECEDENCE_INDEX = {\n    // numeric\n    linear: 0,\n    log: 1,\n    pow: 1,\n    sqrt: 1,\n    // time\n    time: 0,\n    utc: 0,\n    // ordinal-position -- these have higher precedence than continuous scales as they support more types of data\n    point: 10,\n    band: 11,\n    // non grouped types\n    'bin-linear': 0,\n    sequential: 0,\n    ordinal: 0,\n    'bin-ordinal': 0,\n};\n/**\n * Return scale categories -- only scale of the same categories can be merged together.\n */\nfunction scaleTypePrecedence(scaleType) {\n    return SCALE_PRECEDENCE_INDEX[scaleType];\n}\nexports.scaleTypePrecedence = scaleTypePrecedence;\nexports.CONTINUOUS_TO_CONTINUOUS_SCALES = ['linear', 'bin-linear', 'log', 'pow', 'sqrt', 'time', 'utc'];\nvar CONTINUOUS_TO_CONTINUOUS_INDEX = util_1.toSet(exports.CONTINUOUS_TO_CONTINUOUS_SCALES);\nexports.CONTINUOUS_DOMAIN_SCALES = exports.CONTINUOUS_TO_CONTINUOUS_SCALES.concat(['sequential' /* TODO add 'quantile', 'quantize', 'threshold'*/]);\nvar CONTINUOUS_DOMAIN_INDEX = util_1.toSet(exports.CONTINUOUS_DOMAIN_SCALES);\nexports.DISCRETE_DOMAIN_SCALES = ['ordinal', 'bin-ordinal', 'point', 'band'];\nvar DISCRETE_DOMAIN_INDEX = util_1.toSet(exports.DISCRETE_DOMAIN_SCALES);\nvar BIN_SCALES_INDEX = util_1.toSet(['bin-linear', 'bin-ordinal']);\nexports.TIME_SCALE_TYPES = ['time', 'utc'];\nfunction hasDiscreteDomain(type) {\n    return type in DISCRETE_DOMAIN_INDEX;\n}\nexports.hasDiscreteDomain = hasDiscreteDomain;\nfunction isBinScale(type) {\n    return type in BIN_SCALES_INDEX;\n}\nexports.isBinScale = isBinScale;\nfunction hasContinuousDomain(type) {\n    return type in CONTINUOUS_DOMAIN_INDEX;\n}\nexports.hasContinuousDomain = hasContinuousDomain;\nfunction isContinuousToContinuous(type) {\n    return type in CONTINUOUS_TO_CONTINUOUS_INDEX;\n}\nexports.isContinuousToContinuous = isContinuousToContinuous;\nexports.defaultScaleConfig = {\n    textXRangeStep: 90,\n    rangeStep: 21,\n    pointPadding: 0.5,\n    bandPaddingInner: 0.1,\n    facetSpacing: 16,\n    minBandSize: 2,\n    minFontSize: 8,\n    maxFontSize: 40,\n    minOpacity: 0.3,\n    maxOpacity: 0.8,\n    // FIXME: revise if these *can* become ratios of rangeStep\n    minSize: 9,\n    minStrokeWidth: 1,\n    maxStrokeWidth: 4\n};\nfunction isExtendedScheme(scheme) {\n    return scheme && !!scheme['name'];\n}\nexports.isExtendedScheme = isExtendedScheme;\nfunction isSelectionDomain(domain) {\n    return domain && domain['selection'];\n}\nexports.isSelectionDomain = isSelectionDomain;\nvar SCALE_PROPERTY_INDEX = {\n    type: 1,\n    domain: 1,\n    range: 1,\n    rangeStep: 1,\n    scheme: 1,\n    // Other properties\n    reverse: 1,\n    round: 1,\n    // quantitative / time\n    clamp: 1,\n    nice: 1,\n    // quantitative\n    base: 1,\n    exponent: 1,\n    interpolate: 1,\n    zero: 1,\n    // band/point\n    padding: 1,\n    paddingInner: 1,\n    paddingOuter: 1\n};\nexports.SCALE_PROPERTIES = util_1.flagKeys(SCALE_PROPERTY_INDEX);\nvar type = SCALE_PROPERTY_INDEX.type, domain = SCALE_PROPERTY_INDEX.domain, range = SCALE_PROPERTY_INDEX.range, rangeStep = SCALE_PROPERTY_INDEX.rangeStep, scheme = SCALE_PROPERTY_INDEX.scheme, NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX = tslib_1.__rest(SCALE_PROPERTY_INDEX, [\"type\", \"domain\", \"range\", \"rangeStep\", \"scheme\"]);\nexports.NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTIES = util_1.flagKeys(NON_TYPE_DOMAIN_RANGE_VEGA_SCALE_PROPERTY_INDEX);\nfunction scaleTypeSupportProperty(scaleType, propName) {\n    switch (propName) {\n        case 'type':\n        case 'domain':\n        case 'reverse':\n        case 'range':\n            return true;\n        case 'scheme':\n            return util_1.contains(['sequential', 'ordinal', 'bin-ordinal', 'quantile', 'quantize'], scaleType);\n        case 'interpolate':\n            // FIXME(https://github.com/vega/vega-lite/issues/2902) how about ordinal?\n            return util_1.contains(['linear', 'bin-linear', 'pow', 'log', 'sqrt', 'utc', 'time'], scaleType);\n        case 'round':\n            return isContinuousToContinuous(scaleType) || scaleType === 'band' || scaleType === 'point';\n        case 'rangeStep':\n        case 'padding':\n        case 'paddingOuter':\n            return util_1.contains(['point', 'band'], scaleType);\n        case 'paddingInner':\n            return scaleType === 'band';\n        case 'clamp':\n            return isContinuousToContinuous(scaleType) || scaleType === 'sequential';\n        case 'nice':\n            return isContinuousToContinuous(scaleType) || scaleType === 'sequential' || scaleType === 'quantize';\n        case 'exponent':\n            return scaleType === 'pow';\n        case 'base':\n            return scaleType === 'log';\n        case 'zero':\n            return hasContinuousDomain(scaleType) && !util_1.contains([\n                'log',\n                'time', 'utc',\n                'bin-linear',\n                'threshold',\n                'quantile' // quantile depends on distribution so zero does not matter\n            ], scaleType);\n    }\n    /* istanbul ignore next: should never reach here*/\n    throw new Error(\"Invalid scale property \" + propName + \".\");\n}\nexports.scaleTypeSupportProperty = scaleTypeSupportProperty;\n/**\n * Returns undefined if the input channel supports the input scale property name\n */\nfunction channelScalePropertyIncompatability(channel, propName) {\n    switch (propName) {\n        case 'range':\n            // User should not customize range for position and facet channel directly.\n            if (channel === 'x' || channel === 'y') {\n                return log.message.CANNOT_USE_RANGE_WITH_POSITION;\n            }\n            return undefined; // GOOD!\n        case 'interpolate':\n        case 'scheme':\n            if (channel !== 'color') {\n                return log.message.cannotUseScalePropertyWithNonColor(channel);\n            }\n            return undefined;\n        case 'type':\n        case 'domain':\n        case 'base':\n        case 'exponent':\n        case 'nice':\n        case 'padding':\n        case 'paddingInner':\n        case 'paddingOuter':\n        case 'rangeStep':\n        case 'reverse':\n        case 'round':\n        case 'clamp':\n        case 'zero':\n            return undefined; // GOOD!\n    }\n    /* istanbul ignore next: it should never reach here */\n    throw new Error(\"Invalid scale property \\\"\" + propName + \"\\\".\");\n}\nexports.channelScalePropertyIncompatability = channelScalePropertyIncompatability;\nfunction channelSupportScaleType(channel, scaleType) {\n    switch (channel) {\n        case channel_1.Channel.X:\n        case channel_1.Channel.Y:\n        case channel_1.Channel.SIZE: // TODO: size and opacity can support ordinal with more modification\n        case channel_1.Channel.OPACITY:\n            // Although it generally doesn't make sense to use band with size and opacity,\n            // it can also work since we use band: 0.5 to get midpoint.\n            return isContinuousToContinuous(scaleType) || util_1.contains(['band', 'point'], scaleType);\n        case channel_1.Channel.COLOR:\n            return scaleType !== 'band'; // band does not make sense with color\n        case channel_1.Channel.SHAPE:\n            return scaleType === 'ordinal'; // shape = lookup only\n    }\n    /* istanbul ignore next: it should never reach here */\n    return false;\n}\nexports.channelSupportScaleType = channelSupportScaleType;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhbGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc2NhbGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQWtDO0FBR2xDLDJCQUE2QjtBQUM3QiwrQkFBNkQ7QUFFN0QsSUFBaUIsU0FBUyxDQXNCekI7QUF0QkQsV0FBaUIsU0FBUztJQUN4Qiw0QkFBNEI7SUFDZixnQkFBTSxHQUFhLFFBQVEsQ0FBQztJQUM1QixvQkFBVSxHQUFpQixZQUFZLENBQUM7SUFDeEMsYUFBRyxHQUFVLEtBQUssQ0FBQztJQUNuQixhQUFHLEdBQVUsS0FBSyxDQUFDO0lBQ25CLGNBQUksR0FBVyxNQUFNLENBQUM7SUFDbkMsb0JBQW9CO0lBQ1AsY0FBSSxHQUFXLE1BQU0sQ0FBQztJQUN0QixhQUFHLEdBQVcsS0FBSyxDQUFDO0lBQ2pDLGFBQWE7SUFDQSxvQkFBVSxHQUFpQixZQUFZLENBQUM7SUFFckQsZ0NBQWdDO0lBQ25CLGtCQUFRLEdBQWUsVUFBVSxDQUFDO0lBQ2xDLGtCQUFRLEdBQWUsVUFBVSxDQUFDO0lBQ2xDLG1CQUFTLEdBQWdCLFdBQVcsQ0FBQztJQUVyQyxpQkFBTyxHQUFjLFNBQVMsQ0FBQztJQUMvQixxQkFBVyxHQUFrQixhQUFhLENBQUM7SUFDM0MsZUFBSyxHQUFZLE9BQU8sQ0FBQztJQUN6QixjQUFJLEdBQVcsTUFBTSxDQUFDO0FBQ3JDLENBQUMsRUF0QmdCLFNBQVMsR0FBVCxpQkFBUyxLQUFULGlCQUFTLFFBc0J6QjtBQVVEOzs7R0FHRztBQUNILElBQU0sb0JBQW9CLEdBR3RCO0lBQ0YsTUFBTSxFQUFFLFNBQVM7SUFDakIsR0FBRyxFQUFFLFNBQVM7SUFDZCxHQUFHLEVBQUUsU0FBUztJQUNkLElBQUksRUFBRSxTQUFTO0lBQ2YsWUFBWSxFQUFFLFlBQVk7SUFDMUIsSUFBSSxFQUFFLE1BQU07SUFDWixHQUFHLEVBQUUsTUFBTTtJQUNYLFVBQVUsRUFBRSxZQUFZO0lBQ3hCLE9BQU8sRUFBRSxT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",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar datetime_1 = require(\"./datetime\");\nvar log = require(\"./log\");\nvar util_1 = require(\"./util\");\nvar TimeUnit;\n(function (TimeUnit) {\n    TimeUnit.YEAR = 'year';\n    TimeUnit.MONTH = 'month';\n    TimeUnit.DAY = 'day';\n    TimeUnit.DATE = 'date';\n    TimeUnit.HOURS = 'hours';\n    TimeUnit.MINUTES = 'minutes';\n    TimeUnit.SECONDS = 'seconds';\n    TimeUnit.MILLISECONDS = 'milliseconds';\n    TimeUnit.YEARMONTH = 'yearmonth';\n    TimeUnit.YEARMONTHDATE = 'yearmonthdate';\n    TimeUnit.YEARMONTHDATEHOURS = 'yearmonthdatehours';\n    TimeUnit.YEARMONTHDATEHOURSMINUTES = 'yearmonthdatehoursminutes';\n    TimeUnit.YEARMONTHDATEHOURSMINUTESSECONDS = 'yearmonthdatehoursminutesseconds';\n    // MONTHDATE always include 29 February since we use year 0th (which is a leap year);\n    TimeUnit.MONTHDATE = 'monthdate';\n    TimeUnit.HOURSMINUTES = 'hoursminutes';\n    TimeUnit.HOURSMINUTESSECONDS = 'hoursminutesseconds';\n    TimeUnit.MINUTESSECONDS = 'minutesseconds';\n    TimeUnit.SECONDSMILLISECONDS = 'secondsmilliseconds';\n    TimeUnit.QUARTER = 'quarter';\n    TimeUnit.YEARQUARTER = 'yearquarter';\n    TimeUnit.QUARTERMONTH = 'quartermonth';\n    TimeUnit.YEARQUARTERMONTH = 'yearquartermonth';\n    TimeUnit.UTCYEAR = 'utcyear';\n    TimeUnit.UTCMONTH = 'utcmonth';\n    TimeUnit.UTCDAY = 'utcday';\n    TimeUnit.UTCDATE = 'utcdate';\n    TimeUnit.UTCHOURS = 'utchours';\n    TimeUnit.UTCMINUTES = 'utcminutes';\n    TimeUnit.UTCSECONDS = 'utcseconds';\n    TimeUnit.UTCMILLISECONDS = 'utcmilliseconds';\n    TimeUnit.UTCYEARMONTH = 'utcyearmonth';\n    TimeUnit.UTCYEARMONTHDATE = 'utcyearmonthdate';\n    TimeUnit.UTCYEARMONTHDATEHOURS = 'utcyearmonthdatehours';\n    TimeUnit.UTCYEARMONTHDATEHOURSMINUTES = 'utcyearmonthdatehoursminutes';\n    TimeUnit.UTCYEARMONTHDATEHOURSMINUTESSECONDS = 'utcyearmonthdatehoursminutesseconds';\n    // MONTHDATE always include 29 February since we use year 0th (which is a leap year);\n    TimeUnit.UTCMONTHDATE = 'utcmonthdate';\n    TimeUnit.UTCHOURSMINUTES = 'utchoursminutes';\n    TimeUnit.UTCHOURSMINUTESSECONDS = 'utchoursminutesseconds';\n    TimeUnit.UTCMINUTESSECONDS = 'utcminutesseconds';\n    TimeUnit.UTCSECONDSMILLISECONDS = 'utcsecondsmilliseconds';\n    TimeUnit.UTCQUARTER = 'utcquarter';\n    TimeUnit.UTCYEARQUARTER = 'utcyearquarter';\n    TimeUnit.UTCQUARTERMONTH = 'utcquartermonth';\n    TimeUnit.UTCYEARQUARTERMONTH = 'utcyearquartermonth';\n})(TimeUnit = exports.TimeUnit || (exports.TimeUnit = {}));\n/** Time Unit that only corresponds to only one part of Date objects. */\nvar LOCAL_SINGLE_TIMEUNIT_INDEX = {\n    year: 1,\n    quarter: 1,\n    month: 1,\n    day: 1,\n    date: 1,\n    hours: 1,\n    minutes: 1,\n    seconds: 1,\n    milliseconds: 1\n};\nexports.TIMEUNIT_PARTS = util_1.flagKeys(LOCAL_SINGLE_TIMEUNIT_INDEX);\nfunction isLocalSingleTimeUnit(timeUnit) {\n    return !!LOCAL_SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\nexports.isLocalSingleTimeUnit = isLocalSingleTimeUnit;\nvar UTC_SINGLE_TIMEUNIT_INDEX = {\n    utcyear: 1,\n    utcquarter: 1,\n    utcmonth: 1,\n    utcday: 1,\n    utcdate: 1,\n    utchours: 1,\n    utcminutes: 1,\n    utcseconds: 1,\n    utcmilliseconds: 1\n};\nfunction isUtcSingleTimeUnit(timeUnit) {\n    return !!UTC_SINGLE_TIMEUNIT_INDEX[timeUnit];\n}\nexports.isUtcSingleTimeUnit = isUtcSingleTimeUnit;\nvar LOCAL_MULTI_TIMEUNIT_INDEX = {\n    yearquarter: 1,\n    yearquartermonth: 1,\n    yearmonth: 1,\n    yearmonthdate: 1,\n    yearmonthdatehours: 1,\n    yearmonthdatehoursminutes: 1,\n    yearmonthdatehoursminutesseconds: 1,\n    quartermonth: 1,\n    monthdate: 1,\n    hoursminutes: 1,\n    hoursminutesseconds: 1,\n    minutesseconds: 1,\n    secondsmilliseconds: 1\n};\nvar UTC_MULTI_TIMEUNIT_INDEX = {\n    utcyearquarter: 1,\n    utcyearquartermonth: 1,\n    utcyearmonth: 1,\n    utcyearmonthdate: 1,\n    utcyearmonthdatehours: 1,\n    utcyearmonthdatehoursminutes: 1,\n    utcyearmonthdatehoursminutesseconds: 1,\n    utcquartermonth: 1,\n    utcmonthdate: 1,\n    utchoursminutes: 1,\n    utchoursminutesseconds: 1,\n    utcminutesseconds: 1,\n    utcsecondsmilliseconds: 1\n};\nvar UTC_TIMEUNIT_INDEX = tslib_1.__assign({}, UTC_SINGLE_TIMEUNIT_INDEX, UTC_MULTI_TIMEUNIT_INDEX);\nfunction isUTCTimeUnit(t) {\n    return !!UTC_TIMEUNIT_INDEX[t];\n}\nexports.isUTCTimeUnit = isUTCTimeUnit;\nfunction getLocalTimeUnit(t) {\n    return t.substr(3);\n}\nexports.getLocalTimeUnit = getLocalTimeUnit;\nvar TIMEUNIT_INDEX = tslib_1.__assign({}, LOCAL_SINGLE_TIMEUNIT_INDEX, UTC_SINGLE_TIMEUNIT_INDEX, LOCAL_MULTI_TIMEUNIT_INDEX, UTC_MULTI_TIMEUNIT_INDEX);\nexports.TIMEUNITS = util_1.flagKeys(TIMEUNIT_INDEX);\nfunction isTimeUnit(t) {\n    return !!TIMEUNIT_INDEX[t];\n}\nexports.isTimeUnit = isTimeUnit;\nvar SET_DATE_METHOD = {\n    year: 'setFullYear',\n    month: 'setMonth',\n    date: 'setDate',\n    hours: 'setHours',\n    minutes: 'setMinutes',\n    seconds: 'setSeconds',\n    milliseconds: 'setMilliseconds',\n    // Day and quarter have their own special cases\n    quarter: null,\n    day: null,\n};\n/**\n * Converts a date to only have the measurements relevant to the specified unit\n * i.e. ('yearmonth', '2000-12-04 07:58:14') -> '2000-12-01 00:00:00'\n * Note: the base date is Jan 01 1900 00:00:00\n */\nfunction convert(unit, date) {\n    var isUTC = isUTCTimeUnit(unit);\n    var result = isUTC ?\n        // start with uniform date\n        new Date(Date.UTC(0, 0, 1, 0, 0, 0, 0)) :\n        new Date(0, 0, 1, 0, 0, 0, 0);\n    exports.TIMEUNIT_PARTS.forEach(function (timeUnitPart) {\n        if (containsTimeUnit(unit, timeUnitPart)) {\n            switch (timeUnitPart) {\n                case TimeUnit.DAY:\n                    throw new Error('Cannot convert to TimeUnits containing \\'day\\'');\n                case TimeUnit.QUARTER: {\n                    var _a = dateMethods('month', isUTC), getDateMethod_1 = _a.getDateMethod, setDateMethod_1 = _a.setDateMethod;\n                    // indicate quarter by setting month to be the first of the quarter i.e. may (4) -> april (3)\n                    result[setDateMethod_1]((Math.floor(date[getDateMethod_1]() / 3)) * 3);\n                    break;\n                }\n                default:\n                    var _b = dateMethods(timeUnitPart, isUTC), getDateMethod = _b.getDateMethod, setDateMethod = _b.setDateMethod;\n                    result[setDateMethod](date[getDateMethod]());\n            }\n        }\n    });\n    return result;\n}\nexports.convert = convert;\nfunction dateMethods(singleUnit, isUtc) {\n    var rawSetDateMethod = SET_DATE_METHOD[singleUnit];\n    var setDateMethod = isUtc ? 'setUTC' + rawSetDateMethod.substr(3) : rawSetDateMethod;\n    var getDateMethod = 'get' + (isUtc ? 'UTC' : '') + rawSetDateMethod.substr(3);\n    return { setDateMethod: setDateMethod, getDateMethod: getDateMethod };\n}\n/** Returns true if fullTimeUnit contains the timeUnit, false otherwise. */\nfunction containsTimeUnit(fullTimeUnit, timeUnit) {\n    var index = fullTimeUnit.indexOf(timeUnit);\n    return index > -1 &&\n        (timeUnit !== TimeUnit.SECONDS ||\n            index === 0 ||\n            fullTimeUnit.charAt(index - 1) !== 'i' // exclude milliseconds\n        );\n}\nexports.containsTimeUnit = containsTimeUnit;\n/**\n * Returns Vega expresssion for a given timeUnit and fieldRef\n */\nfunction fieldExpr(fullTimeUnit, field) {\n    var fieldRef = \"datum[\" + util_1.stringValue(field) + \"]\";\n    var utc = isUTCTimeUnit(fullTimeUnit) ? 'utc' : '';\n    function func(timeUnit) {\n        if (timeUnit === TimeUnit.QUARTER) {\n            // quarter starting at 0 (0,3,6,9).\n            return \"(\" + utc + \"quarter(\" + fieldRef + \")-1)\";\n        }\n        else {\n            return \"\" + utc + timeUnit + \"(\" + fieldRef + \")\";\n        }\n    }\n    var d = exports.TIMEUNIT_PARTS.reduce(function (dateExpr, tu) {\n        if (containsTimeUnit(fullTimeUnit, tu)) {\n            dateExpr[tu] = func(tu);\n        }\n        return dateExpr;\n    }, {});\n    return datetime_1.dateTimeExpr(d);\n}\nexports.fieldExpr = fieldExpr;\n/** returns the smallest nice unit for scale.nice */\nfunction smallestUnit(timeUnit) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        return 'second';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        return 'minute';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        return 'hour';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY) ||\n        containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        return 'day';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        return 'month';\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.YEAR)) {\n        return 'year';\n    }\n    return undefined;\n}\nexports.smallestUnit = smallestUnit;\n/**\n * returns the signal expression used for axis labels for a time unit\n */\nfunction formatExpression(timeUnit, field, shortTimeLabels, isUTCScale) {\n    if (!timeUnit) {\n        return undefined;\n    }\n    var dateComponents = [];\n    var expression = '';\n    var hasYear = containsTimeUnit(timeUnit, TimeUnit.YEAR);\n    if (containsTimeUnit(timeUnit, TimeUnit.QUARTER)) {\n        // special expression for quarter as prefix\n        expression = \"'Q' + quarter(\" + field + \")\";\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MONTH)) {\n        // By default use short month name\n        dateComponents.push(shortTimeLabels !== false ? '%b' : '%B');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.DAY)) {\n        dateComponents.push(shortTimeLabels ? '%a' : '%A');\n    }\n    else if (containsTimeUnit(timeUnit, TimeUnit.DATE)) {\n        dateComponents.push('%d' + (hasYear ? ',' : '')); // add comma if there is year\n    }\n    if (hasYear) {\n        dateComponents.push(shortTimeLabels ? '%y' : '%Y');\n    }\n    var timeComponents = [];\n    if (containsTimeUnit(timeUnit, TimeUnit.HOURS)) {\n        timeComponents.push('%H');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MINUTES)) {\n        timeComponents.push('%M');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.SECONDS)) {\n        timeComponents.push('%S');\n    }\n    if (containsTimeUnit(timeUnit, TimeUnit.MILLISECONDS)) {\n        timeComponents.push('%L');\n    }\n    var dateTimeComponents = [];\n    if (dateComponents.length > 0) {\n        dateTimeComponents.push(dateComponents.join(' '));\n    }\n    if (timeComponents.length > 0) {\n        dateTimeComponents.push(timeComponents.join(':'));\n    }\n    if (dateTimeComponents.length > 0) {\n        if (expression) {\n            // Add space between quarter and main time format\n            expression += \" + ' ' + \";\n        }\n        // We only use utcFormat for utc scale\n        // For utc time units, the data is already converted as a part of timeUnit transform.\n        // Thus, utc time units should use timeFormat to avoid shifting the time twice.\n        if (isUTCScale) {\n            expression += \"utcFormat(\" + field + \", '\" + dateTimeComponents.join(' ') + \"')\";\n        }\n        else {\n            expression += \"timeFormat(\" + field + \", '\" + dateTimeComponents.join(' ') + \"')\";\n        }\n    }\n    // If expression is still an empty string, return undefined instead.\n    return expression || undefined;\n}\nexports.formatExpression = formatExpression;\nfunction normalizeTimeUnit(timeUnit) {\n    if (timeUnit !== 'day' && timeUnit.indexOf('day') >= 0) {\n        log.warn(log.message.dayReplacedWithDate(timeUnit));\n        return timeUnit.replace('day', 'date');\n    }\n    return timeUnit;\n}\nexports.normalizeTimeUnit = normalizeTimeUnit;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZXVuaXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdGltZXVuaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsdUNBQXNEO0FBQ3RELDJCQUE2QjtBQUU3QiwrQkFBbUQ7QUFFbkQsSUFBaUIsUUFBUSxDQWlEeEI7QUFqREQsV0FBaUIsUUFBUTtJQUNWLGFBQUksR0FBVyxNQUFNLENBQUM7SUFDdEIsY0FBSyxHQUFZLE9BQU8sQ0FBQztJQUN6QixZQUFHLEdBQVUsS0FBSyxDQUFDO0lBQ25CLGFBQUksR0FBVyxNQUFNLENBQUM7SUFDdEIsY0FBSyxHQUFZLE9BQU8sQ0FBQztJQUN6QixnQkFBTyxHQUFjLFNBQVMsQ0FBQztJQUMvQixnQkFBTyxHQUFjLFNBQVMsQ0FBQztJQUMvQixxQkFBWSxHQUFtQixjQUFjLENBQUM7SUFDOUMsa0JBQVMsR0FBZ0IsV0FBVyxDQUFDO0lBQ3JDLHNCQUFhLEdBQW9CLGVBQWUsQ0FBQztJQUNqRCwyQkFBa0IsR0FBeUIsb0JBQW9CLENBQUM7SUFDaEUsa0NBQXlCLEdBQWdDLDJCQUEyQixDQUFDO0lBQ3JGLHlDQUFnQyxHQUF1QyxrQ0FBa0MsQ0FBQztJQUV2SCxxRkFBcUY7SUFDeEUsa0JBQVMsR0FBZ0IsV0FBVyxDQUFDO0lBQ3JDLHFCQUFZLEdBQW1CLGNBQWMsQ0FBQztJQUM5Qyw0QkFBbUIsR0FBMEIscUJBQXFCLENBQUM7SUFDbkUsdUJBQWMsR0FBcUIsZ0JBQWdCLENBQUM7SUFDcEQsNEJBQW1CLEdBQTBCLHFCQUFxQixDQUFDO0lBQ25FLGdCQUFPLEdBQWMsU0FBUyxDQUFDO0lBQy9CLG9CQUFXLEdBQWtCLGFBQWEsQ0FBQztJQUMzQyxxQkFBWSxHQUFtQixjQUFjLENBQUM7SUFDOUMseUJBQWdCLEdBQXVCLGtCQUFrQixDQUFDO0lBQzFELGdCQUFPLEdBQWMsU0FBUyxDQUFDO0lBQy9CLGlCQUFRLEdBQWUsVUFBVSxDQUFDO0lBQ2xDLGVBQU0sR0FBYSxRQUFR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",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Constants and utilities for data type */\n/** Data type based on level of measurement */\nvar Type;\n(function (Type) {\n    Type.QUANTITATIVE = 'quantitative';\n    Type.ORDINAL = 'ordinal';\n    Type.TEMPORAL = 'temporal';\n    Type.NOMINAL = 'nominal';\n})(Type = exports.Type || (exports.Type = {}));\nvar TYPE_INDEX = {\n    quantitative: 1,\n    ordinal: 1,\n    temporal: 1,\n    nominal: 1\n};\nfunction isType(t) {\n    return !!TYPE_INDEX[t];\n}\nexports.isType = isType;\nexports.QUANTITATIVE = Type.QUANTITATIVE;\nexports.ORDINAL = Type.ORDINAL;\nexports.TEMPORAL = Type.TEMPORAL;\nexports.NOMINAL = Type.NOMINAL;\n/**\n * Get full, lowercase type name for a given type.\n * @param  type\n * @return Full type name.\n */\nfunction getFullName(type) {\n    if (type) {\n        type = type.toLowerCase();\n        switch (type) {\n            case 'q':\n            case exports.QUANTITATIVE:\n                return 'quantitative';\n            case 't':\n            case exports.TEMPORAL:\n                return 'temporal';\n            case 'o':\n            case exports.ORDINAL:\n                return 'ordinal';\n            case 'n':\n            case exports.NOMINAL:\n                return 'nominal';\n        }\n    }\n    // If we get invalid input, return undefined type.\n    return undefined;\n}\nexports.getFullName = getFullName;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy90eXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0EsNENBQTRDO0FBQzVDLDhDQUE4QztBQUU5QyxJQUFpQixJQUFJLENBS3BCO0FBTEQsV0FBaUIsSUFBSTtJQUNOLGlCQUFZLEdBQW1CLGNBQWMsQ0FBQztJQUM5QyxZQUFPLEdBQWMsU0FBUyxDQUFDO0lBQy9CLGFBQVEsR0FBZSxVQUFVLENBQUM7SUFDbEMsWUFBTyxHQUFjLFNBQVMsQ0FBQztBQUM5QyxDQUFDLEVBTGdCLElBQUksR0FBSixZQUFJLEtBQUosWUFBSSxRQUtwQjtBQUdELElBQU0sVUFBVSxHQUFlO0lBQzdCLFlBQVksRUFBRSxDQUFDO0lBQ2YsT0FBTyxFQUFFLENBQUM7SUFDVixRQUFRLEVBQUUsQ0FBQztJQUNYLE9BQU8sRUFBRSxDQUFDO0NBQ1gsQ0FBQztBQUVGLGdCQUF1QixDQUFNO0lBQzNCLE1BQU0sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLENBQUM7QUFGRCx3QkFFQztBQUVZLFFBQUEsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUM7QUFDakMsUUFBQSxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztBQUN2QixRQUFBLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0FBQ3pCLFFBQUEsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7QUFFcEM7Ozs7R0FJRztBQUNILHFCQUE0QixJQUFpQjtJQUMzQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ1QsSUFBSSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUMxQixNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2IsS0FBSyxHQUFHLENBQUM7WUFDVCxLQUFLLG9CQUFZO2dCQUNmLE1BQU0sQ0FBQyxjQUFjLENBQUM7WUFDeEIsS0FBSyxHQUFHLENBQUM7WUFDVCxLQUFLLGdCQUFRO2dCQUNYLE1BQU0sQ0FBQyxVQUFVLENBQUM7WUFDcEIsS0FBSyxHQUFHLENBQUM7WUFDVCxLQUFLLGVBQU87Z0JBQ1YsTUFBTSxDQUFDLFNBQVMsQ0FBQztZQUNuQixLQUFLLEdBQUcsQ0FBQztZQUNULEtBQUssZUFBTztnQkFDVixNQUFNLENBQUMsU0FBUyxDQUFDO1FBQ3JCLENBQUM7SUFDSCxDQUFDO0lBQ0Qsa0RBQWtEO0lBQ2xELE1BQU0sQ0FBQyxTQUFTLENBQUM7QUFDbkIsQ0FBQztBQXBCRCxrQ0FvQkMifQ==",
    "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar stringify = require(\"json-stable-stringify\");\nvar vega_util_1 = require(\"vega-util\");\nvar logical_1 = require(\"./logical\");\nvar vega_util_2 = require(\"vega-util\");\nexports.isArray = vega_util_2.isArray;\nexports.isObject = vega_util_2.isObject;\nexports.isNumber = vega_util_2.isNumber;\nexports.isString = vega_util_2.isString;\nexports.truncate = vega_util_2.truncate;\nexports.toSet = vega_util_2.toSet;\nexports.stringValue = vega_util_2.stringValue;\n/**\n * Creates an object composed of the picked object properties.\n *\n * Example:  (from lodash)\n *\n * var object = {'a': 1, 'b': '2', 'c': 3};\n * pick(object, ['a', 'c']);\n * // → {'a': 1, 'c': 3}\n *\n */\nfunction pick(obj, props) {\n    var copy = {};\n    props.forEach(function (prop) {\n        if (obj.hasOwnProperty(prop)) {\n            copy[prop] = obj[prop];\n        }\n    });\n    return copy;\n}\nexports.pick = pick;\n/**\n * The opposite of _.pick; this method creates an object composed of the own\n * and inherited enumerable string keyed properties of object that are not omitted.\n */\nfunction omit(obj, props) {\n    var copy = duplicate(obj);\n    props.forEach(function (prop) {\n        delete copy[prop];\n    });\n    return copy;\n}\nexports.omit = omit;\nfunction hash(a) {\n    if (vega_util_1.isString(a) || vega_util_1.isNumber(a) || isBoolean(a)) {\n        return String(a);\n    }\n    return stringify(a);\n}\nexports.hash = hash;\nfunction contains(array, item) {\n    return array.indexOf(item) > -1;\n}\nexports.contains = contains;\n/** Returns the array without the elements in item */\nfunction without(array, excludedItems) {\n    return array.filter(function (item) { return !contains(excludedItems, item); });\n}\nexports.without = without;\nfunction union(array, other) {\n    return array.concat(without(other, array));\n}\nexports.union = union;\n/**\n * Returns true if any item returns true.\n */\nfunction some(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (f(arr[k], k, i++)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.some = some;\n/**\n * Returns true if all items return true.\n */\nfunction every(arr, f) {\n    var i = 0;\n    for (var k = 0; k < arr.length; k++) {\n        if (!f(arr[k], k, i++)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.every = every;\nfunction flatten(arrays) {\n    return [].concat.apply([], arrays);\n}\nexports.flatten = flatten;\n/**\n * recursively merges src into dest\n */\nfunction mergeDeep(dest) {\n    var src = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        src[_i - 1] = arguments[_i];\n    }\n    for (var _a = 0, src_1 = src; _a < src_1.length; _a++) {\n        var s = src_1[_a];\n        dest = deepMerge_(dest, s);\n    }\n    return dest;\n}\nexports.mergeDeep = mergeDeep;\n// recursively merges src into dest\nfunction deepMerge_(dest, src) {\n    if (typeof src !== 'object' || src === null) {\n        return dest;\n    }\n    for (var p in src) {\n        if (!src.hasOwnProperty(p)) {\n            continue;\n        }\n        if (src[p] === undefined) {\n            continue;\n        }\n        if (typeof src[p] !== 'object' || vega_util_1.isArray(src[p]) || src[p] === null) {\n            dest[p] = src[p];\n        }\n        else if (typeof dest[p] !== 'object' || dest[p] === null) {\n            dest[p] = mergeDeep(vega_util_1.isArray(src[p].constructor) ? [] : {}, src[p]);\n        }\n        else {\n            mergeDeep(dest[p], src[p]);\n        }\n    }\n    return dest;\n}\nfunction unique(values, f) {\n    var results = [];\n    var u = {};\n    var v;\n    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n        var val = values_1[_i];\n        v = f(val);\n        if (v in u) {\n            continue;\n        }\n        u[v] = 1;\n        results.push(val);\n    }\n    return results;\n}\nexports.unique = unique;\n/**\n * Returns true if the two dictionaries disagree. Applies only to defined values.\n */\nfunction differ(dict, other) {\n    for (var key in dict) {\n        if (dict.hasOwnProperty(key)) {\n            if (other[key] && dict[key] && other[key] !== dict[key]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexports.differ = differ;\nfunction hasIntersection(a, b) {\n    for (var key in a) {\n        if (key in b) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.hasIntersection = hasIntersection;\nfunction differArray(array, other) {\n    if (array.length !== other.length) {\n        return true;\n    }\n    array.sort();\n    other.sort();\n    for (var i = 0; i < array.length; i++) {\n        if (other[i] !== array[i]) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.differArray = differArray;\nexports.keys = Object.keys;\nfunction vals(x) {\n    var _vals = [];\n    for (var k in x) {\n        if (x.hasOwnProperty(k)) {\n            _vals.push(x[k]);\n        }\n    }\n    return _vals;\n}\nexports.vals = vals;\nfunction flagKeys(f) {\n    return exports.keys(f);\n}\nexports.flagKeys = flagKeys;\nfunction duplicate(obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nexports.duplicate = duplicate;\nfunction isBoolean(b) {\n    return b === true || b === false;\n}\nexports.isBoolean = isBoolean;\n/**\n * Convert a string into a valid variable name\n */\nfunction varName(s) {\n    // Replace non-alphanumeric characters (anything besides a-zA-Z0-9_) with _\n    var alphanumericS = s.replace(/\\W/g, '_');\n    // Add _ if the string has leading numbers.\n    return (s.match(/^\\d+/) ? '_' : '') + alphanumericS;\n}\nexports.varName = varName;\nfunction logicalExpr(op, cb) {\n    if (logical_1.isLogicalNot(op)) {\n        return '!(' + logicalExpr(op.not, cb) + ')';\n    }\n    else if (logical_1.isLogicalAnd(op)) {\n        return '(' + op.and.map(function (and) { return logicalExpr(and, cb); }).join(') && (') + ')';\n    }\n    else if (logical_1.isLogicalOr(op)) {\n        return '(' + op.or.map(function (or) { return logicalExpr(or, cb); }).join(') || (') + ')';\n    }\n    else {\n        return cb(op);\n    }\n}\nexports.logicalExpr = logicalExpr;\n/**\n * Delete nested property of an object, and delete the ancestors of the property if they become empty.\n */\nfunction deleteNestedProperty(obj, orderedProps) {\n    var isEmpty = true;\n    while (orderedProps.length > 0 && isEmpty) {\n        var o = obj;\n        for (var i = 0; i < orderedProps.length - 1; i++) {\n            o = o[orderedProps[i]];\n        }\n        delete o[orderedProps.pop()];\n        if (exports.keys(o).length !== 0) {\n            isEmpty = false;\n        }\n    }\n}\nexports.deleteNestedProperty = deleteNestedProperty;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaURBQW1EO0FBQ25ELHVDQUFzRDtBQUN0RCxxQ0FBa0Y7QUFHbEYsdUNBQThGO0FBQXRGLDhCQUFBLE9BQU8sQ0FBQTtBQUFFLCtCQUFBLFFBQVEsQ0FBQTtBQUFFLCtCQUFBLFFBQVEsQ0FBQTtBQUFFLCtCQUFBLFFBQVEsQ0FBQTtBQUFFLCtCQUFBLFFBQVEsQ0FBQTtBQUFFLDRCQUFBLEtBQUssQ0FBQTtBQUFFLGtDQUFBLFdBQVcsQ0FBQTtBQUUzRTs7Ozs7Ozs7O0dBU0c7QUFDSCxjQUFxQixHQUFXLEVBQUUsS0FBZTtJQUMvQyxJQUFNLElBQUksR0FBRyxFQUFFLENBQUM7SUFDaEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFDLElBQUk7UUFDakIsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN6QixDQUFDO0lBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDSCxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQVJELG9CQVFDO0FBRUQ7OztHQUdHO0FBQ0gsY0FBcUIsR0FBVyxFQUFFLEtBQWU7SUFDL0MsSUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzVCLEtBQUssQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BCLENBQUMsQ0FBQyxDQUFDO0lBQ0gsTUFBTSxDQUFDLElBQUksQ0FBQztBQUNkLENBQUM7QUFORCxvQkFNQztBQUVELGNBQXFCLENBQU07SUFDekIsRUFBRSxDQUFDLENBQUMsb0JBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxv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",
    "(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.vega = global.vega || {})));\n}(this, (function (exports) { 'use strict';\n\nvar accessor = function(fn, fields, name) {\n  fn.fields = fields || [];\n  fn.fname = name;\n  return fn;\n};\n\nfunction accessorName(fn) {\n  return fn == null ? null : fn.fname;\n}\n\nfunction accessorFields(fn) {\n  return fn == null ? null : fn.fields;\n}\n\nvar error = function(message) {\n  throw Error(message);\n};\n\nvar splitAccessPath = function(p) {\n  var path = [],\n      q = null,\n      b = 0,\n      n = p.length,\n      s = '',\n      i, j, c;\n\n  p = p + '';\n\n  function push() {\n    path.push(s + p.substring(i, j));\n    s = '';\n    i = j + 1;\n  }\n\n  for (i=j=0; j<n; ++j) {\n    c = p[j];\n    if (c === '\\\\') {\n      s += p.substring(i, j);\n      i = ++j;\n    } else if (c === q) {\n      push();\n      q = null;\n      b = -1;\n    } else if (q) {\n      continue;\n    } else if (i === b && c === '\"') {\n      i = j + 1;\n      q = c;\n    } else if (i === b && c === \"'\") {\n      i = j + 1;\n      q = c;\n    } else if (c === '.' && !b) {\n      if (j > i) {\n        push();\n      } else {\n        i = j + 1;\n      }\n    } else if (c === '[') {\n      if (j > i) push();\n      b = i = j + 1;\n    } else if (c === ']') {\n      if (!b) error('Access path missing open bracket: ' + p);\n      if (b > 0) push();\n      b = 0;\n      i = j + 1;\n    }\n  }\n\n  if (b) error('Access path missing closing bracket: ' + p);\n  if (q) error('Access path missing closing quote: ' + p);\n\n  if (j > i) {\n    j++;\n    push();\n  }\n\n  return path;\n};\n\nvar isArray = Array.isArray;\n\nvar isObject = function(_) {\n  return _ === Object(_);\n};\n\nvar isString = function(_) {\n  return typeof _ === 'string';\n};\n\nfunction $(x) {\n  return isArray(x) ? '[' + x.map($) + ']'\n    : isObject(x) || isString(x) ?\n      // Output valid JSON and JS source strings.\n      // See http://timelessrepo.com/json-isnt-a-javascript-subset\n      JSON.stringify(x).replace('\\u2028','\\\\u2028').replace('\\u2029', '\\\\u2029')\n    : x;\n}\n\nvar field = function(field, name) {\n  var path = splitAccessPath(field),\n      code = 'return _[' + path.map($).join('][') + '];';\n\n  return accessor(\n    Function('_', code),\n    [(field = path.length===1 ? path[0] : field)],\n    name || field\n  );\n};\n\nvar empty = [];\n\nvar id = field('id');\n\nvar identity = accessor(function(_) { return _; }, empty, 'identity');\n\nvar zero = accessor(function() { return 0; }, empty, 'zero');\n\nvar one = accessor(function() { return 1; }, empty, 'one');\n\nvar truthy = accessor(function() { return true; }, empty, 'true');\n\nvar falsy = accessor(function() { return false; }, empty, 'false');\n\nfunction log(method, level, input) {\n  var args = [level].concat([].slice.call(input));\n  console[method].apply(console, args); // eslint-disable-line no-console\n}\n\nvar None  = 0;\nvar Error$1 = 1;\nvar Warn  = 2;\nvar Info  = 3;\nvar Debug = 4;\n\nvar logger = function(_) {\n  var level = _ || None;\n  return {\n    level: function(_) {\n      if (arguments.length) {\n        level = +_;\n        return this;\n      } else {\n        return level;\n      }\n    },\n    error: function() {\n      if (level >= Error$1) log('error', 'ERROR', arguments);\n      return this;\n    },\n    warn: function() {\n      if (level >= Warn) log('warn', 'WARN', arguments);\n      return this;\n    },\n    info: function() {\n      if (level >= Info) log('log', 'INFO', arguments);\n      return this;\n    },\n    debug: function() {\n      if (level >= Debug) log('log', 'DEBUG', arguments);\n      return this;\n    }\n  }\n};\n\nvar array = function(_) {\n  return _ != null ? (isArray(_) ? _ : [_]) : [];\n};\n\nvar isFunction = function(_) {\n  return typeof _ === 'function';\n};\n\nvar compare = function(fields, orders) {\n  var idx = [],\n      cmp = (fields = array(fields)).map(function(f, i) {\n        if (f == null) {\n          return null;\n        } else {\n          idx.push(i);\n          return isFunction(f) ? f\n            : splitAccessPath(f).map($).join('][');\n        }\n      }),\n      n = idx.length - 1,\n      ord = array(orders),\n      code = 'var u,v;return ',\n      i, j, f, u, v, d, t, lt, gt;\n\n  if (n < 0) return null;\n\n  for (j=0; j<=n; ++j) {\n    i = idx[j];\n    f = cmp[i];\n\n    if (isFunction(f)) {\n      d = 'f' + i;\n      u = '(u=this.' + d + '(a))';\n      v = '(v=this.' + d + '(b))';\n      (t = t || {})[d] = f;\n    } else {\n      u = '(u=a['+f+'])';\n      v = '(v=b['+f+'])';\n    }\n\n    d = '((v=v instanceof Date?+v:v),(u=u instanceof Date?+u:u))';\n\n    if (ord[i] !== 'descending') {\n      gt = 1;\n      lt = -1;\n    } else {\n      gt = -1;\n      lt = 1;\n    }\n\n    code += '(' + u+'<'+v+'||u==null)&&v!=null?' + lt\n      + ':(u>v||v==null)&&u!=null?' + gt\n      + ':'+d+'!==u&&v===v?' + lt\n      + ':v!==v&&u===u?' + gt\n      + (i < n ? ':' : ':0');\n  }\n\n  f = Function('a', 'b', code + ';');\n  if (t) f = f.bind(t);\n\n  fields = fields.reduce(function(map, field) {\n    if (isFunction(field)) {\n      (accessorFields(field) || []).forEach(function(_) { map[_] = 1; });\n    } else if (field != null) {\n      map[field + ''] = 1;\n    }\n    return map;\n  }, {});\n\n  return accessor(f, Object.keys(fields));\n};\n\nvar constant = function(_) {\n  return isFunction(_) ? _ : function() { return _; };\n};\n\nvar debounce = function(delay, handler) {\n  var tid, evt;\n\n  function callback() {\n    handler(evt);\n    tid = evt = null;\n  }\n\n  return function(e) {\n    evt = e;\n    if (tid) clearTimeout(tid);\n    tid = setTimeout(callback, delay);\n  };\n};\n\nvar extend = function(_) {\n  for (var x, k, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (k in x) { _[k] = x[k]; }\n  }\n  return _;\n};\n\nvar extentIndex = function(array, f) {\n  var i = -1,\n      n = array.length,\n      a, b, c, u, v;\n\n  if (f == null) {\n    while (++i < n) {\n      b = array[i];\n      if (b != null && b >= b) {\n        a = c = b;\n        break;\n      }\n    }\n    u = v = i;\n    while (++i < n) {\n      b = array[i];\n      if (b != null) {\n        if (a > b) {\n          a = b;\n          u = i;\n        }\n        if (c < b) {\n          c = b;\n          v = i;\n        }\n      }\n    }\n  } else {\n    while (++i < n) {\n      b = f(array[i], i, array);\n      if (b != null && b >= b) {\n        a = c = b;\n        break;\n      }\n    }\n    u = v = i;\n    while (++i < n) {\n      b = f(array[i], i, array);\n      if (b != null) {\n        if (a > b) {\n          a = b;\n          u = i;\n        }\n        if (c < b) {\n          c = b;\n          v = i;\n        }\n      }\n    }\n  }\n\n  return [u, v];\n};\n\nvar NULL = {};\n\nvar fastmap = function(input) {\n  var obj = {},\n      map,\n      test;\n\n  function has(key) {\n    return obj.hasOwnProperty(key) && obj[key] !== NULL;\n  }\n\n  map = {\n    size: 0,\n    empty: 0,\n    object: obj,\n    has: has,\n    get: function(key) {\n      return has(key) ? obj[key] : undefined;\n    },\n    set: function(key, value) {\n      if (!has(key)) {\n        ++map.size;\n        if (obj[key] === NULL) --map.empty;\n      }\n      obj[key] = value;\n      return this;\n    },\n    delete: function(key) {\n      if (has(key)) {\n        --map.size;\n        ++map.empty;\n        obj[key] = NULL;\n      }\n      return this;\n    },\n    clear: function() {\n      map.size = map.empty = 0;\n      map.object = obj = {};\n    },\n    test: function(_) {\n      if (arguments.length) {\n        test = _;\n        return map;\n      } else {\n        return test;\n      }\n    },\n    clean: function() {\n      var next = {},\n          size = 0,\n          key, value;\n      for (key in obj) {\n        value = obj[key];\n        if (value !== NULL && (!test || !test(value))) {\n          next[key] = value;\n          ++size;\n        }\n      }\n      map.size = size;\n      map.empty = 0;\n      map.object = (obj = next);\n    }\n  };\n\n  if (input) Object.keys(input).forEach(function(key) {\n    map.set(key, input[key]);\n  });\n\n  return map;\n};\n\nvar inherits = function(child, parent) {\n  var proto = (child.prototype = Object.create(parent.prototype));\n  proto.constructor = child;\n  return proto;\n};\n\nvar isBoolean = function(_) {\n  return typeof _ === 'boolean';\n};\n\nvar isDate = function(_) {\n  return Object.prototype.toString.call(_) === '[object Date]';\n};\n\nvar isNumber = function(_) {\n  return typeof _ === 'number';\n};\n\nvar isRegExp = function(_) {\n  return Object.prototype.toString.call(_) === '[object RegExp]';\n};\n\nvar key = function(fields) {\n  fields = fields ? array(fields) : fields;\n  var fn = !(fields && fields.length)\n    ? function() { return ''; }\n    : Function('_', 'return \\'\\'+' +\n        fields.map(function(f) {\n          return '_[' + splitAccessPath(f).map($).join('][') + ']';\n        }).join('+\\'|\\'+') + ';');\n  return accessor(fn, fields, 'key');\n};\n\nvar merge = function(compare, array0, array1, output) {\n  var n0 = array0.length,\n      n1 = array1.length;\n\n  if (!n1) return array0;\n  if (!n0) return array1;\n\n  var merged = output || new array0.constructor(n0 + n1),\n      i0 = 0, i1 = 0, i = 0;\n\n  for (; i0<n0 && i1<n1; ++i) {\n    merged[i] = compare(array0[i0], array1[i1]) > 0\n       ? array1[i1++]\n       : array0[i0++];\n  }\n\n  for (; i0<n0; ++i0, ++i) {\n    merged[i] = array0[i0];\n  }\n\n  for (; i1<n1; ++i1, ++i) {\n    merged[i] = array1[i1];\n  }\n\n  return merged;\n};\n\nvar repeat = function(str, reps) {\n  var s = '';\n  while (--reps >= 0) s += str;\n  return s;\n};\n\nvar pad = function(str, length, padchar, align) {\n  var c = padchar || ' ',\n      s = str + '',\n      n = length - s.length;\n\n  return n <= 0 ? s\n    : align === 'left' ? repeat(c, n) + s\n    : align === 'center' ? repeat(c, ~~(n/2)) + s + repeat(c, Math.ceil(n/2))\n    : s + repeat(c, n);\n};\n\nvar peek = function(array) {\n  return array[array.length - 1];\n};\n\nvar toBoolean = function(_) {\n  return _ == null || _ === '' ? null : !_ || _ === 'false' || _ === '0' ? false : !!_;\n};\n\nfunction defaultParser(_) {\n  return isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);\n}\n\nvar toDate = function(_, parser) {\n  parser = parser || defaultParser;\n  return _ == null || _ === '' ? null : parser(_);\n};\n\nvar toNumber = function(_) {\n  return _ == null || _ === '' ? null : +_;\n};\n\nvar toString = function(_) {\n  return _ == null || _ === '' ? null : _ + '';\n};\n\nvar toSet = function(_) {\n  for (var s={}, i=0, n=_.length; i<n; ++i) s[_[i]] = 1;\n  return s;\n};\n\nvar truncate = function(str, length, align, ellipsis) {\n  var e = ellipsis != null ? ellipsis : '\\u2026',\n      s = str + '',\n      n = s.length,\n      l = Math.max(0, length - e.length);\n\n  return n <= length ? s\n    : align === 'left' ? e + s.slice(n - l)\n    : align === 'center' ? s.slice(0, Math.ceil(l/2)) + e + s.slice(n - ~~(l/2))\n    : s.slice(0, l) + e;\n};\n\nvar visitArray = function(array, filter, visitor) {\n  if (array) {\n    var i = 0, n = array.length, t;\n    if (filter) {\n      for (; i<n; ++i) {\n        if (t = filter(array[i])) visitor(t, i, array);\n      }\n    } else {\n      array.forEach(visitor);\n    }\n  }\n};\n\nexports.accessor = accessor;\nexports.accessorName = accessorName;\nexports.accessorFields = accessorFields;\nexports.id = id;\nexports.identity = identity;\nexports.zero = zero;\nexports.one = one;\nexports.truthy = truthy;\nexports.falsy = falsy;\nexports.logger = logger;\nexports.None = None;\nexports.Error = Error$1;\nexports.Warn = Warn;\nexports.Info = Info;\nexports.Debug = Debug;\nexports.array = array;\nexports.compare = compare;\nexports.constant = constant;\nexports.debounce = debounce;\nexports.error = error;\nexports.extend = extend;\nexports.extentIndex = extentIndex;\nexports.fastmap = fastmap;\nexports.field = field;\nexports.inherits = inherits;\nexports.isArray = isArray;\nexports.isBoolean = isBoolean;\nexports.isDate = isDate;\nexports.isFunction = isFunction;\nexports.isNumber = isNumber;\nexports.isObject = isObject;\nexports.isRegExp = isRegExp;\nexports.isString = isString;\nexports.key = key;\nexports.merge = merge;\nexports.pad = pad;\nexports.peek = peek;\nexports.repeat = repeat;\nexports.splitAccessPath = splitAccessPath;\nexports.stringValue = $;\nexports.toBoolean = toBoolean;\nexports.toDate = toDate;\nexports.toNumber = toNumber;\nexports.toString = toString;\nexports.toSet = toSet;\nexports.truncate = truncate;\nexports.visitArray = visitArray;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"
  ]
}